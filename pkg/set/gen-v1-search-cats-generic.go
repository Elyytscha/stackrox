// Code generated by genny. DO NOT EDIT.
// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/mauricelam/genny

package set

import "github.com/stackrox/rox/generated/api/v1"
import (
	"sort"

	"github.com/deckarep/golang-set"
)

// If you want to add a set for your custom type, simply add another go generate line along with the
// existing ones. If you're creating a set for a primitive type, you can follow the example of "string"
// and create the generated file in this package.
// Sometimes, you might need to create it in the same package where it is defined to avoid import cycles.
// The permission set is an example of how to do that.
// You can also specify the -imp command to specify additional imports in your generated file, if required.

// v1.SearchCategory represents a generic type that we want to have a set of.

// V1SearchCategorySet will get translated to generic sets.
// It uses mapset.Set as the underlying implementation, so it comes with a bunch
// of utility methods, and is thread-safe.
type V1SearchCategorySet struct {
	underlying mapset.Set
}

// Add adds an element of type v1.SearchCategory.
func (k V1SearchCategorySet) Add(i v1.SearchCategory) bool {
	if k.underlying == nil {
		k.underlying = mapset.NewSet()
	}

	return k.underlying.Add(i)
}

// Remove removes an element of type v1.SearchCategory.
func (k V1SearchCategorySet) Remove(i v1.SearchCategory) {
	if k.underlying != nil {
		k.underlying.Remove(i)
	}
}

// Contains returns whether the set contains an element of type v1.SearchCategory.
func (k V1SearchCategorySet) Contains(i v1.SearchCategory) bool {
	if k.underlying != nil {
		return k.underlying.Contains(i)
	}
	return false
}

// Cardinality returns the number of elements in the set.
func (k V1SearchCategorySet) Cardinality() int {
	if k.underlying != nil {
		return k.underlying.Cardinality()
	}
	return 0
}

// Difference returns a new set with all elements of k not in other.
func (k V1SearchCategorySet) Difference(other V1SearchCategorySet) V1SearchCategorySet {
	if k.underlying == nil {
		return V1SearchCategorySet{underlying: other.underlying}
	} else if other.underlying == nil {
		return V1SearchCategorySet{underlying: k.underlying}
	}

	return V1SearchCategorySet{underlying: k.underlying.Difference(other.underlying)}
}

// Intersect returns a new set with the intersection of the members of both sets.
func (k V1SearchCategorySet) Intersect(other V1SearchCategorySet) V1SearchCategorySet {
	if k.underlying != nil && other.underlying != nil {
		return V1SearchCategorySet{underlying: k.underlying.Intersect(other.underlying)}
	}
	return V1SearchCategorySet{}
}

// Union returns a new set with the union of the members of both sets.
func (k V1SearchCategorySet) Union(other V1SearchCategorySet) V1SearchCategorySet {
	if k.underlying == nil {
		return V1SearchCategorySet{underlying: other.underlying}
	} else if other.underlying == nil {
		return V1SearchCategorySet{underlying: k.underlying}
	}

	return V1SearchCategorySet{underlying: k.underlying.Union(other.underlying)}
}

// AsSlice returns a slice of the elements in the set. The order is unspecified.
func (k V1SearchCategorySet) AsSlice() []v1.SearchCategory {
	if k.underlying == nil {
		return nil
	}
	elems := make([]v1.SearchCategory, 0, k.Cardinality())
	for elem := range k.underlying.Iter() {
		elems = append(elems, elem.(v1.SearchCategory))
	}
	return elems
}

// AsSortedSlice returns a slice of the elements in the set, sorted using the passed less function.
func (k V1SearchCategorySet) AsSortedSlice(less func(i, j v1.SearchCategory) bool) []v1.SearchCategory {
	slice := k.AsSlice()
	if len(slice) < 2 {
		return slice
	}
	// Since we're generating the code, we might as well use sort.Sort
	// and avoid paying the reflection penalty of sort.Slice.
	sortable := &sortablev1SearchCategorySlice{slice: slice, less: less}
	sort.Sort(sortable)
	return sortable.slice
}

// IsInitialized returns whether the set has been initialized
func (k V1SearchCategorySet) IsInitialized() bool {
	return k.underlying != nil
}

// NewV1SearchCategorySet returns a new set with the given key type.
func NewV1SearchCategorySet(initial ...v1.SearchCategory) V1SearchCategorySet {
	k := V1SearchCategorySet{underlying: mapset.NewSet()}
	for _, elem := range initial {
		k.Add(elem)
	}
	return k
}

type sortablev1SearchCategorySlice struct {
	slice []v1.SearchCategory
	less  func(i, j v1.SearchCategory) bool
}

func (s *sortablev1SearchCategorySlice) Len() int {
	return len(s.slice)
}

func (s *sortablev1SearchCategorySlice) Less(i, j int) bool {
	return s.less(s.slice[i], s.slice[j])
}

func (s *sortablev1SearchCategorySlice) Swap(i, j int) {
	s.slice[j], s.slice[i] = s.slice[i], s.slice[j]
}
