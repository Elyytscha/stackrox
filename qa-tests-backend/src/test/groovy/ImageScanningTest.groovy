import common.Constants
import groups.BAT
import groups.Integration
import io.stackrox.proto.storage.ImageIntegrationOuterClass
import io.stackrox.proto.storage.ImageOuterClass
import objects.Deployment
import objects.Secret
import org.junit.Assume
import org.junit.experimental.categories.Category
import services.ImageIntegrationService
import services.ImageService
import services.PolicyService
import spock.lang.Shared
import spock.lang.Unroll
import util.Env
import util.Timer

class ImageScanningTest extends BaseSpecification {
    static final private List<String> POLICIES = [
            "ADD Command used instead of COPY",
            "Secure Shell (ssh) Port Exposed in Image",
            //"Improper Usage of Orchestrator Secrets Volume", // ROX-
    ]
    static final private Map<String, Deployment> DEPLOYMENTS = [
            "quay": new Deployment()
                    .setName("quay-test-deployment")
                    .setImage("quay.io/stackrox/testing:registry-image")
                    .addLabel("app", "quay-test-deployment")
                    .addImagePullSecret("quay"),
    ]

    static final private Map<String, Secret> IMAGE_PULL_SECRETS = [
            "quay": new Secret(
                    name: "quay",
                    namespace: Constants.ORCHESTRATOR_NAMESPACE,
                    username: "stackrox+circleci_apollo",
                    password: Env.mustGet("QUAY_PASSWORD"),
                    server: "https://quay.io"),
    ]
    @Shared
    static final private List<String> UPDATED_POLICIES = []

    def setupSpec() {
        ImageIntegrationService.deleteAutoRegisteredStackRoxScannerIntegrationIfExists()

        // Create necessary deployments
        for (Secret s : IMAGE_PULL_SECRETS.values()) {
            orchestrator.createImagePullSecret(s)
        }
        orchestrator.batchCreateDeployments(DEPLOYMENTS.values() as List)
        for (Deployment d : DEPLOYMENTS.values()) {
            assert Services.waitForDeployment(d)
        }

        //Enable specific policies to test image integrations
        for (String policy : POLICIES) {
            if (Services.setPolicyDisabled(policy, false)) {
                UPDATED_POLICIES.add(policy)
            }
        }
    }

    def cleanupSpec() {
        ImageIntegrationService.addStackroxScannerIntegration()

        for (Secret s : IMAGE_PULL_SECRETS.values()) {
            orchestrator.deleteSecret(s.name, s.namespace)
        }
        for (Deployment d : DEPLOYMENTS.values()) {
            orchestrator.deleteDeployment(d)
        }
        for (String policy : UPDATED_POLICIES) {
            Services.setPolicyDisabled(policy, true)
        }
    }

    def cleanup() {
        ImageService.clearImageCaches()
    }

    @Unroll
    @Category([BAT, Integration])
    def "Verify Image Scanner Integrations: #integration"() {
        given:
        "Get deployment details used to test integration"
        Deployment deployment = null
        if (DEPLOYMENTS.containsKey(integration)) {
            deployment = DEPLOYMENTS.get(integration)
        }
        assert deployment

        expect:
        "validate auto-generated registry was created"
        if (IMAGE_PULL_SECRETS.containsKey(integration)) {
            Secret secret = IMAGE_PULL_SECRETS.get(integration)
            ImageIntegrationOuterClass.ImageIntegration autoGenerated =
                    ImageIntegrationService.getImageIntegrationByName(
                            "Autogenerated ${secret.server} for cluster remote"
                    )
            assert autoGenerated.categoriesCount == 1
            assert autoGenerated.categoriesList.contains(ImageIntegrationOuterClass.ImageIntegrationCategory.REGISTRY)
            assert autoGenerated.docker.username == secret.username
            assert autoGenerated.docker.endpoint == secret.server
        }

        and:
        "validate registry based image metadata"
        def imageDigest = ImageService.getImages().find { it.name == deployment.image }
        try {
            assert imageDigest?.id
        } catch (Exception e) {
            if (strictIntegrationTesting) {
                throw (e)
            }
            Assume.assumeNoException("Failed to pull the image using ${integration}. Skipping test!", e)
        }
        ImageOuterClass.Image imageDetail = ImageService.getImage(imageDigest.id)
        assert imageDetail.metadata?.v1?.layersCount >= 1
        assert imageDetail.metadata?.layerShasCount >= 1

        and:
        "validate expected violations based on dockerfile"
        for (String policy : POLICIES) {
            assert Services.waitForViolation(deployment.name, policy)
        }

        when:
        "Add scanner integration"
        def integrationId = addIntegrationClosure()
        PolicyService.reassessPolicies()
        ImageService.scanImage(deployment.image)
        imageDetail = ImageService.getImage(ImageService.getImages().find { it.name == deployment.image }?.id)

        then:
        "validate scan results for the image"
        Timer t = new Timer(20, 3)
        while (imageDetail.scan?.componentsCount == 0 && t.IsValid()) {
            println "waiting on scan details..."
            sleep 3000
            ImageService.scanImage(deployment.image)
            imageDetail = ImageService.getImage(ImageService.getImages().find { it.name == deployment.image }?.id)
        }
        assert imageDetail.metadata.dataSource.id != ""
        assert imageDetail.metadata.dataSource.name != ""
        assert imageDetail.scan.dataSource.id != ""
        assert imageDetail.scan.dataSource.name != ""
        try {
            assert imageDetail.scan.componentsCount > 0
        } catch (Exception e) {
            if (strictIntegrationTesting) {
                throw (e)
            }
            Assume.assumeNoException("Failed to scan the image using ${integration}. Skipping test!", e)
        }
        for (String cve : cves) {
            println "Validating existence of ${cve} cve..."
            ImageOuterClass.EmbeddedImageScanComponent component = imageDetail.scan.componentsList.find {
                component -> component.vulnsList.find { vuln -> vuln.cve == cve }
            }
            assert component
            ImageOuterClass.EmbeddedVulnerability vuln = component.vulnsList.find { it.cve == cve }
            assert vuln

            assert vuln.summary && vuln.summary != ""
            assert 0.0 <= vuln.cvss && vuln.cvss <= 10.0
            assert vuln.link && vuln.link != ""
        }
        assert imageDetail.components >= components
        assert imageDetail.cves >= totalCves
        assert imageDetail.fixableCves >= fixable

        cleanup:
        "Remove deployment and integrations"
        if (integrationId) {
            ImageIntegrationService.deleteImageIntegration(integrationId)
        }

        where:
        "Data inputs:"

        integration | addIntegrationClosure                         |
                components | totalCves | fixable |
                cves

        /* The full quay test should look like the below, ROX-4001 will causes this test to fail
        "quay"      | { ImageIntegrationService.addQuayRegistry() } |
                165        | 184       | 28      |
                ["CVE-2014-6278","CVE-2019-9924","CVE-2017-8804","CVE-2017-9614"]
        */

        "quay"      | { ImageIntegrationService.addQuayRegistry() } |
                165        | null       | null      |
                ["CVE-2017-8804", "CVE-2017-9614"]
    }

    @Unroll
    @Category([BAT, Integration])
    def "Verify Image Scan Results - #image - #component:#version - #cve - #layerIdx"() {
        when:
        "Add Stackrox scanner"
        ImageIntegrationService.addStackroxScannerIntegration()

        and:
        "Scan Image and verify results"
        ImageOuterClass.Image img = Services.scanImage(image)
        assert img.metadata.dataSource.id != ""
        assert img.metadata.dataSource.name != ""
        assert img.scan.dataSource.id != ""
        assert img.scan.dataSource.name != ""

        then:
        ImageOuterClass.EmbeddedImageScanComponent foundComponent =
                img.scan.componentsList.find {
                    c -> c.name == component && c.version == version && c.layerIndex == layerIdx
                }
        foundComponent != null

        ImageOuterClass.EmbeddedVulnerability vuln =
                foundComponent.vulnsList.find { v -> v.cve == cve }

        vuln != null

        cleanup:
        "Remove stackrox scanner and clear"
        ImageIntegrationService.deleteAutoRegisteredStackRoxScannerIntegrationIfExists()

        where:
        "Data inputs are: "

        image                                                                                   | component      |
                version                | layerIdx | cve
        "richxsl/rhel7@sha256:8f3aae325d2074d2dc328cb532d6e7aeb0c588e15ddf847347038fe0566364d6" | "openssl-libs" |
                "1:1.0.1e-34.el7"      | 1        | "RHSA-2014:1052"

        "richxsl/rhel7@sha256:8f3aae325d2074d2dc328cb532d6e7aeb0c588e15ddf847347038fe0566364d6" | "openssl-libs" |
                "1:1.0.1e-34.el7"      | 1        | "CVE-2014-3509"
    }

    @Unroll
    def "Image scanning test to check if scan time is not null #image from stackrox"() {
        when:
        "Add Stackrox scanner"
        ImageIntegrationService.addStackroxScannerIntegration()

        and:
        "Image is scanned"
        def imageName = image
        Services.scanImage(imageName)

        then:
        "get image by name"
        String id = Services.getImageIdByName(imageName)
        ImageOuterClass.Image img = Services.getImageById(id)

        and:
        "check scanned time is not null"
        assert img.scan.scanTime != null
        assert img.scan.hasScanTime() == true

        cleanup:
        "Remove stackrox scanner and clear"
        ImageIntegrationService.deleteAutoRegisteredStackRoxScannerIntegrationIfExists()

        where:
        image                                    | registry
        "k8s.gcr.io/ip-masq-agent-amd64:v2.4.1"  | "gcr registry"
        "docker.io/jenkins/jenkins:lts"          | "docker registry"
        "docker.io/jenkins/jenkins:2.220-alpine" | "docker registry"
        "gke.gcr.io/heapster:v1.7.2"             | "one from gke"
        "mcr.microsoft.com/dotnet/core/runtime:2.1-alpine" | "one from mcr"
    }

    def "Validate basic image details across all current images in StackRox"() {
        when:
        "This is still flaky - disable for now until we get the issue resolved (ROX-4619)"
        Assume.assumeTrue(false)

        and:
        "get list of all images"
        List<ImageOuterClass.ListImage> images = ImageService.getImages()

        then:
        "validate details for each image"
        Map<ImageOuterClass.ImageName, List<ImageOuterClass.EmbeddedVulnerability>> missingValues = [:]
        for (ImageOuterClass.ListImage image : images) {
            ImageOuterClass.Image imageDetails = ImageService.getImage(image.id)

            if (imageDetails.hasScan()) {
                assert imageDetails.scan.scanTime
                for (ImageOuterClass.EmbeddedImageScanComponent component : imageDetails.scan.componentsList) {
                    for (ImageOuterClass.EmbeddedVulnerability vuln : component.vulnsList) {
                        if (vuln.summary == null || vuln.summary == "" ||
                                0.0 > vuln.cvss || vuln.cvss > 10.0 ||
                                vuln.link == null || vuln.link == "") {
                            missingValues.containsKey(imageDetails.name) ?
                                    missingValues.get(imageDetails.name).add(vuln) :
                                    missingValues.put(imageDetails.name, [vuln])
                        }
                    }
                }
            }
        }
        println missingValues
        assert missingValues.size() == 0
    }
}
