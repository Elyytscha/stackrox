package resolvers

import (
	"context"
	"fmt"
	"regexp"
	"strings"

	"github.com/hashicorp/go-version"
	"github.com/pkg/errors"
	"github.com/stackrox/k8s-istio-cve-pusher/nvd"
	"github.com/stackrox/rox/central/cve/converter"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/search"
	"github.com/stackrox/rox/pkg/set"
	"github.com/stackrox/rox/pkg/stringutils"
)

func isK8sCVEFixable(cve *nvd.CVEEntry) bool {
	for _, node := range cve.Configurations.Nodes {
		for _, cpeMatch := range node.CPEMatch {
			if cpeMatch.VersionEndExcluding != "" {
				return true
			}
		}
	}
	return false
}

func isClusterAffectedByK8sCVE(ctx context.Context, cluster *storage.Cluster, entry *nvd.CVEEntry) bool {
	clusterVersion := cluster.GetStatus().GetOrchestratorMetadata().GetVersion()
	for _, node := range entry.Configurations.Nodes {
		if matchVersions(node, clusterVersion, converter.K8s) {
			return true
		}
	}
	return false
}

func (resolver *Resolver) isClusterAffectedByIstioCVE(ctx context.Context, cluster *storage.Cluster, entry *nvd.CVEEntry) (bool, error) {
	ok, err := resolver.isIstioControlPlaneRunning(ctx)
	if err != nil {
		return false, err
	}
	if !ok {
		return false, nil
	}

	versions, err := resolver.getAllIstioComponentsVersionsInCluster(ctx, cluster)
	if err != nil {
		return false, err
	}
	for _, node := range entry.Configurations.Nodes {
		for _, version := range versions.AsSlice() {
			if matchVersions(node, version, converter.Istio) {
				return true, nil
			}
		}
	}
	return false, nil
}

func (resolver *Resolver) isIstioControlPlaneRunning(ctx context.Context) (bool, error) {
	q := search.NewQueryBuilder().AddExactMatches(search.Namespace, "istio-system").ProtoQuery()
	res, err := resolver.NamespaceDataStore.SearchNamespaces(ctx, q)
	if err != nil {
		return false, err
	}
	return len(res) > 0, nil
}

func (resolver *Resolver) getAllIstioComponentsVersionsInCluster(ctx context.Context, cluster *storage.Cluster) (set.StringSet, error) {
	set := set.StringSet{}
	q := search.NewQueryBuilder().
		AddExactMatches(search.ClusterID, cluster.GetId()).
		AddExactMatches(search.ImageRegistry, "docker.io").
		AddStrings(search.ImageRemote, "istio").
		ProtoQuery()
	images, err := resolver.ImageDataStore.SearchRawImages(ctx, q)
	if err != nil {
		return set, err
	}
	for _, image := range images {
		set.Add(image.GetName().GetTag())
	}
	return set, nil
}

func matchVersions(node nvd.Node, versionToMatch string, ct converter.CveType) bool {
	if node.Operator != "OR" {
		log.Errorf("operator %q is not supported right now", node.Operator)
		return false
	}

	isGKEVersion, err := isGKEVersion(versionToMatch)
	if err != nil {
		return false
	}

	if isGKEVersion {
		versionToMatch = strings.Split(versionToMatch, "-")[0]
	}

	for _, cpeMatch := range node.CPEMatch {
		// It might be possible that the node contains non kube cpes too, so keep iterating. For example,
		// "cpe23Uri": "cpe:2.3:a:cncf:portmap:*:*:*:*:*:container_networking_interface:*:*", and
		// "cpe23Uri": "cpe:2.3:a:kubernetes:kubernetes:*:*:*:*:*:*:*:*" are in the same node
		cpeVersionAndUpdate, err := getVersionAndUpdateFromCpe(cpeMatch.CPE23Uri, ct)
		if err != nil {
			log.Error(errors.Wrapf(err, "could not get version and update from cpe: %q", cpeMatch.CPE23Uri))
			continue
		}

		if cpeVersionAndUpdate == "" {
			continue
		}

		// The version is N/A, treating it as a match
		if cpeVersionAndUpdate == "-:*" {
			return true
		}

		if versionToMatch == "" {
			return false
		}

		targetVersion, err := version.NewVersion(versionToMatch)
		if err != nil {
			log.Error(errors.Wrapf(err, "could not create version for cluster version: %q", versionToMatch))
			continue
		}

		// This is the case where there is just one version so check against it
		// Note that cpeVersionAndUpdate can't be "*:*" in this case, since there is no info about start and end versions
		if stringutils.AllEmpty(cpeMatch.VersionStartIncluding, cpeMatch.VersionEndIncluding, cpeMatch.VersionEndExcluding) {
			// This means this version and all prelease, build versions of this version. For example 1.6.4:*
			if strings.HasSuffix(cpeVersionAndUpdate, ":*") {
				match, err := matchBaseVersion(strings.TrimSuffix(cpeVersionAndUpdate, ":*"), versionToMatch)
				if err != nil {
					log.Error(errors.Wrapf(err, "could not compare base version %q with cluster version: %q", strings.TrimSuffix(cpeVersionAndUpdate, ":*"), versionToMatch))
					continue
				}
				if match {
					return true
				}
				continue
			}

			// Case of specific version and prerelease. Example 1.6.4:beta0
			cpeVersion := strings.Join(strings.Split(cpeVersionAndUpdate, ":"), "-")
			match, err := matchExactVersion(cpeVersion, versionToMatch)
			if err != nil {
				log.Error(errors.Wrapf(err, "could not compare exact version %q with cluster version: %q", cpeVersion, versionToMatch))
				continue
			}
			if match {
				return true
			}
		} else { // This is case where we're dealing with block of versions

			targetVersion, err := getBaseVersion(targetVersion)
			if err != nil {
				continue
			}

			var constraints []*version.Constraint

			if cpeMatch.VersionStartIncluding != "" {
				cs := getConstraints(fmt.Sprintf(">= %s", cpeMatch.VersionStartIncluding))
				constraints = append(constraints, cs...)
			}

			if cpeMatch.VersionEndIncluding != "" {
				cs := getConstraints(fmt.Sprintf("<= %s", cpeMatch.VersionEndIncluding))
				constraints = append(constraints, cs...)
			}

			if cpeMatch.VersionEndExcluding != "" {
				cs := getConstraints(fmt.Sprintf("< %s", cpeMatch.VersionEndExcluding))
				constraints = append(constraints, cs...)
			}

			val := true
			for _, c := range constraints {
				val = val && c.Check(targetVersion)
			}
			if val {
				return true
			}
		}
	}
	return false
}

func getConstraints(s string) []*version.Constraint {
	cs, err := version.NewConstraint(s)
	if err != nil {
		log.Error(err)
		return []*version.Constraint{}
	}
	return cs
}

func matchBaseVersion(version1, version2 string) (bool, error) {
	v1, err := version.NewVersion(version1)
	if err != nil {
		log.Error(err)
		return false, err
	}
	v2, err := version.NewVersion(version2)
	if err != nil {
		log.Error(err)
		return false, err
	}
	// For ex [1.6.4, 1.6.4] Or [1.6.4, 1.6.4+build1] should be matched
	if v1.Equal(v2) {
		return true, nil
	}
	// For ex [1.6.4 and 1.6.4-beta1
	v2, err = getBaseVersion(v2)
	if err != nil {
		log.Error(err)
		return false, err
	}
	return v1.Equal(v2), nil
}

func matchExactVersion(version1, version2 string) (bool, error) {
	v1, err := version.NewVersion(version1)
	if err != nil {
		return false, err
	}
	v2, err := version.NewVersion(version2)
	if err != nil {
		return false, err
	}
	return v1.Equal(v2), nil
}

func getBaseVersion(v *version.Version) (*version.Version, error) {
	prerelease := v.Prerelease()
	if prerelease == "" {
		return v, nil
	}
	versionWithoutPrerelease := strings.ReplaceAll(v.String(), "-"+prerelease, "")
	bv, err := version.NewVersion(versionWithoutPrerelease)
	if err != nil {
		return nil, err
	}
	return bv, nil
}

func getVersionAndUpdateFromCpe(cpe string, ct converter.CveType) (string, error) {
	if ok := strings.HasPrefix(cpe, "cpe:2.3:a:"); !ok {
		return "", fmt.Errorf("cpe: %q not a valid cpe23Uri format", cpe)
	}

	ss := strings.Split(cpe, ":")
	if len(ss) != 13 {
		return "", fmt.Errorf("cpe: %q not a valid cpe23Uri format", cpe)
	}
	if ct != converter.K8s && ct != converter.Istio {
		return "", fmt.Errorf("unkown CVE type: %d", ct)
	}
	if ct == converter.K8s && (ss[3] != "kubernetes" || ss[4] != "kubernetes") {
		return "", nil
	}
	if ct == converter.Istio && (ss[3] != "istio" || ss[4] != "istio") {
		return "", nil
	}

	return strings.Join(ss[5:7], ":"), nil
}

func isGKEVersion(version string) (bool, error) {
	ok, err := regexp.Match("^[v|V]?[0-9]+\\.[0-9]+\\.[0-9]+-gke\\.[0-9]+$", []byte(version))
	if err != nil {
		log.Error(errors.Wrapf(err, "could not verify if version: %s is a gke version", version))
		return false, err
	}
	return ok, nil
}
