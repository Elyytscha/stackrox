package resolvers

import (
	"fmt"
	"strings"

	"github.com/hashicorp/go-version"
	"github.com/pkg/errors"
	"github.com/stackrox/k8s-istio-cve-pusher/nvd"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/stringutils"
)

func isK8sCVEFixable(cve *nvd.CVEEntry) bool {
	for _, node := range cve.Configurations.Nodes {
		for _, cpeMatch := range node.CPEMatch {
			if cpeMatch.VersionEndExcluding != "" {
				return true
			}
		}
	}
	return false
}

func isClusterAffectedByCVE(cluster *storage.Cluster, entry *nvd.CVEEntry) bool {
	clusterVersion := cluster.GetStatus().GetOrchestratorMetadata().Version
	for _, node := range entry.Configurations.Nodes {
		if matchVersions(node, clusterVersion) {
			return true
		}
	}
	return false
}

func matchVersions(node nvd.Node, clusterK8sVersion string) bool {
	if node.Operator != "OR" {
		log.Errorf("operator %q is not supported right now", node.Operator)
		return false
	}

	for _, cpeMatch := range node.CPEMatch {
		// It might be possible that the node contains non kube cpes too, so keep iterating. For example,
		// "cpe23Uri": "cpe:2.3:a:cncf:portmap:*:*:*:*:*:container_networking_interface:*:*", and
		// "cpe23Uri": "cpe:2.3:a:kubernetes:kubernetes:*:*:*:*:*:*:*:*" are in the same node
		cpeVersionAndUpdate, err := getVersionAndUpdateFromCpe(cpeMatch.CPE23Uri)
		if err != nil {
			log.Error(errors.Wrapf(err, "could not get version and update from cpe: %q", cpeMatch.CPE23Uri))
			continue
		}

		// The version is N/A, treating it as a match
		if cpeVersionAndUpdate == "-:*" {
			return true
		}

		targetVersion, err := version.NewVersion(clusterK8sVersion)
		if err != nil {
			log.Error(errors.Wrapf(err, "could not create version for cluster version: %q", clusterK8sVersion))
			continue
		}

		// This is the case where there is just one version so check against it
		// Note that cpeVersionAndUpdate can't be "*:*" in this case, since there is no info about start and end versions
		if stringutils.AllEmpty(cpeMatch.VersionStartIncluding, cpeMatch.VersionEndIncluding, cpeMatch.VersionEndExcluding) {
			// This means this version and all prelease, build versions of this version. For example 1.6.4:*
			if strings.HasSuffix(cpeVersionAndUpdate, ":*") {
				match, err := matchBaseVersion(strings.TrimSuffix(cpeVersionAndUpdate, ":*"), clusterK8sVersion)
				if err != nil {
					log.Error(errors.Wrapf(err, "could not compare base version %q with cluster version: %q", strings.TrimSuffix(cpeVersionAndUpdate, ":*"), clusterK8sVersion))
					continue
				}
				if match {
					return true
				}
				continue
			}

			// Case of specific version and prerelease. Example 1.6.4:beta0
			cpeVersion := strings.Join(strings.Split(cpeVersionAndUpdate, ":"), "-")
			match, err := matchExactVersion(cpeVersion, clusterK8sVersion)
			if err != nil {
				log.Error(errors.Wrapf(err, "could not compare exact version %q with cluster version: %q", cpeVersion, clusterK8sVersion))
				continue
			}
			if match {
				return true
			}
		} else { // This is case where we're dealing with block of versions

			targetVersion, err := getBaseVersion(targetVersion)
			if err != nil {
				continue
			}

			var constraints []*version.Constraint

			if cpeMatch.VersionStartIncluding != "" {
				cs := getConstraints(fmt.Sprintf(">= %s", cpeMatch.VersionStartIncluding))
				constraints = append(constraints, cs...)
			}

			if cpeMatch.VersionEndIncluding != "" {
				cs := getConstraints(fmt.Sprintf("<= %s", cpeMatch.VersionEndIncluding))
				constraints = append(constraints, cs...)
			}

			if cpeMatch.VersionEndExcluding != "" {
				cs := getConstraints(fmt.Sprintf("< %s", cpeMatch.VersionEndExcluding))
				constraints = append(constraints, cs...)
			}

			val := true
			for _, c := range constraints {
				val = val && c.Check(targetVersion)
			}
			if val {
				return true
			}
		}
	}
	return false
}

func getConstraints(s string) []*version.Constraint {
	cs, err := version.NewConstraint(s)
	if err != nil {
		log.Error(err)
		return []*version.Constraint{}
	}
	return cs
}

func matchBaseVersion(version1, version2 string) (bool, error) {
	v1, err := version.NewVersion(version1)
	if err != nil {
		log.Error(err)
		return false, err
	}
	v2, err := version.NewVersion(version2)
	if err != nil {
		log.Error(err)
		return false, err
	}
	// For ex [1.6.4, 1.6.4] Or [1.6.4, 1.6.4+build1] should be matched
	if v1.Equal(v2) {
		return true, nil
	}
	// For ex [1.6.4 and 1.6.4-beta1
	v2, err = getBaseVersion(v2)
	if err != nil {
		log.Error(err)
		return false, err
	}
	return v1.Equal(v2), nil
}

func matchExactVersion(version1, version2 string) (bool, error) {
	v1, err := version.NewVersion(version1)
	if err != nil {
		return false, err
	}
	v2, err := version.NewVersion(version2)
	if err != nil {
		return false, err
	}
	return v1.Equal(v2), nil
}

func getBaseVersion(v *version.Version) (*version.Version, error) {
	prerelease := v.Prerelease()
	if prerelease == "" {
		return v, nil
	}
	versionWithoutPrerelease := strings.ReplaceAll(v.String(), "-"+prerelease, "")
	bv, err := version.NewVersion(versionWithoutPrerelease)
	if err != nil {
		return nil, err
	}
	return bv, nil
}

func getVersionAndUpdateFromCpe(cpe string) (string, error) {
	if ok := strings.HasPrefix(cpe, "cpe:2.3:a:"); !ok {
		return "", fmt.Errorf("cpe: %q not a valid cpe23Uri format", cpe)
	}

	ss := strings.Split(cpe, ":")
	if len(ss) != 13 {
		return "", fmt.Errorf("cpe: %q not a valid cpe23Uri format", cpe)
	}
	if ss[3] != "kubernetes" || ss[4] != "kubernetes" {
		return "", fmt.Errorf("cpe: %q not a k8s cpe", cpe)
	}

	return strings.Join(ss[5:7], ":"), nil
}
