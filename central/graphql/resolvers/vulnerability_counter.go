package resolvers

import (
	"context"

	"github.com/stackrox/rox/generated/storage"
	pkgCVSS "github.com/stackrox/rox/pkg/cvss"
	"github.com/stackrox/rox/pkg/set"
	"github.com/stackrox/rox/pkg/utils"
)

func init() {
	schema := getBuilder()
	utils.Must(
		schema.AddType("VulnerabilityCounter", []string{
			"all: VulnerabilityFixableCounterResolver!",
			"low: VulnerabilityFixableCounterResolver!",
			"medium: VulnerabilityFixableCounterResolver!",
			"high: VulnerabilityFixableCounterResolver!",
			"critical: VulnerabilityFixableCounterResolver!",
		}),
		schema.AddType("VulnerabilityFixableCounterResolver", []string{
			"total: Int!",
			"fixable: Int!",
		}),
	)
}

// VulnerabilityCounterResolver returns the counts of vulnerabilities in a couple different buckets.
type VulnerabilityCounterResolver struct {
	all      *VulnerabilityFixableCounterResolver
	low      *VulnerabilityFixableCounterResolver
	medium   *VulnerabilityFixableCounterResolver
	high     *VulnerabilityFixableCounterResolver
	critical *VulnerabilityFixableCounterResolver
}

// All returns the counter for vulnerabilities of all severity levels.
func (evr *VulnerabilityCounterResolver) All(ctx context.Context) *VulnerabilityFixableCounterResolver {
	return evr.all
}

// Low returns the number of low impact vulnerabilities
func (evr *VulnerabilityCounterResolver) Low(ctx context.Context) *VulnerabilityFixableCounterResolver {
	return evr.low
}

// Medium returns the number of medium impact vulnerabilities
func (evr *VulnerabilityCounterResolver) Medium(ctx context.Context) *VulnerabilityFixableCounterResolver {
	return evr.medium
}

// High returns the number of high impact vulnerabilities
func (evr *VulnerabilityCounterResolver) High(ctx context.Context) *VulnerabilityFixableCounterResolver {
	return evr.high
}

// Critical returns the number of critical vulnerabilities
func (evr *VulnerabilityCounterResolver) Critical(ctx context.Context) *VulnerabilityFixableCounterResolver {
	return evr.critical
}

// VulnerabilityFixableCounterResolver is a counter that differentiates between fixable and all vulnerabilities.
type VulnerabilityFixableCounterResolver struct {
	total   int32
	fixable int32
}

// Total returns the total number of vulnerabilities
func (evr *VulnerabilityFixableCounterResolver) Total(ctx context.Context) int32 {
	return evr.total
}

// Fixable returns the number of fixable vulnerabilities
func (evr *VulnerabilityFixableCounterResolver) Fixable(ctx context.Context) int32 {
	return evr.fixable
}

// Static helpers.
//////////////////

func emptyVulnerabilityCounter() *VulnerabilityCounterResolver {
	return &VulnerabilityCounterResolver{
		all:      &VulnerabilityFixableCounterResolver{},
		low:      &VulnerabilityFixableCounterResolver{},
		medium:   &VulnerabilityFixableCounterResolver{},
		high:     &VulnerabilityFixableCounterResolver{},
		critical: &VulnerabilityFixableCounterResolver{},
	}
}

func mapVulnsToVulnerabilityCounter(vulns []*storage.EmbeddedVulnerability) *VulnerabilityCounterResolver {
	counter := emptyVulnerabilityCounter()
	for _, vuln := range vulns {
		isFixable := vuln.GetFixedBy() != ""
		counter.all.total++
		if isFixable {
			counter.all.fixable++
		}
		incCounter(counter, vuln.GetCvss(), isFixable)
	}
	return counter
}

func mapCVEsToVulnerabilityCounter(fixable, unFixable []*storage.CVE) *VulnerabilityCounterResolver {
	counter := emptyVulnerabilityCounter()
	seenVulns := set.NewStringSet()
	for _, vuln := range fixable {
		counter.all.total++
		counter.all.fixable++
		seenVulns.Add(vuln.GetId())
		incCounter(counter, vuln.GetCvss(), true)
	}

	for _, vuln := range unFixable {
		if !seenVulns.Contains(vuln.GetId()) {
			counter.all.total++
			incCounter(counter, vuln.GetCvss(), false)
		}
	}
	return counter
}

func incCounter(counter *VulnerabilityCounterResolver, cvss float32, fixable bool) {
	switch pkgCVSS.ScoreToSeverity(cvss) {
	case pkgCVSS.LOW:
		counter.low.total++
		if fixable {
			counter.low.fixable++
		}
	case pkgCVSS.MEDIUM:
		counter.medium.total++
		if fixable {
			counter.medium.fixable++
		}
	case pkgCVSS.HIGH:
		counter.high.total++
		if fixable {
			counter.high.fixable++
		}
	case pkgCVSS.CRITICAL:
		counter.critical.total++
		if fixable {
			counter.critical.fixable++
		}
	}
}
