// Code generated by graphql-generator. DO NOT EDIT.

package resolvers

import (
	"github.com/graph-gophers/graphql-go"
	"github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/storage" // end range imports
)

func toAccess(value *string) v1.Access {
	if value != nil {
		return v1.Access(v1.Access_value[*value])
	}
	return v1.Access(0)
}

func toAccesses(values *[]string) []v1.Access {
	if values == nil {
		return nil
	}
	output := make([]v1.Access, len(*values))
	for i, v := range *values {
		output[i] = toAccess(&v)
	}
	return output
}

type alertResolver struct {
	root *Resolver
	data *v1.Alert
	list *v1.ListAlert
}

func (resolver *Resolver) wrapAlert(value *v1.Alert, ok bool, err error) (*alertResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &alertResolver{resolver, value, nil}, nil
}

func (resolver *Resolver) wrapAlerts(values []*v1.Alert, err error) ([]*alertResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*alertResolver, len(values))
	for i, v := range values {
		output[i] = &alertResolver{resolver, v, nil}
	}
	return output, nil
}

func (resolver *Resolver) wrapListAlerts(values []*v1.ListAlert, err error) ([]*alertResolver, error) {
	if err != nil || values == nil {
		return nil, err
	}
	output := make([]*alertResolver, len(values))
	for i, v := range values {
		output[i] = &alertResolver{resolver, nil, v}
	}
	return output, nil
}

func (resolver *alertResolver) ensureData() {
	if resolver.data == nil {
		resolver.data = resolver.root.getAlert(resolver.list.GetId())
	}
}

func (resolver *alertResolver) Deployment() (*deploymentResolver, error) {
	resolver.ensureData()
	value := resolver.data.GetDeployment()
	return resolver.root.wrapDeployment(value, true, nil)
}

func (resolver *alertResolver) Enforcement() (*alert_EnforcementResolver, error) {
	resolver.ensureData()
	value := resolver.data.GetEnforcement()
	return resolver.root.wrapAlert_Enforcement(value, true, nil)
}

func (resolver *alertResolver) FirstOccurred() (graphql.Time, error) {
	resolver.ensureData()
	value := resolver.data.GetFirstOccurred()
	return timestamp(value)
}

func (resolver *alertResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	if resolver.data == nil {
		value = resolver.list.GetId()
	}
	return graphql.ID(value)
}

func (resolver *alertResolver) LifecycleStage() string {
	value := resolver.data.GetLifecycleStage()
	if resolver.data == nil {
		value = resolver.list.GetLifecycleStage()
	}
	return value.String()
}

func (resolver *alertResolver) Policy() (*policyResolver, error) {
	resolver.ensureData()
	value := resolver.data.GetPolicy()
	return resolver.root.wrapPolicy(value, true, nil)
}

func (resolver *alertResolver) SnoozeTill() (graphql.Time, error) {
	resolver.ensureData()
	value := resolver.data.GetSnoozeTill()
	return timestamp(value)
}

func (resolver *alertResolver) State() string {
	value := resolver.data.GetState()
	if resolver.data == nil {
		value = resolver.list.GetState()
	}
	return value.String()
}

func (resolver *alertResolver) Time() (graphql.Time, error) {
	value := resolver.data.GetTime()
	if resolver.data == nil {
		value = resolver.list.GetTime()
	}
	return timestamp(value)
}

func (resolver *alertResolver) Violations() ([]*alert_ViolationResolver, error) {
	resolver.ensureData()
	value := resolver.data.GetViolations()
	return resolver.root.wrapAlert_Violations(value, nil)
}

type alert_EnforcementResolver struct {
	root *Resolver
	data *v1.Alert_Enforcement
}

func (resolver *Resolver) wrapAlert_Enforcement(value *v1.Alert_Enforcement, ok bool, err error) (*alert_EnforcementResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &alert_EnforcementResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapAlert_Enforcements(values []*v1.Alert_Enforcement, err error) ([]*alert_EnforcementResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*alert_EnforcementResolver, len(values))
	for i, v := range values {
		output[i] = &alert_EnforcementResolver{resolver, v}
	}
	return output, nil
}

func (resolver *alert_EnforcementResolver) Action() string {
	value := resolver.data.GetAction()
	return value.String()
}

func (resolver *alert_EnforcementResolver) Message() string {
	value := resolver.data.GetMessage()
	return value
}

type alert_ViolationResolver struct {
	root *Resolver
	data *v1.Alert_Violation
}

func (resolver *Resolver) wrapAlert_Violation(value *v1.Alert_Violation, ok bool, err error) (*alert_ViolationResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &alert_ViolationResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapAlert_Violations(values []*v1.Alert_Violation, err error) ([]*alert_ViolationResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*alert_ViolationResolver, len(values))
	for i, v := range values {
		output[i] = &alert_ViolationResolver{resolver, v}
	}
	return output, nil
}

func (resolver *alert_ViolationResolver) Link() string {
	value := resolver.data.GetLink()
	return value
}

func (resolver *alert_ViolationResolver) Message() string {
	value := resolver.data.GetMessage()
	return value
}

func (resolver *alert_ViolationResolver) Processes() ([]*processIndicatorResolver, error) {
	value := resolver.data.GetProcesses()
	return resolver.root.wrapProcessIndicators(value, nil)
}

type cSCCResolver struct {
	root *Resolver
	data *v1.CSCC
}

func (resolver *Resolver) wrapCSCC(value *v1.CSCC, ok bool, err error) (*cSCCResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &cSCCResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCSCCs(values []*v1.CSCC, err error) ([]*cSCCResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*cSCCResolver, len(values))
	for i, v := range values {
		output[i] = &cSCCResolver{resolver, v}
	}
	return output, nil
}

func (resolver *cSCCResolver) GcpOrgId() string {
	value := resolver.data.GetGcpOrgId()
	return value
}

func (resolver *cSCCResolver) GcpProject() string {
	value := resolver.data.GetGcpProject()
	return value
}

func (resolver *cSCCResolver) ServiceAccount() string {
	value := resolver.data.GetServiceAccount()
	return value
}

type cVSSV2Resolver struct {
	root *Resolver
	data *storage.CVSSV2
}

func (resolver *Resolver) wrapCVSSV2(value *storage.CVSSV2, ok bool, err error) (*cVSSV2Resolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &cVSSV2Resolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCVSSV2s(values []*storage.CVSSV2, err error) ([]*cVSSV2Resolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*cVSSV2Resolver, len(values))
	for i, v := range values {
		output[i] = &cVSSV2Resolver{resolver, v}
	}
	return output, nil
}

func (resolver *cVSSV2Resolver) AccessComplexity() string {
	value := resolver.data.GetAccessComplexity()
	return value.String()
}

func (resolver *cVSSV2Resolver) AttackVector() string {
	value := resolver.data.GetAttackVector()
	return value.String()
}

func (resolver *cVSSV2Resolver) Authentication() string {
	value := resolver.data.GetAuthentication()
	return value.String()
}

func (resolver *cVSSV2Resolver) Availability() string {
	value := resolver.data.GetAvailability()
	return value.String()
}

func (resolver *cVSSV2Resolver) Confidentiality() string {
	value := resolver.data.GetConfidentiality()
	return value.String()
}

func (resolver *cVSSV2Resolver) Integrity() string {
	value := resolver.data.GetIntegrity()
	return value.String()
}

func (resolver *cVSSV2Resolver) Vector() string {
	value := resolver.data.GetVector()
	return value
}

func toCVSSV2_AccessComplexity(value *string) storage.CVSSV2_AccessComplexity {
	if value != nil {
		return storage.CVSSV2_AccessComplexity(storage.CVSSV2_AccessComplexity_value[*value])
	}
	return storage.CVSSV2_AccessComplexity(0)
}

func toCVSSV2_AccessComplexities(values *[]string) []storage.CVSSV2_AccessComplexity {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV2_AccessComplexity, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV2_AccessComplexity(&v)
	}
	return output
}

func toCVSSV2_AttackVector(value *string) storage.CVSSV2_AttackVector {
	if value != nil {
		return storage.CVSSV2_AttackVector(storage.CVSSV2_AttackVector_value[*value])
	}
	return storage.CVSSV2_AttackVector(0)
}

func toCVSSV2_AttackVectors(values *[]string) []storage.CVSSV2_AttackVector {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV2_AttackVector, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV2_AttackVector(&v)
	}
	return output
}

func toCVSSV2_Authentication(value *string) storage.CVSSV2_Authentication {
	if value != nil {
		return storage.CVSSV2_Authentication(storage.CVSSV2_Authentication_value[*value])
	}
	return storage.CVSSV2_Authentication(0)
}

func toCVSSV2_Authentications(values *[]string) []storage.CVSSV2_Authentication {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV2_Authentication, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV2_Authentication(&v)
	}
	return output
}

func toCVSSV2_Impact(value *string) storage.CVSSV2_Impact {
	if value != nil {
		return storage.CVSSV2_Impact(storage.CVSSV2_Impact_value[*value])
	}
	return storage.CVSSV2_Impact(0)
}

func toCVSSV2_Impacts(values *[]string) []storage.CVSSV2_Impact {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV2_Impact, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV2_Impact(&v)
	}
	return output
}

type certResolver struct {
	root *Resolver
	data *v1.Cert
}

func (resolver *Resolver) wrapCert(value *v1.Cert, ok bool, err error) (*certResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &certResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCerts(values []*v1.Cert, err error) ([]*certResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*certResolver, len(values))
	for i, v := range values {
		output[i] = &certResolver{resolver, v}
	}
	return output, nil
}

func (resolver *certResolver) Algorithm() string {
	value := resolver.data.GetAlgorithm()
	return value
}

func (resolver *certResolver) EndDate() (graphql.Time, error) {
	value := resolver.data.GetEndDate()
	return timestamp(value)
}

func (resolver *certResolver) Issuer() (*certNameResolver, error) {
	value := resolver.data.GetIssuer()
	return resolver.root.wrapCertName(value, true, nil)
}

func (resolver *certResolver) Sans() []string {
	value := resolver.data.GetSans()
	return value
}

func (resolver *certResolver) StartDate() (graphql.Time, error) {
	value := resolver.data.GetStartDate()
	return timestamp(value)
}

func (resolver *certResolver) Subject() (*certNameResolver, error) {
	value := resolver.data.GetSubject()
	return resolver.root.wrapCertName(value, true, nil)
}

type certNameResolver struct {
	root *Resolver
	data *v1.CertName
}

func (resolver *Resolver) wrapCertName(value *v1.CertName, ok bool, err error) (*certNameResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &certNameResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCertNames(values []*v1.CertName, err error) ([]*certNameResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*certNameResolver, len(values))
	for i, v := range values {
		output[i] = &certNameResolver{resolver, v}
	}
	return output, nil
}

func (resolver *certNameResolver) CommonName() string {
	value := resolver.data.GetCommonName()
	return value
}

func (resolver *certNameResolver) Country() string {
	value := resolver.data.GetCountry()
	return value
}

func (resolver *certNameResolver) Locality() string {
	value := resolver.data.GetLocality()
	return value
}

func (resolver *certNameResolver) Names() []string {
	value := resolver.data.GetNames()
	return value
}

func (resolver *certNameResolver) Organization() string {
	value := resolver.data.GetOrganization()
	return value
}

func (resolver *certNameResolver) OrganizationUnit() string {
	value := resolver.data.GetOrganizationUnit()
	return value
}

func (resolver *certNameResolver) PostalCode() string {
	value := resolver.data.GetPostalCode()
	return value
}

func (resolver *certNameResolver) Province() string {
	value := resolver.data.GetProvince()
	return value
}

func (resolver *certNameResolver) StreetAddress() string {
	value := resolver.data.GetStreetAddress()
	return value
}

type clusterResolver struct {
	root *Resolver
	data *v1.Cluster
}

func (resolver *Resolver) wrapCluster(value *v1.Cluster, ok bool, err error) (*clusterResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &clusterResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapClusters(values []*v1.Cluster, err error) ([]*clusterResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*clusterResolver, len(values))
	for i, v := range values {
		output[i] = &clusterResolver{resolver, v}
	}
	return output, nil
}

func (resolver *clusterResolver) CentralApiEndpoint() string {
	value := resolver.data.GetCentralApiEndpoint()
	return value
}

func (resolver *clusterResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *clusterResolver) LastContact() (graphql.Time, error) {
	value := resolver.data.GetLastContact()
	return timestamp(value)
}

func (resolver *clusterResolver) MainImage() string {
	value := resolver.data.GetMainImage()
	return value
}

func (resolver *clusterResolver) MonitoringEndpoint() string {
	value := resolver.data.GetMonitoringEndpoint()
	return value
}

func (resolver *clusterResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *clusterResolver) RuntimeSupport() bool {
	value := resolver.data.GetRuntimeSupport()
	return value
}

func (resolver *clusterResolver) Type() string {
	value := resolver.data.GetType()
	return value.String()
}

type clusterOrchestratorParamsResolver struct {
	resolver *clusterResolver
}

func (resolver *clusterResolver) OrchestratorParams() *clusterOrchestratorParamsResolver {
	return &clusterOrchestratorParamsResolver{resolver}
}

func (resolver *clusterOrchestratorParamsResolver) ToKubernetesParams() (*kubernetesParamsResolver, bool) {
	value := resolver.resolver.data.GetKubernetes()
	if value != nil {
		return &kubernetesParamsResolver{resolver.resolver.root, value}, true
	}
	return nil, false
}

func (resolver *clusterOrchestratorParamsResolver) ToSwarmParams() (*swarmParamsResolver, bool) {
	value := resolver.resolver.data.GetSwarm()
	if value != nil {
		return &swarmParamsResolver{resolver.resolver.root, value}, true
	}
	return nil, false
}

func (resolver *clusterOrchestratorParamsResolver) ToOpenshiftParams() (*openshiftParamsResolver, bool) {
	value := resolver.resolver.data.GetOpenshift()
	if value != nil {
		return &openshiftParamsResolver{resolver.resolver.root, value}, true
	}
	return nil, false
}

func toClusterType(value *string) v1.ClusterType {
	if value != nil {
		return v1.ClusterType(v1.ClusterType_value[*value])
	}
	return v1.ClusterType(0)
}

func toClusterTypes(values *[]string) []v1.ClusterType {
	if values == nil {
		return nil
	}
	output := make([]v1.ClusterType, len(*values))
	for i, v := range *values {
		output[i] = toClusterType(&v)
	}
	return output
}

type commonKubernetesParamsResolver struct {
	root *Resolver
	data *v1.CommonKubernetesParams
}

func (resolver *Resolver) wrapCommonKubernetesParams(value *v1.CommonKubernetesParams, ok bool, err error) (*commonKubernetesParamsResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &commonKubernetesParamsResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCommonKubernetesParamses(values []*v1.CommonKubernetesParams, err error) ([]*commonKubernetesParamsResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*commonKubernetesParamsResolver, len(values))
	for i, v := range values {
		output[i] = &commonKubernetesParamsResolver{resolver, v}
	}
	return output, nil
}

func (resolver *commonKubernetesParamsResolver) Namespace() string {
	value := resolver.data.GetNamespace()
	return value
}

func toComparator(value *string) v1.Comparator {
	if value != nil {
		return v1.Comparator(v1.Comparator_value[*value])
	}
	return v1.Comparator(0)
}

func toComparators(values *[]string) []v1.Comparator {
	if values == nil {
		return nil
	}
	output := make([]v1.Comparator, len(*values))
	for i, v := range *values {
		output[i] = toComparator(&v)
	}
	return output
}

type componentResolver struct {
	root *Resolver
	data *v1.Component
}

func (resolver *Resolver) wrapComponent(value *v1.Component, ok bool, err error) (*componentResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &componentResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComponents(values []*v1.Component, err error) ([]*componentResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*componentResolver, len(values))
	for i, v := range values {
		output[i] = &componentResolver{resolver, v}
	}
	return output, nil
}

func (resolver *componentResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *componentResolver) Version() string {
	value := resolver.data.GetVersion()
	return value
}

type containerResolver struct {
	root *Resolver
	data *storage.Container
}

func (resolver *Resolver) wrapContainer(value *storage.Container, ok bool, err error) (*containerResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainers(values []*storage.Container, err error) ([]*containerResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerResolver, len(values))
	for i, v := range values {
		output[i] = &containerResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerResolver) Config() (*containerConfigResolver, error) {
	value := resolver.data.GetConfig()
	return resolver.root.wrapContainerConfig(value, true, nil)
}

func (resolver *containerResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *containerResolver) Image() (*imageResolver, error) {
	value := resolver.data.GetImage()
	return resolver.root.wrapImage(value, true, nil)
}

func (resolver *containerResolver) Instances() ([]*containerInstanceResolver, error) {
	value := resolver.data.GetInstances()
	return resolver.root.wrapContainerInstances(value, nil)
}

func (resolver *containerResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *containerResolver) Ports() ([]*portConfigResolver, error) {
	value := resolver.data.GetPorts()
	return resolver.root.wrapPortConfigs(value, nil)
}

func (resolver *containerResolver) Resources() (*resourcesResolver, error) {
	value := resolver.data.GetResources()
	return resolver.root.wrapResources(value, true, nil)
}

func (resolver *containerResolver) Secrets() ([]*embeddedSecretResolver, error) {
	value := resolver.data.GetSecrets()
	return resolver.root.wrapEmbeddedSecrets(value, nil)
}

func (resolver *containerResolver) SecurityContext() (*securityContextResolver, error) {
	value := resolver.data.GetSecurityContext()
	return resolver.root.wrapSecurityContext(value, true, nil)
}

func (resolver *containerResolver) Volumes() ([]*volumeResolver, error) {
	value := resolver.data.GetVolumes()
	return resolver.root.wrapVolumes(value, nil)
}

type containerConfigResolver struct {
	root *Resolver
	data *storage.ContainerConfig
}

func (resolver *Resolver) wrapContainerConfig(value *storage.ContainerConfig, ok bool, err error) (*containerConfigResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerConfigResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainerConfigs(values []*storage.ContainerConfig, err error) ([]*containerConfigResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerConfigResolver, len(values))
	for i, v := range values {
		output[i] = &containerConfigResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerConfigResolver) Args() []string {
	value := resolver.data.GetArgs()
	return value
}

func (resolver *containerConfigResolver) Command() []string {
	value := resolver.data.GetCommand()
	return value
}

func (resolver *containerConfigResolver) Directory() string {
	value := resolver.data.GetDirectory()
	return value
}

func (resolver *containerConfigResolver) Env() ([]*containerConfig_EnvironmentConfigResolver, error) {
	value := resolver.data.GetEnv()
	return resolver.root.wrapContainerConfig_EnvironmentConfigs(value, nil)
}

func (resolver *containerConfigResolver) Uid() int32 {
	value := resolver.data.GetUid()
	return int32(value)
}

func (resolver *containerConfigResolver) User() string {
	value := resolver.data.GetUser()
	return value
}

type containerConfig_EnvironmentConfigResolver struct {
	root *Resolver
	data *storage.ContainerConfig_EnvironmentConfig
}

func (resolver *Resolver) wrapContainerConfig_EnvironmentConfig(value *storage.ContainerConfig_EnvironmentConfig, ok bool, err error) (*containerConfig_EnvironmentConfigResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerConfig_EnvironmentConfigResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainerConfig_EnvironmentConfigs(values []*storage.ContainerConfig_EnvironmentConfig, err error) ([]*containerConfig_EnvironmentConfigResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerConfig_EnvironmentConfigResolver, len(values))
	for i, v := range values {
		output[i] = &containerConfig_EnvironmentConfigResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerConfig_EnvironmentConfigResolver) Key() string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *containerConfig_EnvironmentConfigResolver) Value() string {
	value := resolver.data.GetValue()
	return value
}

type containerInstanceResolver struct {
	root *Resolver
	data *storage.ContainerInstance
}

func (resolver *Resolver) wrapContainerInstance(value *storage.ContainerInstance, ok bool, err error) (*containerInstanceResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerInstanceResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainerInstances(values []*storage.ContainerInstance, err error) ([]*containerInstanceResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerInstanceResolver, len(values))
	for i, v := range values {
		output[i] = &containerInstanceResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerInstanceResolver) ContainerIps() []string {
	value := resolver.data.GetContainerIps()
	return value
}

func (resolver *containerInstanceResolver) ContainingPodId() string {
	value := resolver.data.GetContainingPodId()
	return value
}

func (resolver *containerInstanceResolver) InstanceId() (*containerInstanceIDResolver, error) {
	value := resolver.data.GetInstanceId()
	return resolver.root.wrapContainerInstanceID(value, true, nil)
}

type containerInstanceIDResolver struct {
	root *Resolver
	data *storage.ContainerInstanceID
}

func (resolver *Resolver) wrapContainerInstanceID(value *storage.ContainerInstanceID, ok bool, err error) (*containerInstanceIDResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerInstanceIDResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainerInstanceIDs(values []*storage.ContainerInstanceID, err error) ([]*containerInstanceIDResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerInstanceIDResolver, len(values))
	for i, v := range values {
		output[i] = &containerInstanceIDResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerInstanceIDResolver) ContainerRuntime() string {
	value := resolver.data.GetContainerRuntime()
	return value.String()
}

func (resolver *containerInstanceIDResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *containerInstanceIDResolver) Node() string {
	value := resolver.data.GetNode()
	return value
}

func toContainerRuntime(value *string) storage.ContainerRuntime {
	if value != nil {
		return storage.ContainerRuntime(storage.ContainerRuntime_value[*value])
	}
	return storage.ContainerRuntime(0)
}

func toContainerRuntimes(values *[]string) []storage.ContainerRuntime {
	if values == nil {
		return nil
	}
	output := make([]storage.ContainerRuntime, len(*values))
	for i, v := range *values {
		output[i] = toContainerRuntime(&v)
	}
	return output
}

type deploymentResolver struct {
	root *Resolver
	data *storage.Deployment
	list *storage.ListDeployment
}

func (resolver *Resolver) wrapDeployment(value *storage.Deployment, ok bool, err error) (*deploymentResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &deploymentResolver{resolver, value, nil}, nil
}

func (resolver *Resolver) wrapDeployments(values []*storage.Deployment, err error) ([]*deploymentResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*deploymentResolver, len(values))
	for i, v := range values {
		output[i] = &deploymentResolver{resolver, v, nil}
	}
	return output, nil
}

func (resolver *Resolver) wrapListDeployments(values []*storage.ListDeployment, err error) ([]*deploymentResolver, error) {
	if err != nil || values == nil {
		return nil, err
	}
	output := make([]*deploymentResolver, len(values))
	for i, v := range values {
		output[i] = &deploymentResolver{resolver, nil, v}
	}
	return output, nil
}

func (resolver *deploymentResolver) ensureData() {
	if resolver.data == nil {
		resolver.data = resolver.root.getDeployment(resolver.list.GetId())
	}
}

func (resolver *deploymentResolver) Annotations() labels {
	resolver.ensureData()
	value := resolver.data.GetAnnotations()
	return labelsResolver(value)
}

func (resolver *deploymentResolver) ClusterId() string {
	value := resolver.data.GetClusterId()
	if resolver.data == nil {
		value = resolver.list.GetClusterId()
	}
	return value
}

func (resolver *deploymentResolver) ClusterName() string {
	resolver.ensureData()
	value := resolver.data.GetClusterName()
	return value
}

func (resolver *deploymentResolver) Containers() ([]*containerResolver, error) {
	resolver.ensureData()
	value := resolver.data.GetContainers()
	return resolver.root.wrapContainers(value, nil)
}

func (resolver *deploymentResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	if resolver.data == nil {
		value = resolver.list.GetId()
	}
	return graphql.ID(value)
}

func (resolver *deploymentResolver) ImagePullSecrets() []string {
	resolver.ensureData()
	value := resolver.data.GetImagePullSecrets()
	return value
}

func (resolver *deploymentResolver) Inactive() bool {
	resolver.ensureData()
	value := resolver.data.GetInactive()
	return value
}

func (resolver *deploymentResolver) Labels() labels {
	resolver.ensureData()
	value := resolver.data.GetLabels()
	return labelsResolver(value)
}

func (resolver *deploymentResolver) Name() string {
	value := resolver.data.GetName()
	if resolver.data == nil {
		value = resolver.list.GetName()
	}
	return value
}

func (resolver *deploymentResolver) Namespace() string {
	value := resolver.data.GetNamespace()
	if resolver.data == nil {
		value = resolver.list.GetNamespace()
	}
	return value
}

func (resolver *deploymentResolver) Priority() int32 {
	value := resolver.data.GetPriority()
	if resolver.data == nil {
		value = resolver.list.GetPriority()
	}
	return int32(value)
}

func (resolver *deploymentResolver) Replicas() int32 {
	resolver.ensureData()
	value := resolver.data.GetReplicas()
	return int32(value)
}

func (resolver *deploymentResolver) Risk() (*riskResolver, error) {
	resolver.ensureData()
	value := resolver.data.GetRisk()
	return resolver.root.wrapRisk(value, true, nil)
}

func (resolver *deploymentResolver) ServiceAccount() string {
	resolver.ensureData()
	value := resolver.data.GetServiceAccount()
	return value
}

func (resolver *deploymentResolver) Type() string {
	resolver.ensureData()
	value := resolver.data.GetType()
	return value
}

func (resolver *deploymentResolver) UpdatedAt() (graphql.Time, error) {
	value := resolver.data.GetUpdatedAt()
	if resolver.data == nil {
		value = resolver.list.GetUpdatedAt()
	}
	return timestamp(value)
}

func (resolver *deploymentResolver) Version() string {
	resolver.ensureData()
	value := resolver.data.GetVersion()
	return value
}

type dockerfileLineRuleFieldResolver struct {
	root *Resolver
	data *v1.DockerfileLineRuleField
}

func (resolver *Resolver) wrapDockerfileLineRuleField(value *v1.DockerfileLineRuleField, ok bool, err error) (*dockerfileLineRuleFieldResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &dockerfileLineRuleFieldResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapDockerfileLineRuleFields(values []*v1.DockerfileLineRuleField, err error) ([]*dockerfileLineRuleFieldResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*dockerfileLineRuleFieldResolver, len(values))
	for i, v := range values {
		output[i] = &dockerfileLineRuleFieldResolver{resolver, v}
	}
	return output, nil
}

func (resolver *dockerfileLineRuleFieldResolver) Instruction() string {
	value := resolver.data.GetInstruction()
	return value
}

func (resolver *dockerfileLineRuleFieldResolver) Value() string {
	value := resolver.data.GetValue()
	return value
}

type emailResolver struct {
	root *Resolver
	data *v1.Email
}

func (resolver *Resolver) wrapEmail(value *v1.Email, ok bool, err error) (*emailResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &emailResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapEmails(values []*v1.Email, err error) ([]*emailResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*emailResolver, len(values))
	for i, v := range values {
		output[i] = &emailResolver{resolver, v}
	}
	return output, nil
}

func (resolver *emailResolver) DisableTLS() bool {
	value := resolver.data.GetDisableTLS()
	return value
}

func (resolver *emailResolver) From() string {
	value := resolver.data.GetFrom()
	return value
}

func (resolver *emailResolver) Password() string {
	value := resolver.data.GetPassword()
	return value
}

func (resolver *emailResolver) Sender() string {
	value := resolver.data.GetSender()
	return value
}

func (resolver *emailResolver) Server() string {
	value := resolver.data.GetServer()
	return value
}

func (resolver *emailResolver) UseSTARTTLS() bool {
	value := resolver.data.GetUseSTARTTLS()
	return value
}

func (resolver *emailResolver) Username() string {
	value := resolver.data.GetUsername()
	return value
}

type embeddedSecretResolver struct {
	root *Resolver
	data *storage.EmbeddedSecret
}

func (resolver *Resolver) wrapEmbeddedSecret(value *storage.EmbeddedSecret, ok bool, err error) (*embeddedSecretResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &embeddedSecretResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapEmbeddedSecrets(values []*storage.EmbeddedSecret, err error) ([]*embeddedSecretResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*embeddedSecretResolver, len(values))
	for i, v := range values {
		output[i] = &embeddedSecretResolver{resolver, v}
	}
	return output, nil
}

func (resolver *embeddedSecretResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *embeddedSecretResolver) Path() string {
	value := resolver.data.GetPath()
	return value
}

func toEnforcementAction(value *string) v1.EnforcementAction {
	if value != nil {
		return v1.EnforcementAction(v1.EnforcementAction_value[*value])
	}
	return v1.EnforcementAction(0)
}

func toEnforcementActions(values *[]string) []v1.EnforcementAction {
	if values == nil {
		return nil
	}
	output := make([]v1.EnforcementAction, len(*values))
	for i, v := range *values {
		output[i] = toEnforcementAction(&v)
	}
	return output
}

type generateTokenResponseResolver struct {
	root *Resolver
	data *v1.GenerateTokenResponse
}

func (resolver *Resolver) wrapGenerateTokenResponse(value *v1.GenerateTokenResponse, ok bool, err error) (*generateTokenResponseResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &generateTokenResponseResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapGenerateTokenResponses(values []*v1.GenerateTokenResponse, err error) ([]*generateTokenResponseResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*generateTokenResponseResolver, len(values))
	for i, v := range values {
		output[i] = &generateTokenResponseResolver{resolver, v}
	}
	return output, nil
}

func (resolver *generateTokenResponseResolver) Metadata() (*tokenMetadataResolver, error) {
	value := resolver.data.GetMetadata()
	return resolver.root.wrapTokenMetadata(value, true, nil)
}

func (resolver *generateTokenResponseResolver) Token() string {
	value := resolver.data.GetToken()
	return value
}

type groupResolver struct {
	root *Resolver
	data *v1.Group
}

func (resolver *Resolver) wrapGroup(value *v1.Group, ok bool, err error) (*groupResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &groupResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapGroups(values []*v1.Group, err error) ([]*groupResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*groupResolver, len(values))
	for i, v := range values {
		output[i] = &groupResolver{resolver, v}
	}
	return output, nil
}

func (resolver *groupResolver) Props() (*groupPropertiesResolver, error) {
	value := resolver.data.GetProps()
	return resolver.root.wrapGroupProperties(value, true, nil)
}

func (resolver *groupResolver) RoleName() string {
	value := resolver.data.GetRoleName()
	return value
}

type groupPropertiesResolver struct {
	root *Resolver
	data *v1.GroupProperties
}

func (resolver *Resolver) wrapGroupProperties(value *v1.GroupProperties, ok bool, err error) (*groupPropertiesResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &groupPropertiesResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapGroupPropertieses(values []*v1.GroupProperties, err error) ([]*groupPropertiesResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*groupPropertiesResolver, len(values))
	for i, v := range values {
		output[i] = &groupPropertiesResolver{resolver, v}
	}
	return output, nil
}

func (resolver *groupPropertiesResolver) AuthProviderId() string {
	value := resolver.data.GetAuthProviderId()
	return value
}

func (resolver *groupPropertiesResolver) Key() string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *groupPropertiesResolver) Value() string {
	value := resolver.data.GetValue()
	return value
}

type imageResolver struct {
	root *Resolver
	data *storage.Image
	list *storage.ListImage
}

func (resolver *Resolver) wrapImage(value *storage.Image, ok bool, err error) (*imageResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageResolver{resolver, value, nil}, nil
}

func (resolver *Resolver) wrapImages(values []*storage.Image, err error) ([]*imageResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageResolver, len(values))
	for i, v := range values {
		output[i] = &imageResolver{resolver, v, nil}
	}
	return output, nil
}

func (resolver *Resolver) wrapListImages(values []*storage.ListImage, err error) ([]*imageResolver, error) {
	if err != nil || values == nil {
		return nil, err
	}
	output := make([]*imageResolver, len(values))
	for i, v := range values {
		output[i] = &imageResolver{resolver, nil, v}
	}
	return output, nil
}

func (resolver *imageResolver) ensureData() {
	if resolver.data == nil {
		resolver.data = resolver.root.getImage(resolver.list.GetId())
	}
}

func (resolver *imageResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	if resolver.data == nil {
		value = resolver.list.GetId()
	}
	return graphql.ID(value)
}

func (resolver *imageResolver) Metadata() (*imageMetadataResolver, error) {
	resolver.ensureData()
	value := resolver.data.GetMetadata()
	return resolver.root.wrapImageMetadata(value, true, nil)
}

func (resolver *imageResolver) Name() (*imageNameResolver, error) {
	resolver.ensureData()
	value := resolver.data.GetName()
	return resolver.root.wrapImageName(value, true, nil)
}

func (resolver *imageResolver) Scan() (*imageScanResolver, error) {
	resolver.ensureData()
	value := resolver.data.GetScan()
	return resolver.root.wrapImageScan(value, true, nil)
}

type imageLayerResolver struct {
	root *Resolver
	data *storage.ImageLayer
}

func (resolver *Resolver) wrapImageLayer(value *storage.ImageLayer, ok bool, err error) (*imageLayerResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageLayerResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageLayers(values []*storage.ImageLayer, err error) ([]*imageLayerResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageLayerResolver, len(values))
	for i, v := range values {
		output[i] = &imageLayerResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageLayerResolver) Author() string {
	value := resolver.data.GetAuthor()
	return value
}

func (resolver *imageLayerResolver) Components() ([]*imageScanComponentResolver, error) {
	value := resolver.data.GetComponents()
	return resolver.root.wrapImageScanComponents(value, nil)
}

func (resolver *imageLayerResolver) Created() (graphql.Time, error) {
	value := resolver.data.GetCreated()
	return timestamp(value)
}

func (resolver *imageLayerResolver) Empty() bool {
	value := resolver.data.GetEmpty()
	return value
}

func (resolver *imageLayerResolver) Instruction() string {
	value := resolver.data.GetInstruction()
	return value
}

func (resolver *imageLayerResolver) Value() string {
	value := resolver.data.GetValue()
	return value
}

type imageMetadataResolver struct {
	root *Resolver
	data *storage.ImageMetadata
}

func (resolver *Resolver) wrapImageMetadata(value *storage.ImageMetadata, ok bool, err error) (*imageMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageMetadatas(values []*storage.ImageMetadata, err error) ([]*imageMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &imageMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageMetadataResolver) LayerShas() []string {
	value := resolver.data.GetLayerShas()
	return value
}

func (resolver *imageMetadataResolver) V1() (*v1MetadataResolver, error) {
	value := resolver.data.GetV1()
	return resolver.root.wrapV1Metadata(value, true, nil)
}

func (resolver *imageMetadataResolver) V2() (*v2MetadataResolver, error) {
	value := resolver.data.GetV2()
	return resolver.root.wrapV2Metadata(value, true, nil)
}

type imageNameResolver struct {
	root *Resolver
	data *storage.ImageName
}

func (resolver *Resolver) wrapImageName(value *storage.ImageName, ok bool, err error) (*imageNameResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageNameResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageNames(values []*storage.ImageName, err error) ([]*imageNameResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageNameResolver, len(values))
	for i, v := range values {
		output[i] = &imageNameResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageNameResolver) FullName() string {
	value := resolver.data.GetFullName()
	return value
}

func (resolver *imageNameResolver) Registry() string {
	value := resolver.data.GetRegistry()
	return value
}

func (resolver *imageNameResolver) Remote() string {
	value := resolver.data.GetRemote()
	return value
}

func (resolver *imageNameResolver) Tag() string {
	value := resolver.data.GetTag()
	return value
}

type imageNamePolicyResolver struct {
	root *Resolver
	data *v1.ImageNamePolicy
}

func (resolver *Resolver) wrapImageNamePolicy(value *v1.ImageNamePolicy, ok bool, err error) (*imageNamePolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageNamePolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageNamePolicies(values []*v1.ImageNamePolicy, err error) ([]*imageNamePolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageNamePolicyResolver, len(values))
	for i, v := range values {
		output[i] = &imageNamePolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageNamePolicyResolver) Registry() string {
	value := resolver.data.GetRegistry()
	return value
}

func (resolver *imageNamePolicyResolver) Remote() string {
	value := resolver.data.GetRemote()
	return value
}

func (resolver *imageNamePolicyResolver) Tag() string {
	value := resolver.data.GetTag()
	return value
}

type imageScanResolver struct {
	root *Resolver
	data *storage.ImageScan
}

func (resolver *Resolver) wrapImageScan(value *storage.ImageScan, ok bool, err error) (*imageScanResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageScanResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageScans(values []*storage.ImageScan, err error) ([]*imageScanResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageScanResolver, len(values))
	for i, v := range values {
		output[i] = &imageScanResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageScanResolver) Components() ([]*imageScanComponentResolver, error) {
	value := resolver.data.GetComponents()
	return resolver.root.wrapImageScanComponents(value, nil)
}

func (resolver *imageScanResolver) ScanTime() (graphql.Time, error) {
	value := resolver.data.GetScanTime()
	return timestamp(value)
}

type imageScanComponentResolver struct {
	root *Resolver
	data *storage.ImageScanComponent
}

func (resolver *Resolver) wrapImageScanComponent(value *storage.ImageScanComponent, ok bool, err error) (*imageScanComponentResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageScanComponentResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageScanComponents(values []*storage.ImageScanComponent, err error) ([]*imageScanComponentResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageScanComponentResolver, len(values))
	for i, v := range values {
		output[i] = &imageScanComponentResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageScanComponentResolver) License() (*licenseResolver, error) {
	value := resolver.data.GetLicense()
	return resolver.root.wrapLicense(value, true, nil)
}

func (resolver *imageScanComponentResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *imageScanComponentResolver) Version() string {
	value := resolver.data.GetVersion()
	return value
}

func (resolver *imageScanComponentResolver) Vulns() ([]*vulnerabilityResolver, error) {
	value := resolver.data.GetVulns()
	return resolver.root.wrapVulnerabilities(value, nil)
}

type jiraResolver struct {
	root *Resolver
	data *v1.Jira
}

func (resolver *Resolver) wrapJira(value *v1.Jira, ok bool, err error) (*jiraResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &jiraResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapJiras(values []*v1.Jira, err error) ([]*jiraResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*jiraResolver, len(values))
	for i, v := range values {
		output[i] = &jiraResolver{resolver, v}
	}
	return output, nil
}

func (resolver *jiraResolver) IssueType() string {
	value := resolver.data.GetIssueType()
	return value
}

func (resolver *jiraResolver) Password() string {
	value := resolver.data.GetPassword()
	return value
}

func (resolver *jiraResolver) Url() string {
	value := resolver.data.GetUrl()
	return value
}

func (resolver *jiraResolver) Username() string {
	value := resolver.data.GetUsername()
	return value
}

type keyValuePolicyResolver struct {
	root *Resolver
	data *v1.KeyValuePolicy
}

func (resolver *Resolver) wrapKeyValuePolicy(value *v1.KeyValuePolicy, ok bool, err error) (*keyValuePolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &keyValuePolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapKeyValuePolicies(values []*v1.KeyValuePolicy, err error) ([]*keyValuePolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*keyValuePolicyResolver, len(values))
	for i, v := range values {
		output[i] = &keyValuePolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *keyValuePolicyResolver) Key() string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *keyValuePolicyResolver) Value() string {
	value := resolver.data.GetValue()
	return value
}

type kubernetesParamsResolver struct {
	root *Resolver
	data *v1.KubernetesParams
}

func (resolver *Resolver) wrapKubernetesParams(value *v1.KubernetesParams, ok bool, err error) (*kubernetesParamsResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &kubernetesParamsResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapKubernetesParamses(values []*v1.KubernetesParams, err error) ([]*kubernetesParamsResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*kubernetesParamsResolver, len(values))
	for i, v := range values {
		output[i] = &kubernetesParamsResolver{resolver, v}
	}
	return output, nil
}

func (resolver *kubernetesParamsResolver) Params() (*commonKubernetesParamsResolver, error) {
	value := resolver.data.GetParams()
	return resolver.root.wrapCommonKubernetesParams(value, true, nil)
}

func toL4Protocol(value *string) v1.L4Protocol {
	if value != nil {
		return v1.L4Protocol(v1.L4Protocol_value[*value])
	}
	return v1.L4Protocol(0)
}

func toL4Protocols(values *[]string) []v1.L4Protocol {
	if values == nil {
		return nil
	}
	output := make([]v1.L4Protocol, len(*values))
	for i, v := range *values {
		output[i] = toL4Protocol(&v)
	}
	return output
}

type licenseResolver struct {
	root *Resolver
	data *storage.License
}

func (resolver *Resolver) wrapLicense(value *storage.License, ok bool, err error) (*licenseResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &licenseResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapLicenses(values []*storage.License, err error) ([]*licenseResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*licenseResolver, len(values))
	for i, v := range values {
		output[i] = &licenseResolver{resolver, v}
	}
	return output, nil
}

func (resolver *licenseResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *licenseResolver) Type() string {
	value := resolver.data.GetType()
	return value
}

func (resolver *licenseResolver) Url() string {
	value := resolver.data.GetUrl()
	return value
}

func toLifecycleStage(value *string) v1.LifecycleStage {
	if value != nil {
		return v1.LifecycleStage(v1.LifecycleStage_value[*value])
	}
	return v1.LifecycleStage(0)
}

func toLifecycleStages(values *[]string) []v1.LifecycleStage {
	if values == nil {
		return nil
	}
	output := make([]v1.LifecycleStage, len(*values))
	for i, v := range *values {
		output[i] = toLifecycleStage(&v)
	}
	return output
}

type metadataResolver struct {
	root *Resolver
	data *v1.Metadata
}

func (resolver *Resolver) wrapMetadata(value *v1.Metadata, ok bool, err error) (*metadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &metadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapMetadatas(values []*v1.Metadata, err error) ([]*metadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*metadataResolver, len(values))
	for i, v := range values {
		output[i] = &metadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *metadataResolver) Version() string {
	value := resolver.data.GetVersion()
	return value
}

type networkEntityInfoResolver struct {
	root *Resolver
	data *v1.NetworkEntityInfo
}

func (resolver *Resolver) wrapNetworkEntityInfo(value *v1.NetworkEntityInfo, ok bool, err error) (*networkEntityInfoResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &networkEntityInfoResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNetworkEntityInfos(values []*v1.NetworkEntityInfo, err error) ([]*networkEntityInfoResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*networkEntityInfoResolver, len(values))
	for i, v := range values {
		output[i] = &networkEntityInfoResolver{resolver, v}
	}
	return output, nil
}

func (resolver *networkEntityInfoResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *networkEntityInfoResolver) Type() string {
	value := resolver.data.GetType()
	return value.String()
}

type networkEntityInfoDescResolver struct {
	resolver *networkEntityInfoResolver
}

func (resolver *networkEntityInfoResolver) Desc() *networkEntityInfoDescResolver {
	return &networkEntityInfoDescResolver{resolver}
}

func (resolver *networkEntityInfoDescResolver) ToNetworkEntityInfo_Deployment() (*networkEntityInfo_DeploymentResolver, bool) {
	value := resolver.resolver.data.GetDeployment()
	if value != nil {
		return &networkEntityInfo_DeploymentResolver{resolver.resolver.root, value}, true
	}
	return nil, false
}

type networkEntityInfo_DeploymentResolver struct {
	root *Resolver
	data *v1.NetworkEntityInfo_Deployment
}

func (resolver *Resolver) wrapNetworkEntityInfo_Deployment(value *v1.NetworkEntityInfo_Deployment, ok bool, err error) (*networkEntityInfo_DeploymentResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &networkEntityInfo_DeploymentResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNetworkEntityInfo_Deployments(values []*v1.NetworkEntityInfo_Deployment, err error) ([]*networkEntityInfo_DeploymentResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*networkEntityInfo_DeploymentResolver, len(values))
	for i, v := range values {
		output[i] = &networkEntityInfo_DeploymentResolver{resolver, v}
	}
	return output, nil
}

func (resolver *networkEntityInfo_DeploymentResolver) Cluster() string {
	value := resolver.data.GetCluster()
	return value
}

func (resolver *networkEntityInfo_DeploymentResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *networkEntityInfo_DeploymentResolver) Namespace() string {
	value := resolver.data.GetNamespace()
	return value
}

func toNetworkEntityInfo_Type(value *string) v1.NetworkEntityInfo_Type {
	if value != nil {
		return v1.NetworkEntityInfo_Type(v1.NetworkEntityInfo_Type_value[*value])
	}
	return v1.NetworkEntityInfo_Type(0)
}

func toNetworkEntityInfo_Types(values *[]string) []v1.NetworkEntityInfo_Type {
	if values == nil {
		return nil
	}
	output := make([]v1.NetworkEntityInfo_Type, len(*values))
	for i, v := range *values {
		output[i] = toNetworkEntityInfo_Type(&v)
	}
	return output
}

type networkFlowResolver struct {
	root *Resolver
	data *v1.NetworkFlow
}

func (resolver *Resolver) wrapNetworkFlow(value *v1.NetworkFlow, ok bool, err error) (*networkFlowResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &networkFlowResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNetworkFlows(values []*v1.NetworkFlow, err error) ([]*networkFlowResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*networkFlowResolver, len(values))
	for i, v := range values {
		output[i] = &networkFlowResolver{resolver, v}
	}
	return output, nil
}

func (resolver *networkFlowResolver) LastSeenTimestamp() (graphql.Time, error) {
	value := resolver.data.GetLastSeenTimestamp()
	return timestamp(value)
}

func (resolver *networkFlowResolver) Props() (*networkFlowPropertiesResolver, error) {
	value := resolver.data.GetProps()
	return resolver.root.wrapNetworkFlowProperties(value, true, nil)
}

type networkFlowPropertiesResolver struct {
	root *Resolver
	data *v1.NetworkFlowProperties
}

func (resolver *Resolver) wrapNetworkFlowProperties(value *v1.NetworkFlowProperties, ok bool, err error) (*networkFlowPropertiesResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &networkFlowPropertiesResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNetworkFlowPropertieses(values []*v1.NetworkFlowProperties, err error) ([]*networkFlowPropertiesResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*networkFlowPropertiesResolver, len(values))
	for i, v := range values {
		output[i] = &networkFlowPropertiesResolver{resolver, v}
	}
	return output, nil
}

func (resolver *networkFlowPropertiesResolver) DstEntity() (*networkEntityInfoResolver, error) {
	value := resolver.data.GetDstEntity()
	return resolver.root.wrapNetworkEntityInfo(value, true, nil)
}

func (resolver *networkFlowPropertiesResolver) DstPort() int32 {
	value := resolver.data.GetDstPort()
	return int32(value)
}

func (resolver *networkFlowPropertiesResolver) L4Protocol() string {
	value := resolver.data.GetL4Protocol()
	return value.String()
}

func (resolver *networkFlowPropertiesResolver) SrcEntity() (*networkEntityInfoResolver, error) {
	value := resolver.data.GetSrcEntity()
	return resolver.root.wrapNetworkEntityInfo(value, true, nil)
}

type nodeResolver struct {
	root *Resolver
	data *v1.Node
}

func (resolver *Resolver) wrapNode(value *v1.Node, ok bool, err error) (*nodeResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &nodeResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNodes(values []*v1.Node, err error) ([]*nodeResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*nodeResolver, len(values))
	for i, v := range values {
		output[i] = &nodeResolver{resolver, v}
	}
	return output, nil
}

func (resolver *nodeResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *nodeResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

type notifierResolver struct {
	root *Resolver
	data *v1.Notifier
}

func (resolver *Resolver) wrapNotifier(value *v1.Notifier, ok bool, err error) (*notifierResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &notifierResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNotifiers(values []*v1.Notifier, err error) ([]*notifierResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*notifierResolver, len(values))
	for i, v := range values {
		output[i] = &notifierResolver{resolver, v}
	}
	return output, nil
}

func (resolver *notifierResolver) Enabled() bool {
	value := resolver.data.GetEnabled()
	return value
}

func (resolver *notifierResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *notifierResolver) LabelDefault() string {
	value := resolver.data.GetLabelDefault()
	return value
}

func (resolver *notifierResolver) LabelKey() string {
	value := resolver.data.GetLabelKey()
	return value
}

func (resolver *notifierResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *notifierResolver) Type() string {
	value := resolver.data.GetType()
	return value
}

func (resolver *notifierResolver) UiEndpoint() string {
	value := resolver.data.GetUiEndpoint()
	return value
}

type notifierConfigResolver struct {
	resolver *notifierResolver
}

func (resolver *notifierResolver) Config() *notifierConfigResolver {
	return &notifierConfigResolver{resolver}
}

func (resolver *notifierConfigResolver) ToJira() (*jiraResolver, bool) {
	value := resolver.resolver.data.GetJira()
	if value != nil {
		return &jiraResolver{resolver.resolver.root, value}, true
	}
	return nil, false
}

func (resolver *notifierConfigResolver) ToEmail() (*emailResolver, bool) {
	value := resolver.resolver.data.GetEmail()
	if value != nil {
		return &emailResolver{resolver.resolver.root, value}, true
	}
	return nil, false
}

func (resolver *notifierConfigResolver) ToCSCC() (*cSCCResolver, bool) {
	value := resolver.resolver.data.GetCscc()
	if value != nil {
		return &cSCCResolver{resolver.resolver.root, value}, true
	}
	return nil, false
}

func (resolver *notifierConfigResolver) ToSplunk() (*splunkResolver, bool) {
	value := resolver.resolver.data.GetSplunk()
	if value != nil {
		return &splunkResolver{resolver.resolver.root, value}, true
	}
	return nil, false
}

type numericalPolicyResolver struct {
	root *Resolver
	data *v1.NumericalPolicy
}

func (resolver *Resolver) wrapNumericalPolicy(value *v1.NumericalPolicy, ok bool, err error) (*numericalPolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &numericalPolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNumericalPolicies(values []*v1.NumericalPolicy, err error) ([]*numericalPolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*numericalPolicyResolver, len(values))
	for i, v := range values {
		output[i] = &numericalPolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *numericalPolicyResolver) Op() string {
	value := resolver.data.GetOp()
	return value.String()
}

func (resolver *numericalPolicyResolver) Value() float64 {
	value := resolver.data.GetValue()
	return float64(value)
}

type openshiftParamsResolver struct {
	root *Resolver
	data *v1.OpenshiftParams
}

func (resolver *Resolver) wrapOpenshiftParams(value *v1.OpenshiftParams, ok bool, err error) (*openshiftParamsResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &openshiftParamsResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapOpenshiftParamses(values []*v1.OpenshiftParams, err error) ([]*openshiftParamsResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*openshiftParamsResolver, len(values))
	for i, v := range values {
		output[i] = &openshiftParamsResolver{resolver, v}
	}
	return output, nil
}

func (resolver *openshiftParamsResolver) Params() (*commonKubernetesParamsResolver, error) {
	value := resolver.data.GetParams()
	return resolver.root.wrapCommonKubernetesParams(value, true, nil)
}

type policyResolver struct {
	root *Resolver
	data *v1.Policy
}

func (resolver *Resolver) wrapPolicy(value *v1.Policy, ok bool, err error) (*policyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &policyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPolicies(values []*v1.Policy, err error) ([]*policyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*policyResolver, len(values))
	for i, v := range values {
		output[i] = &policyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *policyResolver) Categories() []string {
	value := resolver.data.GetCategories()
	return value
}

func (resolver *policyResolver) Description() string {
	value := resolver.data.GetDescription()
	return value
}

func (resolver *policyResolver) Disabled() bool {
	value := resolver.data.GetDisabled()
	return value
}

func (resolver *policyResolver) EnforcementActions() []string {
	value := resolver.data.GetEnforcementActions()
	return stringSlice(value)
}

func (resolver *policyResolver) Fields() (*policyFieldsResolver, error) {
	value := resolver.data.GetFields()
	return resolver.root.wrapPolicyFields(value, true, nil)
}

func (resolver *policyResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *policyResolver) LifecycleStages() []string {
	value := resolver.data.GetLifecycleStages()
	return stringSlice(value)
}

func (resolver *policyResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *policyResolver) Notifiers() []string {
	value := resolver.data.GetNotifiers()
	return value
}

func (resolver *policyResolver) Rationale() string {
	value := resolver.data.GetRationale()
	return value
}

func (resolver *policyResolver) Remediation() string {
	value := resolver.data.GetRemediation()
	return value
}

func (resolver *policyResolver) Scope() ([]*scopeResolver, error) {
	value := resolver.data.GetScope()
	return resolver.root.wrapScopes(value, nil)
}

func (resolver *policyResolver) Severity() string {
	value := resolver.data.GetSeverity()
	return value.String()
}

func (resolver *policyResolver) Whitelists() ([]*whitelistResolver, error) {
	value := resolver.data.GetWhitelists()
	return resolver.root.wrapWhitelists(value, nil)
}

type policyFieldsResolver struct {
	root *Resolver
	data *v1.PolicyFields
}

func (resolver *Resolver) wrapPolicyFields(value *v1.PolicyFields, ok bool, err error) (*policyFieldsResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &policyFieldsResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPolicyFieldses(values []*v1.PolicyFields, err error) ([]*policyFieldsResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*policyFieldsResolver, len(values))
	for i, v := range values {
		output[i] = &policyFieldsResolver{resolver, v}
	}
	return output, nil
}

func (resolver *policyFieldsResolver) AddCapabilities() []string {
	value := resolver.data.GetAddCapabilities()
	return value
}

func (resolver *policyFieldsResolver) Args() string {
	value := resolver.data.GetArgs()
	return value
}

func (resolver *policyFieldsResolver) Command() string {
	value := resolver.data.GetCommand()
	return value
}

func (resolver *policyFieldsResolver) Component() (*componentResolver, error) {
	value := resolver.data.GetComponent()
	return resolver.root.wrapComponent(value, true, nil)
}

func (resolver *policyFieldsResolver) ContainerResourcePolicy() (*resourcePolicyResolver, error) {
	value := resolver.data.GetContainerResourcePolicy()
	return resolver.root.wrapResourcePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) Cve() string {
	value := resolver.data.GetCve()
	return value
}

func (resolver *policyFieldsResolver) Cvss() (*numericalPolicyResolver, error) {
	value := resolver.data.GetCvss()
	return resolver.root.wrapNumericalPolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) Directory() string {
	value := resolver.data.GetDirectory()
	return value
}

func (resolver *policyFieldsResolver) DropCapabilities() []string {
	value := resolver.data.GetDropCapabilities()
	return value
}

func (resolver *policyFieldsResolver) Env() (*keyValuePolicyResolver, error) {
	value := resolver.data.GetEnv()
	return resolver.root.wrapKeyValuePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) ImageName() (*imageNamePolicyResolver, error) {
	value := resolver.data.GetImageName()
	return resolver.root.wrapImageNamePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) LineRule() (*dockerfileLineRuleFieldResolver, error) {
	value := resolver.data.GetLineRule()
	return resolver.root.wrapDockerfileLineRuleField(value, true, nil)
}

func (resolver *policyFieldsResolver) PortPolicy() (*portPolicyResolver, error) {
	value := resolver.data.GetPortPolicy()
	return resolver.root.wrapPortPolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) ProcessPolicy() (*processPolicyResolver, error) {
	value := resolver.data.GetProcessPolicy()
	return resolver.root.wrapProcessPolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) RequiredAnnotation() (*keyValuePolicyResolver, error) {
	value := resolver.data.GetRequiredAnnotation()
	return resolver.root.wrapKeyValuePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) RequiredLabel() (*keyValuePolicyResolver, error) {
	value := resolver.data.GetRequiredLabel()
	return resolver.root.wrapKeyValuePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) User() string {
	value := resolver.data.GetUser()
	return value
}

func (resolver *policyFieldsResolver) VolumePolicy() (*volumePolicyResolver, error) {
	value := resolver.data.GetVolumePolicy()
	return resolver.root.wrapVolumePolicy(value, true, nil)
}

type portConfigResolver struct {
	root *Resolver
	data *storage.PortConfig
}

func (resolver *Resolver) wrapPortConfig(value *storage.PortConfig, ok bool, err error) (*portConfigResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &portConfigResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPortConfigs(values []*storage.PortConfig, err error) ([]*portConfigResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*portConfigResolver, len(values))
	for i, v := range values {
		output[i] = &portConfigResolver{resolver, v}
	}
	return output, nil
}

func (resolver *portConfigResolver) ContainerPort() int32 {
	value := resolver.data.GetContainerPort()
	return value
}

func (resolver *portConfigResolver) ExposedPort() int32 {
	value := resolver.data.GetExposedPort()
	return value
}

func (resolver *portConfigResolver) Exposure() string {
	value := resolver.data.GetExposure()
	return value.String()
}

func (resolver *portConfigResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *portConfigResolver) Protocol() string {
	value := resolver.data.GetProtocol()
	return value
}

func toPortConfig_Exposure(value *string) storage.PortConfig_Exposure {
	if value != nil {
		return storage.PortConfig_Exposure(storage.PortConfig_Exposure_value[*value])
	}
	return storage.PortConfig_Exposure(0)
}

func toPortConfig_Exposures(values *[]string) []storage.PortConfig_Exposure {
	if values == nil {
		return nil
	}
	output := make([]storage.PortConfig_Exposure, len(*values))
	for i, v := range *values {
		output[i] = toPortConfig_Exposure(&v)
	}
	return output
}

type portPolicyResolver struct {
	root *Resolver
	data *v1.PortPolicy
}

func (resolver *Resolver) wrapPortPolicy(value *v1.PortPolicy, ok bool, err error) (*portPolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &portPolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPortPolicies(values []*v1.PortPolicy, err error) ([]*portPolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*portPolicyResolver, len(values))
	for i, v := range values {
		output[i] = &portPolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *portPolicyResolver) Port() int32 {
	value := resolver.data.GetPort()
	return value
}

func (resolver *portPolicyResolver) Protocol() string {
	value := resolver.data.GetProtocol()
	return value
}

type processGroupResolver struct {
	root *Resolver
	data *v1.ProcessGroup
}

func (resolver *Resolver) wrapProcessGroup(value *v1.ProcessGroup, ok bool, err error) (*processGroupResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &processGroupResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapProcessGroups(values []*v1.ProcessGroup, err error) ([]*processGroupResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*processGroupResolver, len(values))
	for i, v := range values {
		output[i] = &processGroupResolver{resolver, v}
	}
	return output, nil
}

func (resolver *processGroupResolver) Args() string {
	value := resolver.data.GetArgs()
	return value
}

func (resolver *processGroupResolver) Signals() ([]*processIndicatorResolver, error) {
	value := resolver.data.GetSignals()
	return resolver.root.wrapProcessIndicators(value, nil)
}

type processIndicatorResolver struct {
	root *Resolver
	data *v1.ProcessIndicator
}

func (resolver *Resolver) wrapProcessIndicator(value *v1.ProcessIndicator, ok bool, err error) (*processIndicatorResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &processIndicatorResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapProcessIndicators(values []*v1.ProcessIndicator, err error) ([]*processIndicatorResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*processIndicatorResolver, len(values))
	for i, v := range values {
		output[i] = &processIndicatorResolver{resolver, v}
	}
	return output, nil
}

func (resolver *processIndicatorResolver) ContainerName() string {
	value := resolver.data.GetContainerName()
	return value
}

func (resolver *processIndicatorResolver) DeploymentId() string {
	value := resolver.data.GetDeploymentId()
	return value
}

func (resolver *processIndicatorResolver) EmitTimestamp() (graphql.Time, error) {
	value := resolver.data.GetEmitTimestamp()
	return timestamp(value)
}

func (resolver *processIndicatorResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *processIndicatorResolver) PodId() string {
	value := resolver.data.GetPodId()
	return value
}

func (resolver *processIndicatorResolver) Signal() (*processSignalResolver, error) {
	value := resolver.data.GetSignal()
	return resolver.root.wrapProcessSignal(value, true, nil)
}

type processNameGroupResolver struct {
	root *Resolver
	data *v1.ProcessNameGroup
}

func (resolver *Resolver) wrapProcessNameGroup(value *v1.ProcessNameGroup, ok bool, err error) (*processNameGroupResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &processNameGroupResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapProcessNameGroups(values []*v1.ProcessNameGroup, err error) ([]*processNameGroupResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*processNameGroupResolver, len(values))
	for i, v := range values {
		output[i] = &processNameGroupResolver{resolver, v}
	}
	return output, nil
}

func (resolver *processNameGroupResolver) Groups() ([]*processGroupResolver, error) {
	value := resolver.data.GetGroups()
	return resolver.root.wrapProcessGroups(value, nil)
}

func (resolver *processNameGroupResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *processNameGroupResolver) TimesExecuted() int32 {
	value := resolver.data.GetTimesExecuted()
	return int32(value)
}

type processPolicyResolver struct {
	root *Resolver
	data *v1.ProcessPolicy
}

func (resolver *Resolver) wrapProcessPolicy(value *v1.ProcessPolicy, ok bool, err error) (*processPolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &processPolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapProcessPolicies(values []*v1.ProcessPolicy, err error) ([]*processPolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*processPolicyResolver, len(values))
	for i, v := range values {
		output[i] = &processPolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *processPolicyResolver) Args() string {
	value := resolver.data.GetArgs()
	return value
}

func (resolver *processPolicyResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

type processSignalResolver struct {
	root *Resolver
	data *v1.ProcessSignal
}

func (resolver *Resolver) wrapProcessSignal(value *v1.ProcessSignal, ok bool, err error) (*processSignalResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &processSignalResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapProcessSignals(values []*v1.ProcessSignal, err error) ([]*processSignalResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*processSignalResolver, len(values))
	for i, v := range values {
		output[i] = &processSignalResolver{resolver, v}
	}
	return output, nil
}

func (resolver *processSignalResolver) Args() string {
	value := resolver.data.GetArgs()
	return value
}

func (resolver *processSignalResolver) ContainerId() string {
	value := resolver.data.GetContainerId()
	return value
}

func (resolver *processSignalResolver) ExecFilePath() string {
	value := resolver.data.GetExecFilePath()
	return value
}

func (resolver *processSignalResolver) Gid() int32 {
	value := resolver.data.GetGid()
	return int32(value)
}

func (resolver *processSignalResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *processSignalResolver) Lineage() []string {
	value := resolver.data.GetLineage()
	return value
}

func (resolver *processSignalResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *processSignalResolver) Pid() int32 {
	value := resolver.data.GetPid()
	return int32(value)
}

func (resolver *processSignalResolver) Time() (graphql.Time, error) {
	value := resolver.data.GetTime()
	return timestamp(value)
}

func (resolver *processSignalResolver) Uid() int32 {
	value := resolver.data.GetUid()
	return int32(value)
}

type resourcePolicyResolver struct {
	root *Resolver
	data *v1.ResourcePolicy
}

func (resolver *Resolver) wrapResourcePolicy(value *v1.ResourcePolicy, ok bool, err error) (*resourcePolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &resourcePolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapResourcePolicies(values []*v1.ResourcePolicy, err error) ([]*resourcePolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*resourcePolicyResolver, len(values))
	for i, v := range values {
		output[i] = &resourcePolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *resourcePolicyResolver) CpuResourceLimit() (*numericalPolicyResolver, error) {
	value := resolver.data.GetCpuResourceLimit()
	return resolver.root.wrapNumericalPolicy(value, true, nil)
}

func (resolver *resourcePolicyResolver) CpuResourceRequest() (*numericalPolicyResolver, error) {
	value := resolver.data.GetCpuResourceRequest()
	return resolver.root.wrapNumericalPolicy(value, true, nil)
}

func (resolver *resourcePolicyResolver) MemoryResourceLimit() (*numericalPolicyResolver, error) {
	value := resolver.data.GetMemoryResourceLimit()
	return resolver.root.wrapNumericalPolicy(value, true, nil)
}

func (resolver *resourcePolicyResolver) MemoryResourceRequest() (*numericalPolicyResolver, error) {
	value := resolver.data.GetMemoryResourceRequest()
	return resolver.root.wrapNumericalPolicy(value, true, nil)
}

type resourcesResolver struct {
	root *Resolver
	data *storage.Resources
}

func (resolver *Resolver) wrapResources(value *storage.Resources, ok bool, err error) (*resourcesResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &resourcesResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapResourceses(values []*storage.Resources, err error) ([]*resourcesResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*resourcesResolver, len(values))
	for i, v := range values {
		output[i] = &resourcesResolver{resolver, v}
	}
	return output, nil
}

func (resolver *resourcesResolver) CpuCoresLimit() float64 {
	value := resolver.data.GetCpuCoresLimit()
	return float64(value)
}

func (resolver *resourcesResolver) CpuCoresRequest() float64 {
	value := resolver.data.GetCpuCoresRequest()
	return float64(value)
}

func (resolver *resourcesResolver) MemoryMbLimit() float64 {
	value := resolver.data.GetMemoryMbLimit()
	return float64(value)
}

func (resolver *resourcesResolver) MemoryMbRequest() float64 {
	value := resolver.data.GetMemoryMbRequest()
	return float64(value)
}

type riskResolver struct {
	root *Resolver
	data *storage.Risk
}

func (resolver *Resolver) wrapRisk(value *storage.Risk, ok bool, err error) (*riskResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &riskResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapRisks(values []*storage.Risk, err error) ([]*riskResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*riskResolver, len(values))
	for i, v := range values {
		output[i] = &riskResolver{resolver, v}
	}
	return output, nil
}

func (resolver *riskResolver) Results() ([]*risk_ResultResolver, error) {
	value := resolver.data.GetResults()
	return resolver.root.wrapRisk_Results(value, nil)
}

func (resolver *riskResolver) Score() float64 {
	value := resolver.data.GetScore()
	return float64(value)
}

type risk_ResultResolver struct {
	root *Resolver
	data *storage.Risk_Result
}

func (resolver *Resolver) wrapRisk_Result(value *storage.Risk_Result, ok bool, err error) (*risk_ResultResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &risk_ResultResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapRisk_Results(values []*storage.Risk_Result, err error) ([]*risk_ResultResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*risk_ResultResolver, len(values))
	for i, v := range values {
		output[i] = &risk_ResultResolver{resolver, v}
	}
	return output, nil
}

func (resolver *risk_ResultResolver) Factors() ([]*risk_Result_FactorResolver, error) {
	value := resolver.data.GetFactors()
	return resolver.root.wrapRisk_Result_Factors(value, nil)
}

func (resolver *risk_ResultResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *risk_ResultResolver) Score() float64 {
	value := resolver.data.GetScore()
	return float64(value)
}

type risk_Result_FactorResolver struct {
	root *Resolver
	data *storage.Risk_Result_Factor
}

func (resolver *Resolver) wrapRisk_Result_Factor(value *storage.Risk_Result_Factor, ok bool, err error) (*risk_Result_FactorResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &risk_Result_FactorResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapRisk_Result_Factors(values []*storage.Risk_Result_Factor, err error) ([]*risk_Result_FactorResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*risk_Result_FactorResolver, len(values))
	for i, v := range values {
		output[i] = &risk_Result_FactorResolver{resolver, v}
	}
	return output, nil
}

func (resolver *risk_Result_FactorResolver) Message() string {
	value := resolver.data.GetMessage()
	return value
}

func (resolver *risk_Result_FactorResolver) Url() string {
	value := resolver.data.GetUrl()
	return value
}

type roleResolver struct {
	root *Resolver
	data *v1.Role
}

func (resolver *Resolver) wrapRole(value *v1.Role, ok bool, err error) (*roleResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &roleResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapRoles(values []*v1.Role, err error) ([]*roleResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*roleResolver, len(values))
	for i, v := range values {
		output[i] = &roleResolver{resolver, v}
	}
	return output, nil
}

func (resolver *roleResolver) GlobalAccess() string {
	value := resolver.data.GetGlobalAccess()
	return value.String()
}

func (resolver *roleResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

type scopeResolver struct {
	root *Resolver
	data *storage.Scope
}

func (resolver *Resolver) wrapScope(value *storage.Scope, ok bool, err error) (*scopeResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &scopeResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapScopes(values []*storage.Scope, err error) ([]*scopeResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*scopeResolver, len(values))
	for i, v := range values {
		output[i] = &scopeResolver{resolver, v}
	}
	return output, nil
}

func (resolver *scopeResolver) Cluster() string {
	value := resolver.data.GetCluster()
	return value
}

func (resolver *scopeResolver) Label() (*scope_LabelResolver, error) {
	value := resolver.data.GetLabel()
	return resolver.root.wrapScope_Label(value, true, nil)
}

func (resolver *scopeResolver) Namespace() string {
	value := resolver.data.GetNamespace()
	return value
}

type scope_LabelResolver struct {
	root *Resolver
	data *storage.Scope_Label
}

func (resolver *Resolver) wrapScope_Label(value *storage.Scope_Label, ok bool, err error) (*scope_LabelResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &scope_LabelResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapScope_Labels(values []*storage.Scope_Label, err error) ([]*scope_LabelResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*scope_LabelResolver, len(values))
	for i, v := range values {
		output[i] = &scope_LabelResolver{resolver, v}
	}
	return output, nil
}

func (resolver *scope_LabelResolver) Key() string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *scope_LabelResolver) Value() string {
	value := resolver.data.GetValue()
	return value
}

func toSearchCategory(value *string) v1.SearchCategory {
	if value != nil {
		return v1.SearchCategory(v1.SearchCategory_value[*value])
	}
	return v1.SearchCategory(0)
}

func toSearchCategories(values *[]string) []v1.SearchCategory {
	if values == nil {
		return nil
	}
	output := make([]v1.SearchCategory, len(*values))
	for i, v := range *values {
		output[i] = toSearchCategory(&v)
	}
	return output
}

type searchResultResolver struct {
	root *Resolver
	data *v1.SearchResult
}

func (resolver *Resolver) wrapSearchResult(value *v1.SearchResult, ok bool, err error) (*searchResultResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &searchResultResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSearchResults(values []*v1.SearchResult, err error) ([]*searchResultResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*searchResultResolver, len(values))
	for i, v := range values {
		output[i] = &searchResultResolver{resolver, v}
	}
	return output, nil
}

func (resolver *searchResultResolver) Category() string {
	value := resolver.data.GetCategory()
	return value.String()
}

func (resolver *searchResultResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *searchResultResolver) Location() string {
	value := resolver.data.GetLocation()
	return value
}

func (resolver *searchResultResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *searchResultResolver) Score() float64 {
	value := resolver.data.GetScore()
	return value
}

type secretResolver struct {
	root *Resolver
	data *v1.Secret
	list *v1.ListSecret
}

func (resolver *Resolver) wrapSecret(value *v1.Secret, ok bool, err error) (*secretResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &secretResolver{resolver, value, nil}, nil
}

func (resolver *Resolver) wrapSecrets(values []*v1.Secret, err error) ([]*secretResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*secretResolver, len(values))
	for i, v := range values {
		output[i] = &secretResolver{resolver, v, nil}
	}
	return output, nil
}

func (resolver *Resolver) wrapListSecrets(values []*v1.ListSecret, err error) ([]*secretResolver, error) {
	if err != nil || values == nil {
		return nil, err
	}
	output := make([]*secretResolver, len(values))
	for i, v := range values {
		output[i] = &secretResolver{resolver, nil, v}
	}
	return output, nil
}

func (resolver *secretResolver) ensureData() {
	if resolver.data == nil {
		resolver.data = resolver.root.getSecret(resolver.list.GetId())
	}
}

func (resolver *secretResolver) Annotations() labels {
	resolver.ensureData()
	value := resolver.data.GetAnnotations()
	return labelsResolver(value)
}

func (resolver *secretResolver) ClusterId() string {
	resolver.ensureData()
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *secretResolver) ClusterName() string {
	value := resolver.data.GetClusterName()
	if resolver.data == nil {
		value = resolver.list.GetClusterName()
	}
	return value
}

func (resolver *secretResolver) CreatedAt() (graphql.Time, error) {
	value := resolver.data.GetCreatedAt()
	if resolver.data == nil {
		value = resolver.list.GetCreatedAt()
	}
	return timestamp(value)
}

func (resolver *secretResolver) Files() ([]*secretDataFileResolver, error) {
	resolver.ensureData()
	value := resolver.data.GetFiles()
	return resolver.root.wrapSecretDataFiles(value, nil)
}

func (resolver *secretResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	if resolver.data == nil {
		value = resolver.list.GetId()
	}
	return graphql.ID(value)
}

func (resolver *secretResolver) Labels() labels {
	resolver.ensureData()
	value := resolver.data.GetLabels()
	return labelsResolver(value)
}

func (resolver *secretResolver) Name() string {
	value := resolver.data.GetName()
	if resolver.data == nil {
		value = resolver.list.GetName()
	}
	return value
}

func (resolver *secretResolver) Namespace() string {
	value := resolver.data.GetNamespace()
	if resolver.data == nil {
		value = resolver.list.GetNamespace()
	}
	return value
}

func (resolver *secretResolver) Relationship() (*secretRelationshipResolver, error) {
	resolver.ensureData()
	value := resolver.data.GetRelationship()
	return resolver.root.wrapSecretRelationship(value, true, nil)
}

func (resolver *secretResolver) Type() string {
	resolver.ensureData()
	value := resolver.data.GetType()
	return value
}

type secretContainerRelationshipResolver struct {
	root *Resolver
	data *v1.SecretContainerRelationship
}

func (resolver *Resolver) wrapSecretContainerRelationship(value *v1.SecretContainerRelationship, ok bool, err error) (*secretContainerRelationshipResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &secretContainerRelationshipResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecretContainerRelationships(values []*v1.SecretContainerRelationship, err error) ([]*secretContainerRelationshipResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*secretContainerRelationshipResolver, len(values))
	for i, v := range values {
		output[i] = &secretContainerRelationshipResolver{resolver, v}
	}
	return output, nil
}

func (resolver *secretContainerRelationshipResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *secretContainerRelationshipResolver) Path() string {
	value := resolver.data.GetPath()
	return value
}

type secretDataFileResolver struct {
	root *Resolver
	data *v1.SecretDataFile
}

func (resolver *Resolver) wrapSecretDataFile(value *v1.SecretDataFile, ok bool, err error) (*secretDataFileResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &secretDataFileResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecretDataFiles(values []*v1.SecretDataFile, err error) ([]*secretDataFileResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*secretDataFileResolver, len(values))
	for i, v := range values {
		output[i] = &secretDataFileResolver{resolver, v}
	}
	return output, nil
}

func (resolver *secretDataFileResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *secretDataFileResolver) Type() string {
	value := resolver.data.GetType()
	return value.String()
}

type secretDataFileMetadataResolver struct {
	resolver *secretDataFileResolver
}

func (resolver *secretDataFileResolver) Metadata() *secretDataFileMetadataResolver {
	return &secretDataFileMetadataResolver{resolver}
}

func (resolver *secretDataFileMetadataResolver) ToCert() (*certResolver, bool) {
	value := resolver.resolver.data.GetCert()
	if value != nil {
		return &certResolver{resolver.resolver.root, value}, true
	}
	return nil, false
}

type secretDeploymentRelationshipResolver struct {
	root *Resolver
	data *v1.SecretDeploymentRelationship
}

func (resolver *Resolver) wrapSecretDeploymentRelationship(value *v1.SecretDeploymentRelationship, ok bool, err error) (*secretDeploymentRelationshipResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &secretDeploymentRelationshipResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecretDeploymentRelationships(values []*v1.SecretDeploymentRelationship, err error) ([]*secretDeploymentRelationshipResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*secretDeploymentRelationshipResolver, len(values))
	for i, v := range values {
		output[i] = &secretDeploymentRelationshipResolver{resolver, v}
	}
	return output, nil
}

func (resolver *secretDeploymentRelationshipResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *secretDeploymentRelationshipResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

type secretRelationshipResolver struct {
	root *Resolver
	data *v1.SecretRelationship
}

func (resolver *Resolver) wrapSecretRelationship(value *v1.SecretRelationship, ok bool, err error) (*secretRelationshipResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &secretRelationshipResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecretRelationships(values []*v1.SecretRelationship, err error) ([]*secretRelationshipResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*secretRelationshipResolver, len(values))
	for i, v := range values {
		output[i] = &secretRelationshipResolver{resolver, v}
	}
	return output, nil
}

func (resolver *secretRelationshipResolver) ContainerRelationships() ([]*secretContainerRelationshipResolver, error) {
	value := resolver.data.GetContainerRelationships()
	return resolver.root.wrapSecretContainerRelationships(value, nil)
}

func (resolver *secretRelationshipResolver) DeploymentRelationships() ([]*secretDeploymentRelationshipResolver, error) {
	value := resolver.data.GetDeploymentRelationships()
	return resolver.root.wrapSecretDeploymentRelationships(value, nil)
}

func (resolver *secretRelationshipResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func toSecretType(value *string) v1.SecretType {
	if value != nil {
		return v1.SecretType(v1.SecretType_value[*value])
	}
	return v1.SecretType(0)
}

func toSecretTypes(values *[]string) []v1.SecretType {
	if values == nil {
		return nil
	}
	output := make([]v1.SecretType, len(*values))
	for i, v := range *values {
		output[i] = toSecretType(&v)
	}
	return output
}

type securityContextResolver struct {
	root *Resolver
	data *storage.SecurityContext
}

func (resolver *Resolver) wrapSecurityContext(value *storage.SecurityContext, ok bool, err error) (*securityContextResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &securityContextResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecurityContexts(values []*storage.SecurityContext, err error) ([]*securityContextResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*securityContextResolver, len(values))
	for i, v := range values {
		output[i] = &securityContextResolver{resolver, v}
	}
	return output, nil
}

func (resolver *securityContextResolver) AddCapabilities() []string {
	value := resolver.data.GetAddCapabilities()
	return value
}

func (resolver *securityContextResolver) DropCapabilities() []string {
	value := resolver.data.GetDropCapabilities()
	return value
}

func (resolver *securityContextResolver) Privileged() bool {
	value := resolver.data.GetPrivileged()
	return value
}

func (resolver *securityContextResolver) Selinux() (*securityContext_SELinuxResolver, error) {
	value := resolver.data.GetSelinux()
	return resolver.root.wrapSecurityContext_SELinux(value, true, nil)
}

type securityContext_SELinuxResolver struct {
	root *Resolver
	data *storage.SecurityContext_SELinux
}

func (resolver *Resolver) wrapSecurityContext_SELinux(value *storage.SecurityContext_SELinux, ok bool, err error) (*securityContext_SELinuxResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &securityContext_SELinuxResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecurityContext_SELinuxs(values []*storage.SecurityContext_SELinux, err error) ([]*securityContext_SELinuxResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*securityContext_SELinuxResolver, len(values))
	for i, v := range values {
		output[i] = &securityContext_SELinuxResolver{resolver, v}
	}
	return output, nil
}

func (resolver *securityContext_SELinuxResolver) Level() string {
	value := resolver.data.GetLevel()
	return value
}

func (resolver *securityContext_SELinuxResolver) Role() string {
	value := resolver.data.GetRole()
	return value
}

func (resolver *securityContext_SELinuxResolver) Type() string {
	value := resolver.data.GetType()
	return value
}

func (resolver *securityContext_SELinuxResolver) User() string {
	value := resolver.data.GetUser()
	return value
}

func toSeverity(value *string) v1.Severity {
	if value != nil {
		return v1.Severity(v1.Severity_value[*value])
	}
	return v1.Severity(0)
}

func toSeverities(values *[]string) []v1.Severity {
	if values == nil {
		return nil
	}
	output := make([]v1.Severity, len(*values))
	for i, v := range *values {
		output[i] = toSeverity(&v)
	}
	return output
}

type splunkResolver struct {
	root *Resolver
	data *v1.Splunk
}

func (resolver *Resolver) wrapSplunk(value *v1.Splunk, ok bool, err error) (*splunkResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &splunkResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSplunks(values []*v1.Splunk, err error) ([]*splunkResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*splunkResolver, len(values))
	for i, v := range values {
		output[i] = &splunkResolver{resolver, v}
	}
	return output, nil
}

func (resolver *splunkResolver) HttpEndpoint() string {
	value := resolver.data.GetHttpEndpoint()
	return value
}

func (resolver *splunkResolver) HttpToken() string {
	value := resolver.data.GetHttpToken()
	return value
}

func (resolver *splunkResolver) Insecure() bool {
	value := resolver.data.GetInsecure()
	return value
}

type swarmParamsResolver struct {
	root *Resolver
	data *v1.SwarmParams
}

func (resolver *Resolver) wrapSwarmParams(value *v1.SwarmParams, ok bool, err error) (*swarmParamsResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &swarmParamsResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSwarmParamses(values []*v1.SwarmParams, err error) ([]*swarmParamsResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*swarmParamsResolver, len(values))
	for i, v := range values {
		output[i] = &swarmParamsResolver{resolver, v}
	}
	return output, nil
}

func (resolver *swarmParamsResolver) DisableSwarmTls() bool {
	value := resolver.data.GetDisableSwarmTls()
	return value
}

type tokenMetadataResolver struct {
	root *Resolver
	data *storage.TokenMetadata
}

func (resolver *Resolver) wrapTokenMetadata(value *storage.TokenMetadata, ok bool, err error) (*tokenMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &tokenMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapTokenMetadatas(values []*storage.TokenMetadata, err error) ([]*tokenMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*tokenMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &tokenMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *tokenMetadataResolver) Expiration() (graphql.Time, error) {
	value := resolver.data.GetExpiration()
	return timestamp(value)
}

func (resolver *tokenMetadataResolver) Id() graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *tokenMetadataResolver) IssuedAt() (graphql.Time, error) {
	value := resolver.data.GetIssuedAt()
	return timestamp(value)
}

func (resolver *tokenMetadataResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *tokenMetadataResolver) Revoked() bool {
	value := resolver.data.GetRevoked()
	return value
}

func (resolver *tokenMetadataResolver) Role() string {
	value := resolver.data.GetRole()
	return value
}

type v1MetadataResolver struct {
	root *Resolver
	data *storage.V1Metadata
}

func (resolver *Resolver) wrapV1Metadata(value *storage.V1Metadata, ok bool, err error) (*v1MetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &v1MetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapV1Metadatas(values []*storage.V1Metadata, err error) ([]*v1MetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*v1MetadataResolver, len(values))
	for i, v := range values {
		output[i] = &v1MetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *v1MetadataResolver) Author() string {
	value := resolver.data.GetAuthor()
	return value
}

func (resolver *v1MetadataResolver) Created() (graphql.Time, error) {
	value := resolver.data.GetCreated()
	return timestamp(value)
}

func (resolver *v1MetadataResolver) Digest() string {
	value := resolver.data.GetDigest()
	return value
}

func (resolver *v1MetadataResolver) Layers() ([]*imageLayerResolver, error) {
	value := resolver.data.GetLayers()
	return resolver.root.wrapImageLayers(value, nil)
}

type v2MetadataResolver struct {
	root *Resolver
	data *storage.V2Metadata
}

func (resolver *Resolver) wrapV2Metadata(value *storage.V2Metadata, ok bool, err error) (*v2MetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &v2MetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapV2Metadatas(values []*storage.V2Metadata, err error) ([]*v2MetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*v2MetadataResolver, len(values))
	for i, v := range values {
		output[i] = &v2MetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *v2MetadataResolver) Digest() string {
	value := resolver.data.GetDigest()
	return value
}

func toViolationState(value *string) v1.ViolationState {
	if value != nil {
		return v1.ViolationState(v1.ViolationState_value[*value])
	}
	return v1.ViolationState(0)
}

func toViolationStates(values *[]string) []v1.ViolationState {
	if values == nil {
		return nil
	}
	output := make([]v1.ViolationState, len(*values))
	for i, v := range *values {
		output[i] = toViolationState(&v)
	}
	return output
}

type volumeResolver struct {
	root *Resolver
	data *storage.Volume
}

func (resolver *Resolver) wrapVolume(value *storage.Volume, ok bool, err error) (*volumeResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &volumeResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapVolumes(values []*storage.Volume, err error) ([]*volumeResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*volumeResolver, len(values))
	for i, v := range values {
		output[i] = &volumeResolver{resolver, v}
	}
	return output, nil
}

func (resolver *volumeResolver) Destination() string {
	value := resolver.data.GetDestination()
	return value
}

func (resolver *volumeResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *volumeResolver) ReadOnly() bool {
	value := resolver.data.GetReadOnly()
	return value
}

func (resolver *volumeResolver) Source() string {
	value := resolver.data.GetSource()
	return value
}

func (resolver *volumeResolver) Type() string {
	value := resolver.data.GetType()
	return value
}

type volumePolicyResolver struct {
	root *Resolver
	data *v1.VolumePolicy
}

func (resolver *Resolver) wrapVolumePolicy(value *v1.VolumePolicy, ok bool, err error) (*volumePolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &volumePolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapVolumePolicies(values []*v1.VolumePolicy, err error) ([]*volumePolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*volumePolicyResolver, len(values))
	for i, v := range values {
		output[i] = &volumePolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *volumePolicyResolver) Destination() string {
	value := resolver.data.GetDestination()
	return value
}

func (resolver *volumePolicyResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *volumePolicyResolver) Source() string {
	value := resolver.data.GetSource()
	return value
}

func (resolver *volumePolicyResolver) Type() string {
	value := resolver.data.GetType()
	return value
}

type vulnerabilityResolver struct {
	root *Resolver
	data *storage.Vulnerability
}

func (resolver *Resolver) wrapVulnerability(value *storage.Vulnerability, ok bool, err error) (*vulnerabilityResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &vulnerabilityResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapVulnerabilities(values []*storage.Vulnerability, err error) ([]*vulnerabilityResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*vulnerabilityResolver, len(values))
	for i, v := range values {
		output[i] = &vulnerabilityResolver{resolver, v}
	}
	return output, nil
}

func (resolver *vulnerabilityResolver) Cve() string {
	value := resolver.data.GetCve()
	return value
}

func (resolver *vulnerabilityResolver) Cvss() float64 {
	value := resolver.data.GetCvss()
	return float64(value)
}

func (resolver *vulnerabilityResolver) CvssV2() (*cVSSV2Resolver, error) {
	value := resolver.data.GetCvssV2()
	return resolver.root.wrapCVSSV2(value, true, nil)
}

func (resolver *vulnerabilityResolver) Link() string {
	value := resolver.data.GetLink()
	return value
}

func (resolver *vulnerabilityResolver) Summary() string {
	value := resolver.data.GetSummary()
	return value
}

type whitelistResolver struct {
	root *Resolver
	data *v1.Whitelist
}

func (resolver *Resolver) wrapWhitelist(value *v1.Whitelist, ok bool, err error) (*whitelistResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &whitelistResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapWhitelists(values []*v1.Whitelist, err error) ([]*whitelistResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*whitelistResolver, len(values))
	for i, v := range values {
		output[i] = &whitelistResolver{resolver, v}
	}
	return output, nil
}

func (resolver *whitelistResolver) Container() (*whitelist_ContainerResolver, error) {
	value := resolver.data.GetContainer()
	return resolver.root.wrapWhitelist_Container(value, true, nil)
}

func (resolver *whitelistResolver) Deployment() (*whitelist_DeploymentResolver, error) {
	value := resolver.data.GetDeployment()
	return resolver.root.wrapWhitelist_Deployment(value, true, nil)
}

func (resolver *whitelistResolver) Expiration() (graphql.Time, error) {
	value := resolver.data.GetExpiration()
	return timestamp(value)
}

func (resolver *whitelistResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

type whitelist_ContainerResolver struct {
	root *Resolver
	data *v1.Whitelist_Container
}

func (resolver *Resolver) wrapWhitelist_Container(value *v1.Whitelist_Container, ok bool, err error) (*whitelist_ContainerResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &whitelist_ContainerResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapWhitelist_Containers(values []*v1.Whitelist_Container, err error) ([]*whitelist_ContainerResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*whitelist_ContainerResolver, len(values))
	for i, v := range values {
		output[i] = &whitelist_ContainerResolver{resolver, v}
	}
	return output, nil
}

func (resolver *whitelist_ContainerResolver) ImageName() (*imageNameResolver, error) {
	value := resolver.data.GetImageName()
	return resolver.root.wrapImageName(value, true, nil)
}

type whitelist_DeploymentResolver struct {
	root *Resolver
	data *v1.Whitelist_Deployment
}

func (resolver *Resolver) wrapWhitelist_Deployment(value *v1.Whitelist_Deployment, ok bool, err error) (*whitelist_DeploymentResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &whitelist_DeploymentResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapWhitelist_Deployments(values []*v1.Whitelist_Deployment, err error) ([]*whitelist_DeploymentResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*whitelist_DeploymentResolver, len(values))
	for i, v := range values {
		output[i] = &whitelist_DeploymentResolver{resolver, v}
	}
	return output, nil
}

func (resolver *whitelist_DeploymentResolver) Name() string {
	value := resolver.data.GetName()
	return value
}

func (resolver *whitelist_DeploymentResolver) Scope() (*scopeResolver, error) {
	value := resolver.data.GetScope()
	return resolver.root.wrapScope(value, true, nil)
}
