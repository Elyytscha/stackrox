// Code generated by graphql-generator. DO NOT EDIT.

package resolvers

import (
	"context"
	"reflect"

	"github.com/graph-gophers/graphql-go"
	"github.com/stackrox/rox/central/graphql/generator"
	"github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/generated/storage" // end range imports
	"github.com/stackrox/rox/pkg/utils"
)

func registerGeneratedTypes(builder generator.SchemaBuilder) {
	utils.Must(builder.AddType("Label", []string{"key: String!", "value: String!"}))
	utils.Must(builder.AddType("AWSProviderMetadata", []string{
		"accountId: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.Access(0)))
	utils.Must(builder.AddType("AdmissionControllerConfig", []string{
		"disableBypass: Boolean!",
		"enabled: Boolean!",
		"scanInline: Boolean!",
		"timeoutSeconds: Int!",
	}))
	utils.Must(builder.AddType("Alert", []string{
		"deployment: Alert_Deployment",
		"enforcement: Alert_Enforcement",
		"firstOccurred: Time",
		"id: ID!",
		"lifecycleStage: LifecycleStage!",
		"policy: Policy",
		"processViolation: Alert_ProcessViolation",
		"snoozeTill: Time",
		"state: ViolationState!",
		"time: Time",
		"violations: [Alert_Violation]!",
	}))
	utils.Must(builder.AddType("Alert_Deployment", []string{
		"annotations: [Label!]!",
		"clusterId: String!",
		"clusterName: String!",
		"containers: [Alert_Deployment_Container]!",
		"id: ID!",
		"inactive: Boolean!",
		"labels: [Label!]!",
		"name: String!",
		"namespace: String!",
		"type: String!",
	}))
	utils.Must(builder.AddType("Alert_Deployment_Container", []string{
		"image: ContainerImage",
		"name: String!",
	}))
	utils.Must(builder.AddType("Alert_Enforcement", []string{
		"action: EnforcementAction!",
		"message: String!",
	}))
	utils.Must(builder.AddType("Alert_ProcessViolation", []string{
		"message: String!",
		"processes: [ProcessIndicator]!",
	}))
	utils.Must(builder.AddType("Alert_Violation", []string{
		"message: String!",
	}))
	utils.Must(builder.AddType("AzureProviderMetadata", []string{
		"subscriptionId: String!",
	}))
	utils.Must(builder.AddType("CSCC", []string{
		"serviceAccount: String!",
		"sourceId: String!",
	}))
	utils.Must(builder.AddType("CVE", []string{
		"cvss: Float!",
		"cvssV2: CVSSV2",
		"cvssV3: CVSSV3",
		"id: ID!",
		"lastModified: Time",
		"link: String!",
		"publishedOn: Time",
		"references: [CVE_Reference]!",
		"scoreVersion: CVE_ScoreVersion!",
		"summary: String!",
		"type: CVE_CVEType!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVE_CVEType(0)))
	utils.Must(builder.AddType("CVE_Reference", []string{
		"tags: [String!]!",
		"uRI: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVE_ScoreVersion(0)))
	utils.Must(builder.AddType("CVSSV2", []string{
		"accessComplexity: CVSSV2_AccessComplexity!",
		"attackVector: CVSSV2_AttackVector!",
		"authentication: CVSSV2_Authentication!",
		"availability: CVSSV2_Impact!",
		"confidentiality: CVSSV2_Impact!",
		"exploitabilityScore: Float!",
		"impactScore: Float!",
		"integrity: CVSSV2_Impact!",
		"score: Float!",
		"severity: CVSSV2_Severity!",
		"vector: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV2_AccessComplexity(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV2_AttackVector(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV2_Authentication(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV2_Impact(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV2_Severity(0)))
	utils.Must(builder.AddType("CVSSV3", []string{
		"attackComplexity: CVSSV3_Complexity!",
		"attackVector: CVSSV3_AttackVector!",
		"availability: CVSSV3_Impact!",
		"confidentiality: CVSSV3_Impact!",
		"exploitabilityScore: Float!",
		"impactScore: Float!",
		"integrity: CVSSV3_Impact!",
		"privilegesRequired: CVSSV3_Privileges!",
		"scope: CVSSV3_Scope!",
		"score: Float!",
		"severity: CVSSV3_Severity!",
		"userInteraction: CVSSV3_UserInteraction!",
		"vector: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV3_AttackVector(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV3_Complexity(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV3_Impact(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV3_Privileges(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV3_Scope(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV3_Severity(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CVSSV3_UserInteraction(0)))
	utils.Must(builder.AddType("Cert", []string{
		"algorithm: String!",
		"endDate: Time",
		"issuer: CertName",
		"sans: [String!]!",
		"startDate: Time",
		"subject: CertName",
	}))
	utils.Must(builder.AddType("CertName", []string{
		"commonName: String!",
		"country: String!",
		"locality: String!",
		"names: [String!]!",
		"organization: String!",
		"organizationUnit: String!",
		"postalCode: String!",
		"province: String!",
		"streetAddress: String!",
	}))
	utils.Must(builder.AddType("Cluster", []string{
		"admissionController: Boolean!",
		"centralApiEndpoint: String!",
		"collectionMethod: CollectionMethod!",
		"collectorImage: String!",
		"dynamicConfig: DynamicClusterConfig",
		"id: ID!",
		"mainImage: String!",
		"monitoringEndpoint: String!",
		"name: String!",
		"priority: Int!",
		"runtimeSupport: Boolean!",
		"status: ClusterStatus",
		"tolerationsConfig: TolerationsConfig",
		"type: ClusterType!",
	}))
	utils.Must(builder.AddType("ClusterStatus", []string{
		"lastContact: Time",
		"orchestratorMetadata: OrchestratorMetadata",
		"providerMetadata: ProviderMetadata",
		"sensorVersion: String!",
		"upgradeStatus: ClusterUpgradeStatus",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.ClusterType(0)))
	utils.Must(builder.AddType("ClusterUpgradeStatus", []string{
		"mostRecentProcess: ClusterUpgradeStatus_UpgradeProcessStatus",
		"upgradability: ClusterUpgradeStatus_Upgradability!",
		"upgradabilityStatusReason: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.ClusterUpgradeStatus_Upgradability(0)))
	utils.Must(builder.AddType("ClusterUpgradeStatus_UpgradeProcessStatus", []string{
		"active: Boolean!",
		"id: ID!",
		"initiatedAt: Time",
		"progress: UpgradeProgress",
		"targetVersion: String!",
		"upgraderImage: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.CollectionMethod(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.Comparator(0)))
	utils.Must(builder.AddType("ComplianceAggregation_AggregationKey", []string{
		"id: ID!",
		"scope: ComplianceAggregation_Scope!",
	}))
	utils.Must(builder.AddType("ComplianceAggregation_Response", []string{
		"results: [ComplianceAggregation_Result]!",
		"sources: [ComplianceAggregation_Source]!",
	}))
	utils.Must(builder.AddType("ComplianceAggregation_Result", []string{
		"aggregationKeys: [ComplianceAggregation_AggregationKey]!",
		"numFailing: Int!",
		"numPassing: Int!",
		"unit: ComplianceAggregation_Scope!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(v1.ComplianceAggregation_Scope(0)))
	utils.Must(builder.AddType("ComplianceAggregation_Source", []string{
		"clusterId: String!",
		"failedRuns: [ComplianceRunMetadata]!",
		"standardId: String!",
		"successfulRun: ComplianceRunMetadata",
	}))
	utils.Must(builder.AddType("ComplianceControl", []string{
		"description: String!",
		"groupId: String!",
		"id: ID!",
		"implemented: Boolean!",
		"interpretationText: String!",
		"name: String!",
		"standardId: String!",
	}))
	utils.Must(builder.AddType("ComplianceControlGroup", []string{
		"description: String!",
		"id: ID!",
		"name: String!",
		"numImplementedChecks: Int!",
		"standardId: String!",
	}))
	utils.Must(builder.AddType("ComplianceControlResult", []string{
		"controlId: String!",
		"resource: ComplianceResource",
		"value: ComplianceResultValue",
	}))
	utils.Must(builder.AddType("ComplianceResource", []string{
		"resource: ComplianceResourceResource",
	}))
	utils.Must(builder.AddUnionType("ComplianceResourceResource", []string{
		"ComplianceResource_ClusterName",
		"ComplianceResource_DeploymentName",
		"ComplianceResource_NodeName",
		"ImageName",
	}))
	utils.Must(builder.AddType("ComplianceResource_ClusterName", []string{
		"id: ID!",
		"name: String!",
	}))
	utils.Must(builder.AddType("ComplianceResource_DeploymentName", []string{
		"cluster: ComplianceResource_ClusterName",
		"id: ID!",
		"name: String!",
		"namespace: String!",
	}))
	utils.Must(builder.AddType("ComplianceResource_NodeName", []string{
		"cluster: ComplianceResource_ClusterName",
		"id: ID!",
		"name: String!",
	}))
	utils.Must(builder.AddType("ComplianceResultValue", []string{
		"evidence: [ComplianceResultValue_Evidence]!",
		"overallState: ComplianceState!",
	}))
	utils.Must(builder.AddType("ComplianceResultValue_Evidence", []string{
		"message: String!",
		"messageId: Int!",
		"state: ComplianceState!",
	}))
	utils.Must(builder.AddType("ComplianceRun", []string{
		"clusterId: String!",
		"errorMessage: String!",
		"finishTime: Time",
		"id: ID!",
		"scheduleId: String!",
		"standardId: String!",
		"startTime: Time",
		"state: ComplianceRun_State!",
	}))
	utils.Must(builder.AddType("ComplianceRunMetadata", []string{
		"clusterId: String!",
		"errorMessage: String!",
		"finishTimestamp: Time",
		"runId: String!",
		"standardId: String!",
		"startTimestamp: Time",
		"success: Boolean!",
	}))
	utils.Must(builder.AddType("ComplianceRunSchedule", []string{
		"clusterId: String!",
		"crontabSpec: String!",
		"id: ID!",
		"standardId: String!",
		"suspended: Boolean!",
	}))
	utils.Must(builder.AddType("ComplianceRunScheduleInfo", []string{
		"lastCompletedRun: ComplianceRun",
		"lastRun: ComplianceRun",
		"nextRunTime: Time",
		"schedule: ComplianceRunSchedule",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(v1.ComplianceRun_State(0)))
	utils.Must(builder.AddType("ComplianceStandard", []string{
		"controls: [ComplianceControl]!",
		"groups: [ComplianceControlGroup]!",
		"metadata: ComplianceStandardMetadata",
	}))
	utils.Must(builder.AddType("ComplianceStandardMetadata", []string{
		"description: String!",
		"id: ID!",
		"name: String!",
		"numImplementedChecks: Int!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.ComplianceState(0)))
	utils.Must(builder.AddType("Component", []string{
		"name: String!",
		"version: String!",
	}))
	utils.Must(builder.AddType("Container", []string{
		"config: ContainerConfig",
		"id: ID!",
		"image: ContainerImage",
		"instances: [ContainerInstance]!",
		"name: String!",
		"ports: [PortConfig]!",
		"resources: Resources",
		"secrets: [EmbeddedSecret]!",
		"securityContext: SecurityContext",
		"volumes: [Volume]!",
	}))
	utils.Must(builder.AddType("ContainerConfig", []string{
		"args: [String!]!",
		"command: [String!]!",
		"directory: String!",
		"env: [ContainerConfig_EnvironmentConfig]!",
		"uid: Int!",
		"user: String!",
	}))
	utils.Must(builder.AddType("ContainerConfig_EnvironmentConfig", []string{
		"envVarSource: ContainerConfig_EnvironmentConfig_EnvVarSource!",
		"key: String!",
		"value: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.ContainerConfig_EnvironmentConfig_EnvVarSource(0)))
	utils.Must(builder.AddType("ContainerImage", []string{
		"id: ID!",
		"name: ImageName",
		"notPullable: Boolean!",
	}))
	utils.Must(builder.AddType("ContainerInstance", []string{
		"containerIps: [String!]!",
		"containingPodId: String!",
		"instanceId: ContainerInstanceID",
		"started: Time",
	}))
	utils.Must(builder.AddType("ContainerInstanceID", []string{
		"containerRuntime: ContainerRuntime!",
		"id: ID!",
		"node: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.ContainerRuntime(0)))
	utils.Must(builder.AddType("ContainerRuntimeInfo", []string{
		"type: ContainerRuntime!",
		"version: String!",
	}))
	utils.Must(builder.AddType("Deployment", []string{
		"annotations: [Label!]!",
		"automountServiceAccountToken: Boolean!",
		"clusterId: String!",
		"clusterName: String!",
		"containers: [Container]!",
		"created: Time",
		"hostNetwork: Boolean!",
		"id: ID!",
		"imagePullSecrets: [String!]!",
		"inactive: Boolean!",
		"labelSelector: LabelSelector",
		"labels: [Label!]!",
		"name: String!",
		"namespace: String!",
		"namespaceId: String!",
		"podLabels: [Label!]!",
		"ports: [PortConfig]!",
		"priority: Int!",
		"replicas: Int!",
		"serviceAccount: String!",
		"stateTimestamp: Int!",
		"tolerations: [Toleration]!",
		"type: String!",
	}))
	utils.Must(builder.AddType("DockerfileLineRuleField", []string{
		"instruction: String!",
		"value: String!",
	}))
	utils.Must(builder.AddType("DynamicClusterConfig", []string{
		"admissionControllerConfig: AdmissionControllerConfig",
		"registryOverride: String!",
	}))
	utils.Must(builder.AddType("Email", []string{
		"disableTLS: Boolean!",
		"from: String!",
		"password: String!",
		"sender: String!",
		"server: String!",
		"useSTARTTLS: Boolean!",
		"username: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.EmbeddedImageScanComponent_SourceType(0)))
	utils.Must(builder.AddType("EmbeddedSecret", []string{
		"name: String!",
		"path: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.EmbeddedVulnerability_ScoreVersion(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.EmbeddedVulnerability_VulnerabilityType(0)))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.EnforcementAction(0)))
	utils.Must(builder.AddType("GenerateTokenResponse", []string{
		"metadata: TokenMetadata",
		"token: String!",
	}))
	utils.Must(builder.AddType("Generic", []string{
		"auditLoggingEnabled: Boolean!",
		"caCert: String!",
		"endpoint: String!",
		"extraFields: [KeyValuePair]!",
		"headers: [KeyValuePair]!",
		"password: String!",
		"skipTLSVerify: Boolean!",
		"username: String!",
	}))
	utils.Must(builder.AddType("GetComplianceRunStatusesResponse", []string{
		"invalidRunIds: [String!]!",
		"runs: [ComplianceRun]!",
	}))
	utils.Must(builder.AddType("GoogleProviderMetadata", []string{
		"clusterName: String!",
		"project: String!",
	}))
	utils.Must(builder.AddType("Group", []string{
		"props: GroupProperties",
		"roleName: String!",
	}))
	utils.Must(builder.AddType("GroupProperties", []string{
		"authProviderId: String!",
		"key: String!",
		"value: String!",
	}))
	utils.Must(builder.AddType("HostMountPolicy", []string{
	}))
	utils.Must(builder.AddType("Image", []string{
		"id: ID!",
		"lastUpdated: Time",
		"metadata: ImageMetadata",
		"name: ImageName",
		"notPullable: Boolean!",
		"priority: Int!",
		"scan: ImageScan",
	}))
	utils.Must(builder.AddType("ImageComponent", []string{
		"id: ID!",
		"license: ImageComponent_License",
		"name: String!",
		"priority: Int!",
		"version: String!",
	}))
	utils.Must(builder.AddType("ImageComponent_License", []string{
		"name: String!",
		"type: String!",
		"url: String!",
	}))
	utils.Must(builder.AddType("ImageLayer", []string{
		"author: String!",
		"created: Time",
		"empty: Boolean!",
		"instruction: String!",
		"value: String!",
	}))
	utils.Must(builder.AddType("ImageMetadata", []string{
		"layerShas: [String!]!",
		"v1: V1Metadata",
		"v2: V2Metadata",
	}))
	utils.Must(builder.AddType("ImageName", []string{
		"fullName: String!",
		"registry: String!",
		"remote: String!",
		"tag: String!",
	}))
	utils.Must(builder.AddType("ImageNamePolicy", []string{
		"registry: String!",
		"remote: String!",
		"tag: String!",
	}))
	utils.Must(builder.AddType("ImagePullSecret", []string{
		"registries: [ImagePullSecret_Registry]!",
	}))
	utils.Must(builder.AddType("ImagePullSecret_Registry", []string{
		"name: String!",
		"username: String!",
	}))
	utils.Must(builder.AddType("ImageScan", []string{
		"scanTime: Time",
	}))
	utils.Must(builder.AddType("Jira", []string{
		"issueType: String!",
		"password: String!",
		"url: String!",
		"username: String!",
	}))
	utils.Must(builder.AddType("K8SRole", []string{
		"annotations: [Label!]!",
		"clusterId: String!",
		"clusterName: String!",
		"clusterRole: Boolean!",
		"createdAt: Time",
		"id: ID!",
		"labels: [Label!]!",
		"name: String!",
		"namespace: String!",
		"rules: [PolicyRule]!",
	}))
	utils.Must(builder.AddType("K8SRoleBinding", []string{
		"annotations: [Label!]!",
		"clusterId: String!",
		"clusterName: String!",
		"clusterRole: Boolean!",
		"createdAt: Time",
		"id: ID!",
		"labels: [Label!]!",
		"name: String!",
		"namespace: String!",
		"roleId: String!",
		"subjects: [Subject]!",
	}))
	utils.Must(builder.AddType("KeyValuePair", []string{
		"key: String!",
		"value: String!",
	}))
	utils.Must(builder.AddType("KeyValuePolicy", []string{
		"envVarSource: ContainerConfig_EnvironmentConfig_EnvVarSource!",
		"key: String!",
		"value: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.L4Protocol(0)))
	utils.Must(builder.AddType("LabelSelector", []string{
		"matchLabels: [Label!]!",
		"requirements: [LabelSelector_Requirement]!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.LabelSelector_Operator(0)))
	utils.Must(builder.AddType("LabelSelector_Requirement", []string{
		"key: String!",
		"op: LabelSelector_Operator!",
		"values: [String!]!",
	}))
	utils.Must(builder.AddType("License", []string{
		"name: String!",
		"type: String!",
		"url: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.LifecycleStage(0)))
	utils.Must(builder.AddType("Metadata", []string{
		"buildFlavor: String!",
		"licenseStatus: Metadata_LicenseStatus!",
		"releaseBuild: Boolean!",
		"version: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(v1.Metadata_LicenseStatus(0)))
	utils.Must(builder.AddType("Namespace", []string{
		"metadata: NamespaceMetadata",
		"numDeployments: Int!",
		"numNetworkPolicies: Int!",
		"numSecrets: Int!",
	}))
	utils.Must(builder.AddType("NamespaceMetadata", []string{
		"clusterId: String!",
		"clusterName: String!",
		"creationTime: Time",
		"id: ID!",
		"labels: [Label!]!",
		"name: String!",
		"priority: Int!",
	}))
	utils.Must(builder.AddType("NetworkEntityInfo", []string{
		"id: ID!",
		"type: NetworkEntityInfo_Type!",
		"desc: NetworkEntityInfoDesc",
	}))
	utils.Must(builder.AddUnionType("NetworkEntityInfoDesc", []string{
		"NetworkEntityInfo_Deployment",
	}))
	utils.Must(builder.AddType("NetworkEntityInfo_Deployment", []string{
		"cluster: String!",
		"name: String!",
		"namespace: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.NetworkEntityInfo_Type(0)))
	utils.Must(builder.AddType("NetworkFlow", []string{
		"lastSeenTimestamp: Time",
		"props: NetworkFlowProperties",
	}))
	utils.Must(builder.AddType("NetworkFlowProperties", []string{
		"dstEntity: NetworkEntityInfo",
		"dstPort: Int!",
		"l4Protocol: L4Protocol!",
		"srcEntity: NetworkEntityInfo",
	}))
	utils.Must(builder.AddType("Node", []string{
		"annotations: [Label!]!",
		"clusterId: String!",
		"clusterName: String!",
		"containerRuntime: ContainerRuntimeInfo",
		"containerRuntimeVersion: String!",
		"externalIpAddresses: [String!]!",
		"id: ID!",
		"internalIpAddresses: [String!]!",
		"joinedAt: Time",
		"kernelVersion: String!",
		"kubeletVersion: String!",
		"labels: [Label!]!",
		"name: String!",
		"osImage: String!",
		"taints: [Taint]!",
	}))
	utils.Must(builder.AddType("Notifier", []string{
		"enabled: Boolean!",
		"id: ID!",
		"labelDefault: String!",
		"labelKey: String!",
		"name: String!",
		"type: String!",
		"uiEndpoint: String!",
		"config: NotifierConfig",
	}))
	utils.Must(builder.AddUnionType("NotifierConfig", []string{
		"Jira",
		"Email",
		"CSCC",
		"Splunk",
		"PagerDuty",
		"Generic",
		"SumoLogic",
	}))
	utils.Must(builder.AddType("NumericalPolicy", []string{
		"op: Comparator!",
		"value: Float!",
	}))
	utils.Must(builder.AddType("OrchestratorMetadata", []string{
		"apiVersions: [String!]!",
		"buildDate: Time",
		"version: String!",
	}))
	utils.Must(builder.AddType("PagerDuty", []string{
		"apiKey: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.PermissionLevel(0)))
	utils.Must(builder.AddType("PermissionPolicy", []string{
		"permissionLevel: PermissionLevel!",
	}))
	utils.Must(builder.AddType("Policy", []string{
		"categories: [String!]!",
		"description: String!",
		"disabled: Boolean!",
		"enforcementActions: [EnforcementAction!]!",
		"fields: PolicyFields",
		"id: ID!",
		"lastUpdated: Time",
		"lifecycleStages: [LifecycleStage!]!",
		"name: String!",
		"notifiers: [String!]!",
		"rationale: String!",
		"remediation: String!",
		"scope: [Scope]!",
		"severity: Severity!",
		"whitelists: [Whitelist]!",
	}))
	utils.Must(builder.AddType("PolicyFields", []string{
		"addCapabilities: [String!]!",
		"args: String!",
		"command: String!",
		"component: Component",
		"containerResourcePolicy: ResourcePolicy",
		"cve: String!",
		"cvss: NumericalPolicy",
		"directory: String!",
		"disallowedAnnotation: KeyValuePolicy",
		"dropCapabilities: [String!]!",
		"env: KeyValuePolicy",
		"fixedBy: String!",
		"hostMountPolicy: HostMountPolicy",
		"imageName: ImageNamePolicy",
		"lineRule: DockerfileLineRuleField",
		"permissionPolicy: PermissionPolicy",
		"portExposurePolicy: PortExposurePolicy",
		"portPolicy: PortPolicy",
		"processPolicy: ProcessPolicy",
		"requiredAnnotation: KeyValuePolicy",
		"requiredLabel: KeyValuePolicy",
		"user: String!",
		"volumePolicy: VolumePolicy",
	}))
	utils.Must(builder.AddType("PolicyRule", []string{
		"apiGroups: [String!]!",
		"nonResourceUrls: [String!]!",
		"resourceNames: [String!]!",
		"resources: [String!]!",
		"verbs: [String!]!",
	}))
	utils.Must(builder.AddType("PortConfig", []string{
		"containerPort: Int!",
		"exposedPort: Int!",
		"exposure: PortConfig_ExposureLevel!",
		"exposureInfos: [PortConfig_ExposureInfo]!",
		"name: String!",
		"protocol: String!",
	}))
	utils.Must(builder.AddType("PortConfig_ExposureInfo", []string{
		"externalHostnames: [String!]!",
		"externalIps: [String!]!",
		"level: PortConfig_ExposureLevel!",
		"nodePort: Int!",
		"serviceClusterIp: String!",
		"serviceId: String!",
		"serviceName: String!",
		"servicePort: Int!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.PortConfig_ExposureLevel(0)))
	utils.Must(builder.AddType("PortExposurePolicy", []string{
		"exposureLevels: [PortConfig_ExposureLevel!]!",
	}))
	utils.Must(builder.AddType("PortPolicy", []string{
		"port: Int!",
		"protocol: String!",
	}))
	utils.Must(builder.AddType("ProcessGroup", []string{
		"args: String!",
		"signals: [ProcessIndicator]!",
	}))
	utils.Must(builder.AddType("ProcessIndicator", []string{
		"clusterId: String!",
		"containerName: String!",
		"containerStartTime: Time",
		"deploymentId: String!",
		"deploymentStateTs: Int!",
		"id: ID!",
		"namespace: String!",
		"podId: String!",
		"signal: ProcessSignal",
	}))
	utils.Must(builder.AddType("ProcessNameGroup", []string{
		"groups: [ProcessGroup]!",
		"name: String!",
		"timesExecuted: Int!",
	}))
	utils.Must(builder.AddType("ProcessPolicy", []string{
		"ancestor: String!",
		"args: String!",
		"name: String!",
		"uid: String!",
	}))
	utils.Must(builder.AddType("ProcessSignal", []string{
		"args: String!",
		"containerId: String!",
		"execFilePath: String!",
		"gid: Int!",
		"id: ID!",
		"lineage: [String!]!",
		"name: String!",
		"pid: Int!",
		"time: Time",
		"uid: Int!",
	}))
	utils.Must(builder.AddType("ProviderMetadata", []string{
		"region: String!",
		"verified: Boolean!",
		"zone: String!",
		"provider: ProviderMetadataProvider",
	}))
	utils.Must(builder.AddUnionType("ProviderMetadataProvider", []string{
		"GoogleProviderMetadata",
		"AWSProviderMetadata",
		"AzureProviderMetadata",
	}))
	utils.Must(builder.AddType("ResourcePolicy", []string{
		"cpuResourceLimit: NumericalPolicy",
		"cpuResourceRequest: NumericalPolicy",
		"memoryResourceLimit: NumericalPolicy",
		"memoryResourceRequest: NumericalPolicy",
	}))
	utils.Must(builder.AddType("Resources", []string{
		"cpuCoresLimit: Float!",
		"cpuCoresRequest: Float!",
		"memoryMbLimit: Float!",
		"memoryMbRequest: Float!",
	}))
	utils.Must(builder.AddType("Risk", []string{
		"id: ID!",
		"results: [Risk_Result]!",
		"score: Float!",
		"subject: RiskSubject",
	}))
	utils.Must(builder.AddType("RiskSubject", []string{
		"clusterId: String!",
		"id: ID!",
		"namespace: String!",
		"type: RiskSubjectType!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.RiskSubjectType(0)))
	utils.Must(builder.AddType("Risk_Result", []string{
		"factors: [Risk_Result_Factor]!",
		"name: String!",
		"score: Float!",
	}))
	utils.Must(builder.AddType("Risk_Result_Factor", []string{
		"message: String!",
		"url: String!",
	}))
	utils.Must(builder.AddType("Role", []string{
		"globalAccess: Access!",
		"name: String!",
	}))
	utils.Must(builder.AddType("Scope", []string{
		"cluster: String!",
		"label: Scope_Label",
		"namespace: String!",
	}))
	utils.Must(builder.AddType("Scope_Label", []string{
		"key: String!",
		"value: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(v1.SearchCategory(0)))
	utils.Must(builder.AddType("SearchResult", []string{
		"category: SearchCategory!",
		"id: ID!",
		"location: String!",
		"name: String!",
		"score: Float!",
	}))
	utils.Must(builder.AddType("Secret", []string{
		"annotations: [Label!]!",
		"clusterId: String!",
		"clusterName: String!",
		"createdAt: Time",
		"files: [SecretDataFile]!",
		"id: ID!",
		"labels: [Label!]!",
		"name: String!",
		"namespace: String!",
		"relationship: SecretRelationship",
		"type: String!",
	}))
	utils.Must(builder.AddType("SecretContainerRelationship", []string{
		"id: ID!",
		"path: String!",
	}))
	utils.Must(builder.AddType("SecretDataFile", []string{
		"name: String!",
		"type: SecretType!",
		"metadata: SecretDataFileMetadata",
	}))
	utils.Must(builder.AddUnionType("SecretDataFileMetadata", []string{
		"Cert",
		"ImagePullSecret",
	}))
	utils.Must(builder.AddType("SecretDeploymentRelationship", []string{
		"id: ID!",
		"name: String!",
	}))
	utils.Must(builder.AddType("SecretRelationship", []string{
		"containerRelationships: [SecretContainerRelationship]!",
		"deploymentRelationships: [SecretDeploymentRelationship]!",
		"id: ID!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.SecretType(0)))
	utils.Must(builder.AddType("SecurityContext", []string{
		"addCapabilities: [String!]!",
		"dropCapabilities: [String!]!",
		"privileged: Boolean!",
		"readOnlyRootFilesystem: Boolean!",
		"selinux: SecurityContext_SELinux",
	}))
	utils.Must(builder.AddType("SecurityContext_SELinux", []string{
		"level: String!",
		"role: String!",
		"type: String!",
		"user: String!",
	}))
	utils.Must(builder.AddType("ServiceAccount", []string{
		"annotations: [Label!]!",
		"automountToken: Boolean!",
		"clusterId: String!",
		"clusterName: String!",
		"createdAt: Time",
		"id: ID!",
		"imagePullSecrets: [String!]!",
		"labels: [Label!]!",
		"name: String!",
		"namespace: String!",
		"secrets: [String!]!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.Severity(0)))
	utils.Must(builder.AddType("Splunk", []string{
		"auditLoggingEnabled: Boolean!",
		"httpEndpoint: String!",
		"httpToken: String!",
		"insecure: Boolean!",
		"truncate: Int!",
	}))
	utils.Must(builder.AddType("Subject", []string{
		"kind: SubjectKind!",
		"name: String!",
		"namespace: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.SubjectKind(0)))
	utils.Must(builder.AddType("SumoLogic", []string{
		"httpSourceAddress: String!",
		"skipTLSVerify: Boolean!",
	}))
	utils.Must(builder.AddType("Taint", []string{
		"key: String!",
		"taintEffect: TaintEffect!",
		"value: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.TaintEffect(0)))
	utils.Must(builder.AddType("TokenMetadata", []string{
		"expiration: Time",
		"id: ID!",
		"issuedAt: Time",
		"name: String!",
		"revoked: Boolean!",
		"role: String!",
	}))
	utils.Must(builder.AddType("Toleration", []string{
		"key: String!",
		"operator: Toleration_Operator!",
		"taintEffect: TaintEffect!",
		"value: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.Toleration_Operator(0)))
	utils.Must(builder.AddType("TolerationsConfig", []string{
		"disabled: Boolean!",
	}))
	utils.Must(builder.AddType("UpgradeProgress", []string{
		"since: Time",
		"upgradeState: UpgradeProgress_UpgradeState!",
		"upgradeStatusDetail: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.UpgradeProgress_UpgradeState(0)))
	utils.Must(builder.AddType("V1Metadata", []string{
		"author: String!",
		"command: [String!]!",
		"created: Time",
		"digest: String!",
		"entrypoint: [String!]!",
		"layers: [ImageLayer]!",
		"user: String!",
		"volumes: [String!]!",
	}))
	utils.Must(builder.AddType("V2Metadata", []string{
		"digest: String!",
	}))
	generator.RegisterProtoEnum(builder, reflect.TypeOf(storage.ViolationState(0)))
	utils.Must(builder.AddType("Volume", []string{
		"destination: String!",
		"name: String!",
		"readOnly: Boolean!",
		"source: String!",
		"type: String!",
	}))
	utils.Must(builder.AddType("VolumePolicy", []string{
		"destination: String!",
		"name: String!",
		"source: String!",
		"type: String!",
	}))
	utils.Must(builder.AddType("Whitelist", []string{
		"deployment: Whitelist_Deployment",
		"expiration: Time",
		"image: Whitelist_Image",
		"name: String!",
	}))
	utils.Must(builder.AddType("Whitelist_Deployment", []string{
		"name: String!",
		"scope: Scope",
	}))
	utils.Must(builder.AddType("Whitelist_Image", []string{
		"name: String!",
	}))
}

type aWSProviderMetadataResolver struct {
	root *Resolver
	data *storage.AWSProviderMetadata
}

func (resolver *Resolver) wrapAWSProviderMetadata(value *storage.AWSProviderMetadata, ok bool, err error) (*aWSProviderMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &aWSProviderMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapAWSProviderMetadatas(values []*storage.AWSProviderMetadata, err error) ([]*aWSProviderMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*aWSProviderMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &aWSProviderMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *aWSProviderMetadataResolver) AccountId(ctx context.Context) string {
	value := resolver.data.GetAccountId()
	return value
}

func toAccess(value *string) storage.Access {
	if value != nil {
		return storage.Access(storage.Access_value[*value])
	}
	return storage.Access(0)
}

func toAccesses(values *[]string) []storage.Access {
	if values == nil {
		return nil
	}
	output := make([]storage.Access, len(*values))
	for i, v := range *values {
		output[i] = toAccess(&v)
	}
	return output
}

type admissionControllerConfigResolver struct {
	root *Resolver
	data *storage.AdmissionControllerConfig
}

func (resolver *Resolver) wrapAdmissionControllerConfig(value *storage.AdmissionControllerConfig, ok bool, err error) (*admissionControllerConfigResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &admissionControllerConfigResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapAdmissionControllerConfigs(values []*storage.AdmissionControllerConfig, err error) ([]*admissionControllerConfigResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*admissionControllerConfigResolver, len(values))
	for i, v := range values {
		output[i] = &admissionControllerConfigResolver{resolver, v}
	}
	return output, nil
}

func (resolver *admissionControllerConfigResolver) DisableBypass(ctx context.Context) bool {
	value := resolver.data.GetDisableBypass()
	return value
}

func (resolver *admissionControllerConfigResolver) Enabled(ctx context.Context) bool {
	value := resolver.data.GetEnabled()
	return value
}

func (resolver *admissionControllerConfigResolver) ScanInline(ctx context.Context) bool {
	value := resolver.data.GetScanInline()
	return value
}

func (resolver *admissionControllerConfigResolver) TimeoutSeconds(ctx context.Context) int32 {
	value := resolver.data.GetTimeoutSeconds()
	return value
}

type alertResolver struct {
	root *Resolver
	data *storage.Alert
	list *storage.ListAlert
}

func (resolver *Resolver) wrapAlert(value *storage.Alert, ok bool, err error) (*alertResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &alertResolver{resolver, value, nil}, nil
}

func (resolver *Resolver) wrapAlerts(values []*storage.Alert, err error) ([]*alertResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*alertResolver, len(values))
	for i, v := range values {
		output[i] = &alertResolver{resolver, v, nil}
	}
	return output, nil
}

func (resolver *Resolver) wrapListAlerts(values []*storage.ListAlert, err error) ([]*alertResolver, error) {
	if err != nil || values == nil {
		return nil, err
	}
	output := make([]*alertResolver, len(values))
	for i, v := range values {
		output[i] = &alertResolver{resolver, nil, v}
	}
	return output, nil
}

func (resolver *alertResolver) ensureData(ctx context.Context) {
	if resolver.data == nil {
		resolver.data = resolver.root.getAlert(ctx, resolver.list.GetId())
	}
}

func (resolver *alertResolver) Deployment(ctx context.Context) (*alert_DeploymentResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetDeployment()
	return resolver.root.wrapAlert_Deployment(value, true, nil)
}

func (resolver *alertResolver) Enforcement(ctx context.Context) (*alert_EnforcementResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetEnforcement()
	return resolver.root.wrapAlert_Enforcement(value, true, nil)
}

func (resolver *alertResolver) FirstOccurred(ctx context.Context) (*graphql.Time, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetFirstOccurred()
	return timestamp(value)
}

func (resolver *alertResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	if resolver.data == nil {
		value = resolver.list.GetId()
	}
	return graphql.ID(value)
}

func (resolver *alertResolver) LifecycleStage(ctx context.Context) string {
	value := resolver.data.GetLifecycleStage()
	if resolver.data == nil {
		value = resolver.list.GetLifecycleStage()
	}
	return value.String()
}

func (resolver *alertResolver) Policy(ctx context.Context) (*policyResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetPolicy()
	return resolver.root.wrapPolicy(value, true, nil)
}

func (resolver *alertResolver) ProcessViolation(ctx context.Context) (*alert_ProcessViolationResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetProcessViolation()
	return resolver.root.wrapAlert_ProcessViolation(value, true, nil)
}

func (resolver *alertResolver) SnoozeTill(ctx context.Context) (*graphql.Time, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetSnoozeTill()
	return timestamp(value)
}

func (resolver *alertResolver) State(ctx context.Context) string {
	value := resolver.data.GetState()
	if resolver.data == nil {
		value = resolver.list.GetState()
	}
	return value.String()
}

func (resolver *alertResolver) Time(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetTime()
	if resolver.data == nil {
		value = resolver.list.GetTime()
	}
	return timestamp(value)
}

func (resolver *alertResolver) Violations(ctx context.Context) ([]*alert_ViolationResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetViolations()
	return resolver.root.wrapAlert_Violations(value, nil)
}

type alert_DeploymentResolver struct {
	root *Resolver
	data *storage.Alert_Deployment
}

func (resolver *Resolver) wrapAlert_Deployment(value *storage.Alert_Deployment, ok bool, err error) (*alert_DeploymentResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &alert_DeploymentResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapAlert_Deployments(values []*storage.Alert_Deployment, err error) ([]*alert_DeploymentResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*alert_DeploymentResolver, len(values))
	for i, v := range values {
		output[i] = &alert_DeploymentResolver{resolver, v}
	}
	return output, nil
}

func (resolver *alert_DeploymentResolver) Annotations(ctx context.Context) labels {
	value := resolver.data.GetAnnotations()
	return labelsResolver(value)
}

func (resolver *alert_DeploymentResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *alert_DeploymentResolver) ClusterName(ctx context.Context) string {
	value := resolver.data.GetClusterName()
	return value
}

func (resolver *alert_DeploymentResolver) Containers(ctx context.Context) ([]*alert_Deployment_ContainerResolver, error) {
	value := resolver.data.GetContainers()
	return resolver.root.wrapAlert_Deployment_Containers(value, nil)
}

func (resolver *alert_DeploymentResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *alert_DeploymentResolver) Inactive(ctx context.Context) bool {
	value := resolver.data.GetInactive()
	return value
}

func (resolver *alert_DeploymentResolver) Labels(ctx context.Context) labels {
	value := resolver.data.GetLabels()
	return labelsResolver(value)
}

func (resolver *alert_DeploymentResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *alert_DeploymentResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	return value
}

func (resolver *alert_DeploymentResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value
}

type alert_Deployment_ContainerResolver struct {
	root *Resolver
	data *storage.Alert_Deployment_Container
}

func (resolver *Resolver) wrapAlert_Deployment_Container(value *storage.Alert_Deployment_Container, ok bool, err error) (*alert_Deployment_ContainerResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &alert_Deployment_ContainerResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapAlert_Deployment_Containers(values []*storage.Alert_Deployment_Container, err error) ([]*alert_Deployment_ContainerResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*alert_Deployment_ContainerResolver, len(values))
	for i, v := range values {
		output[i] = &alert_Deployment_ContainerResolver{resolver, v}
	}
	return output, nil
}

func (resolver *alert_Deployment_ContainerResolver) Image(ctx context.Context) (*containerImageResolver, error) {
	value := resolver.data.GetImage()
	return resolver.root.wrapContainerImage(value, true, nil)
}

func (resolver *alert_Deployment_ContainerResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

type alert_EnforcementResolver struct {
	root *Resolver
	data *storage.Alert_Enforcement
}

func (resolver *Resolver) wrapAlert_Enforcement(value *storage.Alert_Enforcement, ok bool, err error) (*alert_EnforcementResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &alert_EnforcementResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapAlert_Enforcements(values []*storage.Alert_Enforcement, err error) ([]*alert_EnforcementResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*alert_EnforcementResolver, len(values))
	for i, v := range values {
		output[i] = &alert_EnforcementResolver{resolver, v}
	}
	return output, nil
}

func (resolver *alert_EnforcementResolver) Action(ctx context.Context) string {
	value := resolver.data.GetAction()
	return value.String()
}

func (resolver *alert_EnforcementResolver) Message(ctx context.Context) string {
	value := resolver.data.GetMessage()
	return value
}

type alert_ProcessViolationResolver struct {
	root *Resolver
	data *storage.Alert_ProcessViolation
}

func (resolver *Resolver) wrapAlert_ProcessViolation(value *storage.Alert_ProcessViolation, ok bool, err error) (*alert_ProcessViolationResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &alert_ProcessViolationResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapAlert_ProcessViolations(values []*storage.Alert_ProcessViolation, err error) ([]*alert_ProcessViolationResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*alert_ProcessViolationResolver, len(values))
	for i, v := range values {
		output[i] = &alert_ProcessViolationResolver{resolver, v}
	}
	return output, nil
}

func (resolver *alert_ProcessViolationResolver) Message(ctx context.Context) string {
	value := resolver.data.GetMessage()
	return value
}

func (resolver *alert_ProcessViolationResolver) Processes(ctx context.Context) ([]*processIndicatorResolver, error) {
	value := resolver.data.GetProcesses()
	return resolver.root.wrapProcessIndicators(value, nil)
}

type alert_ViolationResolver struct {
	root *Resolver
	data *storage.Alert_Violation
}

func (resolver *Resolver) wrapAlert_Violation(value *storage.Alert_Violation, ok bool, err error) (*alert_ViolationResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &alert_ViolationResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapAlert_Violations(values []*storage.Alert_Violation, err error) ([]*alert_ViolationResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*alert_ViolationResolver, len(values))
	for i, v := range values {
		output[i] = &alert_ViolationResolver{resolver, v}
	}
	return output, nil
}

func (resolver *alert_ViolationResolver) Message(ctx context.Context) string {
	value := resolver.data.GetMessage()
	return value
}

type azureProviderMetadataResolver struct {
	root *Resolver
	data *storage.AzureProviderMetadata
}

func (resolver *Resolver) wrapAzureProviderMetadata(value *storage.AzureProviderMetadata, ok bool, err error) (*azureProviderMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &azureProviderMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapAzureProviderMetadatas(values []*storage.AzureProviderMetadata, err error) ([]*azureProviderMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*azureProviderMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &azureProviderMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *azureProviderMetadataResolver) SubscriptionId(ctx context.Context) string {
	value := resolver.data.GetSubscriptionId()
	return value
}

type cSCCResolver struct {
	root *Resolver
	data *storage.CSCC
}

func (resolver *Resolver) wrapCSCC(value *storage.CSCC, ok bool, err error) (*cSCCResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &cSCCResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCSCCs(values []*storage.CSCC, err error) ([]*cSCCResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*cSCCResolver, len(values))
	for i, v := range values {
		output[i] = &cSCCResolver{resolver, v}
	}
	return output, nil
}

func (resolver *cSCCResolver) ServiceAccount(ctx context.Context) string {
	value := resolver.data.GetServiceAccount()
	return value
}

func (resolver *cSCCResolver) SourceId(ctx context.Context) string {
	value := resolver.data.GetSourceId()
	return value
}

type cVEResolver struct {
	root *Resolver
	data *storage.CVE
}

func (resolver *Resolver) wrapCVE(value *storage.CVE, ok bool, err error) (*cVEResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &cVEResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCVEs(values []*storage.CVE, err error) ([]*cVEResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*cVEResolver, len(values))
	for i, v := range values {
		output[i] = &cVEResolver{resolver, v}
	}
	return output, nil
}

func (resolver *cVEResolver) Cvss(ctx context.Context) float64 {
	value := resolver.data.GetCvss()
	return float64(value)
}

func (resolver *cVEResolver) CvssV2(ctx context.Context) (*cVSSV2Resolver, error) {
	value := resolver.data.GetCvssV2()
	return resolver.root.wrapCVSSV2(value, true, nil)
}

func (resolver *cVEResolver) CvssV3(ctx context.Context) (*cVSSV3Resolver, error) {
	value := resolver.data.GetCvssV3()
	return resolver.root.wrapCVSSV3(value, true, nil)
}

func (resolver *cVEResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *cVEResolver) LastModified(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetLastModified()
	return timestamp(value)
}

func (resolver *cVEResolver) Link(ctx context.Context) string {
	value := resolver.data.GetLink()
	return value
}

func (resolver *cVEResolver) PublishedOn(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetPublishedOn()
	return timestamp(value)
}

func (resolver *cVEResolver) References(ctx context.Context) ([]*cVE_ReferenceResolver, error) {
	value := resolver.data.GetReferences()
	return resolver.root.wrapCVE_References(value, nil)
}

func (resolver *cVEResolver) ScoreVersion(ctx context.Context) string {
	value := resolver.data.GetScoreVersion()
	return value.String()
}

func (resolver *cVEResolver) Summary(ctx context.Context) string {
	value := resolver.data.GetSummary()
	return value
}

func (resolver *cVEResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value.String()
}

func toCVE_CVEType(value *string) storage.CVE_CVEType {
	if value != nil {
		return storage.CVE_CVEType(storage.CVE_CVEType_value[*value])
	}
	return storage.CVE_CVEType(0)
}

func toCVE_CVETypes(values *[]string) []storage.CVE_CVEType {
	if values == nil {
		return nil
	}
	output := make([]storage.CVE_CVEType, len(*values))
	for i, v := range *values {
		output[i] = toCVE_CVEType(&v)
	}
	return output
}

type cVE_ReferenceResolver struct {
	root *Resolver
	data *storage.CVE_Reference
}

func (resolver *Resolver) wrapCVE_Reference(value *storage.CVE_Reference, ok bool, err error) (*cVE_ReferenceResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &cVE_ReferenceResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCVE_References(values []*storage.CVE_Reference, err error) ([]*cVE_ReferenceResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*cVE_ReferenceResolver, len(values))
	for i, v := range values {
		output[i] = &cVE_ReferenceResolver{resolver, v}
	}
	return output, nil
}

func (resolver *cVE_ReferenceResolver) Tags(ctx context.Context) []string {
	value := resolver.data.GetTags()
	return value
}

func (resolver *cVE_ReferenceResolver) URI(ctx context.Context) string {
	value := resolver.data.GetURI()
	return value
}

func toCVE_ScoreVersion(value *string) storage.CVE_ScoreVersion {
	if value != nil {
		return storage.CVE_ScoreVersion(storage.CVE_ScoreVersion_value[*value])
	}
	return storage.CVE_ScoreVersion(0)
}

func toCVE_ScoreVersions(values *[]string) []storage.CVE_ScoreVersion {
	if values == nil {
		return nil
	}
	output := make([]storage.CVE_ScoreVersion, len(*values))
	for i, v := range *values {
		output[i] = toCVE_ScoreVersion(&v)
	}
	return output
}

type cVSSV2Resolver struct {
	root *Resolver
	data *storage.CVSSV2
}

func (resolver *Resolver) wrapCVSSV2(value *storage.CVSSV2, ok bool, err error) (*cVSSV2Resolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &cVSSV2Resolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCVSSV2s(values []*storage.CVSSV2, err error) ([]*cVSSV2Resolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*cVSSV2Resolver, len(values))
	for i, v := range values {
		output[i] = &cVSSV2Resolver{resolver, v}
	}
	return output, nil
}

func (resolver *cVSSV2Resolver) AccessComplexity(ctx context.Context) string {
	value := resolver.data.GetAccessComplexity()
	return value.String()
}

func (resolver *cVSSV2Resolver) AttackVector(ctx context.Context) string {
	value := resolver.data.GetAttackVector()
	return value.String()
}

func (resolver *cVSSV2Resolver) Authentication(ctx context.Context) string {
	value := resolver.data.GetAuthentication()
	return value.String()
}

func (resolver *cVSSV2Resolver) Availability(ctx context.Context) string {
	value := resolver.data.GetAvailability()
	return value.String()
}

func (resolver *cVSSV2Resolver) Confidentiality(ctx context.Context) string {
	value := resolver.data.GetConfidentiality()
	return value.String()
}

func (resolver *cVSSV2Resolver) ExploitabilityScore(ctx context.Context) float64 {
	value := resolver.data.GetExploitabilityScore()
	return float64(value)
}

func (resolver *cVSSV2Resolver) ImpactScore(ctx context.Context) float64 {
	value := resolver.data.GetImpactScore()
	return float64(value)
}

func (resolver *cVSSV2Resolver) Integrity(ctx context.Context) string {
	value := resolver.data.GetIntegrity()
	return value.String()
}

func (resolver *cVSSV2Resolver) Score(ctx context.Context) float64 {
	value := resolver.data.GetScore()
	return float64(value)
}

func (resolver *cVSSV2Resolver) Severity(ctx context.Context) string {
	value := resolver.data.GetSeverity()
	return value.String()
}

func (resolver *cVSSV2Resolver) Vector(ctx context.Context) string {
	value := resolver.data.GetVector()
	return value
}

func toCVSSV2_AccessComplexity(value *string) storage.CVSSV2_AccessComplexity {
	if value != nil {
		return storage.CVSSV2_AccessComplexity(storage.CVSSV2_AccessComplexity_value[*value])
	}
	return storage.CVSSV2_AccessComplexity(0)
}

func toCVSSV2_AccessComplexities(values *[]string) []storage.CVSSV2_AccessComplexity {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV2_AccessComplexity, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV2_AccessComplexity(&v)
	}
	return output
}

func toCVSSV2_AttackVector(value *string) storage.CVSSV2_AttackVector {
	if value != nil {
		return storage.CVSSV2_AttackVector(storage.CVSSV2_AttackVector_value[*value])
	}
	return storage.CVSSV2_AttackVector(0)
}

func toCVSSV2_AttackVectors(values *[]string) []storage.CVSSV2_AttackVector {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV2_AttackVector, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV2_AttackVector(&v)
	}
	return output
}

func toCVSSV2_Authentication(value *string) storage.CVSSV2_Authentication {
	if value != nil {
		return storage.CVSSV2_Authentication(storage.CVSSV2_Authentication_value[*value])
	}
	return storage.CVSSV2_Authentication(0)
}

func toCVSSV2_Authentications(values *[]string) []storage.CVSSV2_Authentication {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV2_Authentication, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV2_Authentication(&v)
	}
	return output
}

func toCVSSV2_Impact(value *string) storage.CVSSV2_Impact {
	if value != nil {
		return storage.CVSSV2_Impact(storage.CVSSV2_Impact_value[*value])
	}
	return storage.CVSSV2_Impact(0)
}

func toCVSSV2_Impacts(values *[]string) []storage.CVSSV2_Impact {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV2_Impact, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV2_Impact(&v)
	}
	return output
}

func toCVSSV2_Severity(value *string) storage.CVSSV2_Severity {
	if value != nil {
		return storage.CVSSV2_Severity(storage.CVSSV2_Severity_value[*value])
	}
	return storage.CVSSV2_Severity(0)
}

func toCVSSV2_Severities(values *[]string) []storage.CVSSV2_Severity {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV2_Severity, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV2_Severity(&v)
	}
	return output
}

type cVSSV3Resolver struct {
	root *Resolver
	data *storage.CVSSV3
}

func (resolver *Resolver) wrapCVSSV3(value *storage.CVSSV3, ok bool, err error) (*cVSSV3Resolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &cVSSV3Resolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCVSSV3s(values []*storage.CVSSV3, err error) ([]*cVSSV3Resolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*cVSSV3Resolver, len(values))
	for i, v := range values {
		output[i] = &cVSSV3Resolver{resolver, v}
	}
	return output, nil
}

func (resolver *cVSSV3Resolver) AttackComplexity(ctx context.Context) string {
	value := resolver.data.GetAttackComplexity()
	return value.String()
}

func (resolver *cVSSV3Resolver) AttackVector(ctx context.Context) string {
	value := resolver.data.GetAttackVector()
	return value.String()
}

func (resolver *cVSSV3Resolver) Availability(ctx context.Context) string {
	value := resolver.data.GetAvailability()
	return value.String()
}

func (resolver *cVSSV3Resolver) Confidentiality(ctx context.Context) string {
	value := resolver.data.GetConfidentiality()
	return value.String()
}

func (resolver *cVSSV3Resolver) ExploitabilityScore(ctx context.Context) float64 {
	value := resolver.data.GetExploitabilityScore()
	return float64(value)
}

func (resolver *cVSSV3Resolver) ImpactScore(ctx context.Context) float64 {
	value := resolver.data.GetImpactScore()
	return float64(value)
}

func (resolver *cVSSV3Resolver) Integrity(ctx context.Context) string {
	value := resolver.data.GetIntegrity()
	return value.String()
}

func (resolver *cVSSV3Resolver) PrivilegesRequired(ctx context.Context) string {
	value := resolver.data.GetPrivilegesRequired()
	return value.String()
}

func (resolver *cVSSV3Resolver) Scope(ctx context.Context) string {
	value := resolver.data.GetScope()
	return value.String()
}

func (resolver *cVSSV3Resolver) Score(ctx context.Context) float64 {
	value := resolver.data.GetScore()
	return float64(value)
}

func (resolver *cVSSV3Resolver) Severity(ctx context.Context) string {
	value := resolver.data.GetSeverity()
	return value.String()
}

func (resolver *cVSSV3Resolver) UserInteraction(ctx context.Context) string {
	value := resolver.data.GetUserInteraction()
	return value.String()
}

func (resolver *cVSSV3Resolver) Vector(ctx context.Context) string {
	value := resolver.data.GetVector()
	return value
}

func toCVSSV3_AttackVector(value *string) storage.CVSSV3_AttackVector {
	if value != nil {
		return storage.CVSSV3_AttackVector(storage.CVSSV3_AttackVector_value[*value])
	}
	return storage.CVSSV3_AttackVector(0)
}

func toCVSSV3_AttackVectors(values *[]string) []storage.CVSSV3_AttackVector {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV3_AttackVector, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV3_AttackVector(&v)
	}
	return output
}

func toCVSSV3_Complexity(value *string) storage.CVSSV3_Complexity {
	if value != nil {
		return storage.CVSSV3_Complexity(storage.CVSSV3_Complexity_value[*value])
	}
	return storage.CVSSV3_Complexity(0)
}

func toCVSSV3_Complexities(values *[]string) []storage.CVSSV3_Complexity {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV3_Complexity, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV3_Complexity(&v)
	}
	return output
}

func toCVSSV3_Impact(value *string) storage.CVSSV3_Impact {
	if value != nil {
		return storage.CVSSV3_Impact(storage.CVSSV3_Impact_value[*value])
	}
	return storage.CVSSV3_Impact(0)
}

func toCVSSV3_Impacts(values *[]string) []storage.CVSSV3_Impact {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV3_Impact, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV3_Impact(&v)
	}
	return output
}

func toCVSSV3_Privileges(value *string) storage.CVSSV3_Privileges {
	if value != nil {
		return storage.CVSSV3_Privileges(storage.CVSSV3_Privileges_value[*value])
	}
	return storage.CVSSV3_Privileges(0)
}

func toCVSSV3_Privilegeses(values *[]string) []storage.CVSSV3_Privileges {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV3_Privileges, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV3_Privileges(&v)
	}
	return output
}

func toCVSSV3_Scope(value *string) storage.CVSSV3_Scope {
	if value != nil {
		return storage.CVSSV3_Scope(storage.CVSSV3_Scope_value[*value])
	}
	return storage.CVSSV3_Scope(0)
}

func toCVSSV3_Scopes(values *[]string) []storage.CVSSV3_Scope {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV3_Scope, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV3_Scope(&v)
	}
	return output
}

func toCVSSV3_Severity(value *string) storage.CVSSV3_Severity {
	if value != nil {
		return storage.CVSSV3_Severity(storage.CVSSV3_Severity_value[*value])
	}
	return storage.CVSSV3_Severity(0)
}

func toCVSSV3_Severities(values *[]string) []storage.CVSSV3_Severity {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV3_Severity, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV3_Severity(&v)
	}
	return output
}

func toCVSSV3_UserInteraction(value *string) storage.CVSSV3_UserInteraction {
	if value != nil {
		return storage.CVSSV3_UserInteraction(storage.CVSSV3_UserInteraction_value[*value])
	}
	return storage.CVSSV3_UserInteraction(0)
}

func toCVSSV3_UserInteractions(values *[]string) []storage.CVSSV3_UserInteraction {
	if values == nil {
		return nil
	}
	output := make([]storage.CVSSV3_UserInteraction, len(*values))
	for i, v := range *values {
		output[i] = toCVSSV3_UserInteraction(&v)
	}
	return output
}

type certResolver struct {
	root *Resolver
	data *storage.Cert
}

func (resolver *Resolver) wrapCert(value *storage.Cert, ok bool, err error) (*certResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &certResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCerts(values []*storage.Cert, err error) ([]*certResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*certResolver, len(values))
	for i, v := range values {
		output[i] = &certResolver{resolver, v}
	}
	return output, nil
}

func (resolver *certResolver) Algorithm(ctx context.Context) string {
	value := resolver.data.GetAlgorithm()
	return value
}

func (resolver *certResolver) EndDate(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetEndDate()
	return timestamp(value)
}

func (resolver *certResolver) Issuer(ctx context.Context) (*certNameResolver, error) {
	value := resolver.data.GetIssuer()
	return resolver.root.wrapCertName(value, true, nil)
}

func (resolver *certResolver) Sans(ctx context.Context) []string {
	value := resolver.data.GetSans()
	return value
}

func (resolver *certResolver) StartDate(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetStartDate()
	return timestamp(value)
}

func (resolver *certResolver) Subject(ctx context.Context) (*certNameResolver, error) {
	value := resolver.data.GetSubject()
	return resolver.root.wrapCertName(value, true, nil)
}

type certNameResolver struct {
	root *Resolver
	data *storage.CertName
}

func (resolver *Resolver) wrapCertName(value *storage.CertName, ok bool, err error) (*certNameResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &certNameResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapCertNames(values []*storage.CertName, err error) ([]*certNameResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*certNameResolver, len(values))
	for i, v := range values {
		output[i] = &certNameResolver{resolver, v}
	}
	return output, nil
}

func (resolver *certNameResolver) CommonName(ctx context.Context) string {
	value := resolver.data.GetCommonName()
	return value
}

func (resolver *certNameResolver) Country(ctx context.Context) string {
	value := resolver.data.GetCountry()
	return value
}

func (resolver *certNameResolver) Locality(ctx context.Context) string {
	value := resolver.data.GetLocality()
	return value
}

func (resolver *certNameResolver) Names(ctx context.Context) []string {
	value := resolver.data.GetNames()
	return value
}

func (resolver *certNameResolver) Organization(ctx context.Context) string {
	value := resolver.data.GetOrganization()
	return value
}

func (resolver *certNameResolver) OrganizationUnit(ctx context.Context) string {
	value := resolver.data.GetOrganizationUnit()
	return value
}

func (resolver *certNameResolver) PostalCode(ctx context.Context) string {
	value := resolver.data.GetPostalCode()
	return value
}

func (resolver *certNameResolver) Province(ctx context.Context) string {
	value := resolver.data.GetProvince()
	return value
}

func (resolver *certNameResolver) StreetAddress(ctx context.Context) string {
	value := resolver.data.GetStreetAddress()
	return value
}

type clusterResolver struct {
	root *Resolver
	data *storage.Cluster
}

func (resolver *Resolver) wrapCluster(value *storage.Cluster, ok bool, err error) (*clusterResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &clusterResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapClusters(values []*storage.Cluster, err error) ([]*clusterResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*clusterResolver, len(values))
	for i, v := range values {
		output[i] = &clusterResolver{resolver, v}
	}
	return output, nil
}

func (resolver *clusterResolver) AdmissionController(ctx context.Context) bool {
	value := resolver.data.GetAdmissionController()
	return value
}

func (resolver *clusterResolver) CentralApiEndpoint(ctx context.Context) string {
	value := resolver.data.GetCentralApiEndpoint()
	return value
}

func (resolver *clusterResolver) CollectionMethod(ctx context.Context) string {
	value := resolver.data.GetCollectionMethod()
	return value.String()
}

func (resolver *clusterResolver) CollectorImage(ctx context.Context) string {
	value := resolver.data.GetCollectorImage()
	return value
}

func (resolver *clusterResolver) DynamicConfig(ctx context.Context) (*dynamicClusterConfigResolver, error) {
	value := resolver.data.GetDynamicConfig()
	return resolver.root.wrapDynamicClusterConfig(value, true, nil)
}

func (resolver *clusterResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *clusterResolver) MainImage(ctx context.Context) string {
	value := resolver.data.GetMainImage()
	return value
}

func (resolver *clusterResolver) MonitoringEndpoint(ctx context.Context) string {
	value := resolver.data.GetMonitoringEndpoint()
	return value
}

func (resolver *clusterResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *clusterResolver) Priority(ctx context.Context) int32 {
	value := resolver.data.GetPriority()
	return int32(value)
}

func (resolver *clusterResolver) RuntimeSupport(ctx context.Context) bool {
	value := resolver.data.GetRuntimeSupport()
	return value
}

func (resolver *clusterResolver) Status(ctx context.Context) (*clusterStatusResolver, error) {
	value := resolver.data.GetStatus()
	return resolver.root.wrapClusterStatus(value, true, nil)
}

func (resolver *clusterResolver) TolerationsConfig(ctx context.Context) (*tolerationsConfigResolver, error) {
	value := resolver.data.GetTolerationsConfig()
	return resolver.root.wrapTolerationsConfig(value, true, nil)
}

func (resolver *clusterResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value.String()
}

type clusterStatusResolver struct {
	root *Resolver
	data *storage.ClusterStatus
}

func (resolver *Resolver) wrapClusterStatus(value *storage.ClusterStatus, ok bool, err error) (*clusterStatusResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &clusterStatusResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapClusterStatuses(values []*storage.ClusterStatus, err error) ([]*clusterStatusResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*clusterStatusResolver, len(values))
	for i, v := range values {
		output[i] = &clusterStatusResolver{resolver, v}
	}
	return output, nil
}

func (resolver *clusterStatusResolver) LastContact(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetLastContact()
	return timestamp(value)
}

func (resolver *clusterStatusResolver) OrchestratorMetadata(ctx context.Context) (*orchestratorMetadataResolver, error) {
	value := resolver.data.GetOrchestratorMetadata()
	return resolver.root.wrapOrchestratorMetadata(value, true, nil)
}

func (resolver *clusterStatusResolver) ProviderMetadata(ctx context.Context) (*providerMetadataResolver, error) {
	value := resolver.data.GetProviderMetadata()
	return resolver.root.wrapProviderMetadata(value, true, nil)
}

func (resolver *clusterStatusResolver) SensorVersion(ctx context.Context) string {
	value := resolver.data.GetSensorVersion()
	return value
}

func (resolver *clusterStatusResolver) UpgradeStatus(ctx context.Context) (*clusterUpgradeStatusResolver, error) {
	value := resolver.data.GetUpgradeStatus()
	return resolver.root.wrapClusterUpgradeStatus(value, true, nil)
}

func toClusterType(value *string) storage.ClusterType {
	if value != nil {
		return storage.ClusterType(storage.ClusterType_value[*value])
	}
	return storage.ClusterType(0)
}

func toClusterTypes(values *[]string) []storage.ClusterType {
	if values == nil {
		return nil
	}
	output := make([]storage.ClusterType, len(*values))
	for i, v := range *values {
		output[i] = toClusterType(&v)
	}
	return output
}

type clusterUpgradeStatusResolver struct {
	root *Resolver
	data *storage.ClusterUpgradeStatus
}

func (resolver *Resolver) wrapClusterUpgradeStatus(value *storage.ClusterUpgradeStatus, ok bool, err error) (*clusterUpgradeStatusResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &clusterUpgradeStatusResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapClusterUpgradeStatuses(values []*storage.ClusterUpgradeStatus, err error) ([]*clusterUpgradeStatusResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*clusterUpgradeStatusResolver, len(values))
	for i, v := range values {
		output[i] = &clusterUpgradeStatusResolver{resolver, v}
	}
	return output, nil
}

func (resolver *clusterUpgradeStatusResolver) MostRecentProcess(ctx context.Context) (*clusterUpgradeStatus_UpgradeProcessStatusResolver, error) {
	value := resolver.data.GetMostRecentProcess()
	return resolver.root.wrapClusterUpgradeStatus_UpgradeProcessStatus(value, true, nil)
}

func (resolver *clusterUpgradeStatusResolver) Upgradability(ctx context.Context) string {
	value := resolver.data.GetUpgradability()
	return value.String()
}

func (resolver *clusterUpgradeStatusResolver) UpgradabilityStatusReason(ctx context.Context) string {
	value := resolver.data.GetUpgradabilityStatusReason()
	return value
}

func toClusterUpgradeStatus_Upgradability(value *string) storage.ClusterUpgradeStatus_Upgradability {
	if value != nil {
		return storage.ClusterUpgradeStatus_Upgradability(storage.ClusterUpgradeStatus_Upgradability_value[*value])
	}
	return storage.ClusterUpgradeStatus_Upgradability(0)
}

func toClusterUpgradeStatus_Upgradabilities(values *[]string) []storage.ClusterUpgradeStatus_Upgradability {
	if values == nil {
		return nil
	}
	output := make([]storage.ClusterUpgradeStatus_Upgradability, len(*values))
	for i, v := range *values {
		output[i] = toClusterUpgradeStatus_Upgradability(&v)
	}
	return output
}

type clusterUpgradeStatus_UpgradeProcessStatusResolver struct {
	root *Resolver
	data *storage.ClusterUpgradeStatus_UpgradeProcessStatus
}

func (resolver *Resolver) wrapClusterUpgradeStatus_UpgradeProcessStatus(value *storage.ClusterUpgradeStatus_UpgradeProcessStatus, ok bool, err error) (*clusterUpgradeStatus_UpgradeProcessStatusResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &clusterUpgradeStatus_UpgradeProcessStatusResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapClusterUpgradeStatus_UpgradeProcessStatuses(values []*storage.ClusterUpgradeStatus_UpgradeProcessStatus, err error) ([]*clusterUpgradeStatus_UpgradeProcessStatusResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*clusterUpgradeStatus_UpgradeProcessStatusResolver, len(values))
	for i, v := range values {
		output[i] = &clusterUpgradeStatus_UpgradeProcessStatusResolver{resolver, v}
	}
	return output, nil
}

func (resolver *clusterUpgradeStatus_UpgradeProcessStatusResolver) Active(ctx context.Context) bool {
	value := resolver.data.GetActive()
	return value
}

func (resolver *clusterUpgradeStatus_UpgradeProcessStatusResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *clusterUpgradeStatus_UpgradeProcessStatusResolver) InitiatedAt(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetInitiatedAt()
	return timestamp(value)
}

func (resolver *clusterUpgradeStatus_UpgradeProcessStatusResolver) Progress(ctx context.Context) (*upgradeProgressResolver, error) {
	value := resolver.data.GetProgress()
	return resolver.root.wrapUpgradeProgress(value, true, nil)
}

func (resolver *clusterUpgradeStatus_UpgradeProcessStatusResolver) TargetVersion(ctx context.Context) string {
	value := resolver.data.GetTargetVersion()
	return value
}

func (resolver *clusterUpgradeStatus_UpgradeProcessStatusResolver) UpgraderImage(ctx context.Context) string {
	value := resolver.data.GetUpgraderImage()
	return value
}

func toCollectionMethod(value *string) storage.CollectionMethod {
	if value != nil {
		return storage.CollectionMethod(storage.CollectionMethod_value[*value])
	}
	return storage.CollectionMethod(0)
}

func toCollectionMethods(values *[]string) []storage.CollectionMethod {
	if values == nil {
		return nil
	}
	output := make([]storage.CollectionMethod, len(*values))
	for i, v := range *values {
		output[i] = toCollectionMethod(&v)
	}
	return output
}

func toComparator(value *string) storage.Comparator {
	if value != nil {
		return storage.Comparator(storage.Comparator_value[*value])
	}
	return storage.Comparator(0)
}

func toComparators(values *[]string) []storage.Comparator {
	if values == nil {
		return nil
	}
	output := make([]storage.Comparator, len(*values))
	for i, v := range *values {
		output[i] = toComparator(&v)
	}
	return output
}

type complianceAggregation_AggregationKeyResolver struct {
	root *Resolver
	data *v1.ComplianceAggregation_AggregationKey
}

func (resolver *Resolver) wrapComplianceAggregation_AggregationKey(value *v1.ComplianceAggregation_AggregationKey, ok bool, err error) (*complianceAggregation_AggregationKeyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceAggregation_AggregationKeyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceAggregation_AggregationKeies(values []*v1.ComplianceAggregation_AggregationKey, err error) ([]*complianceAggregation_AggregationKeyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceAggregation_AggregationKeyResolver, len(values))
	for i, v := range values {
		output[i] = &complianceAggregation_AggregationKeyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceAggregation_AggregationKeyResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *complianceAggregation_AggregationKeyResolver) Scope(ctx context.Context) string {
	value := resolver.data.GetScope()
	return value.String()
}

type complianceAggregation_ResponseResolver struct {
	root *Resolver
	data *v1.ComplianceAggregation_Response
}

func (resolver *Resolver) wrapComplianceAggregation_Response(value *v1.ComplianceAggregation_Response, ok bool, err error) (*complianceAggregation_ResponseResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceAggregation_ResponseResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceAggregation_Responses(values []*v1.ComplianceAggregation_Response, err error) ([]*complianceAggregation_ResponseResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceAggregation_ResponseResolver, len(values))
	for i, v := range values {
		output[i] = &complianceAggregation_ResponseResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceAggregation_ResponseResolver) Results(ctx context.Context) ([]*complianceAggregation_ResultResolver, error) {
	value := resolver.data.GetResults()
	return resolver.root.wrapComplianceAggregation_Results(value, nil)
}

func (resolver *complianceAggregation_ResponseResolver) Sources(ctx context.Context) ([]*complianceAggregation_SourceResolver, error) {
	value := resolver.data.GetSources()
	return resolver.root.wrapComplianceAggregation_Sources(value, nil)
}

type complianceAggregation_ResultResolver struct {
	root *Resolver
	data *v1.ComplianceAggregation_Result
}

func (resolver *Resolver) wrapComplianceAggregation_Result(value *v1.ComplianceAggregation_Result, ok bool, err error) (*complianceAggregation_ResultResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceAggregation_ResultResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceAggregation_Results(values []*v1.ComplianceAggregation_Result, err error) ([]*complianceAggregation_ResultResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceAggregation_ResultResolver, len(values))
	for i, v := range values {
		output[i] = &complianceAggregation_ResultResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceAggregation_ResultResolver) AggregationKeys(ctx context.Context) ([]*complianceAggregation_AggregationKeyResolver, error) {
	value := resolver.data.GetAggregationKeys()
	return resolver.root.wrapComplianceAggregation_AggregationKeies(value, nil)
}

func (resolver *complianceAggregation_ResultResolver) NumFailing(ctx context.Context) int32 {
	value := resolver.data.GetNumFailing()
	return value
}

func (resolver *complianceAggregation_ResultResolver) NumPassing(ctx context.Context) int32 {
	value := resolver.data.GetNumPassing()
	return value
}

func (resolver *complianceAggregation_ResultResolver) Unit(ctx context.Context) string {
	value := resolver.data.GetUnit()
	return value.String()
}

func toComplianceAggregation_Scope(value *string) v1.ComplianceAggregation_Scope {
	if value != nil {
		return v1.ComplianceAggregation_Scope(v1.ComplianceAggregation_Scope_value[*value])
	}
	return v1.ComplianceAggregation_Scope(0)
}

func toComplianceAggregation_Scopes(values *[]string) []v1.ComplianceAggregation_Scope {
	if values == nil {
		return nil
	}
	output := make([]v1.ComplianceAggregation_Scope, len(*values))
	for i, v := range *values {
		output[i] = toComplianceAggregation_Scope(&v)
	}
	return output
}

type complianceAggregation_SourceResolver struct {
	root *Resolver
	data *v1.ComplianceAggregation_Source
}

func (resolver *Resolver) wrapComplianceAggregation_Source(value *v1.ComplianceAggregation_Source, ok bool, err error) (*complianceAggregation_SourceResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceAggregation_SourceResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceAggregation_Sources(values []*v1.ComplianceAggregation_Source, err error) ([]*complianceAggregation_SourceResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceAggregation_SourceResolver, len(values))
	for i, v := range values {
		output[i] = &complianceAggregation_SourceResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceAggregation_SourceResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *complianceAggregation_SourceResolver) FailedRuns(ctx context.Context) ([]*complianceRunMetadataResolver, error) {
	value := resolver.data.GetFailedRuns()
	return resolver.root.wrapComplianceRunMetadatas(value, nil)
}

func (resolver *complianceAggregation_SourceResolver) StandardId(ctx context.Context) string {
	value := resolver.data.GetStandardId()
	return value
}

func (resolver *complianceAggregation_SourceResolver) SuccessfulRun(ctx context.Context) (*complianceRunMetadataResolver, error) {
	value := resolver.data.GetSuccessfulRun()
	return resolver.root.wrapComplianceRunMetadata(value, true, nil)
}

type complianceControlResolver struct {
	root *Resolver
	data *v1.ComplianceControl
}

func (resolver *Resolver) wrapComplianceControl(value *v1.ComplianceControl, ok bool, err error) (*complianceControlResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceControlResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceControls(values []*v1.ComplianceControl, err error) ([]*complianceControlResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceControlResolver, len(values))
	for i, v := range values {
		output[i] = &complianceControlResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceControlResolver) Description(ctx context.Context) string {
	value := resolver.data.GetDescription()
	return value
}

func (resolver *complianceControlResolver) GroupId(ctx context.Context) string {
	value := resolver.data.GetGroupId()
	return value
}

func (resolver *complianceControlResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *complianceControlResolver) Implemented(ctx context.Context) bool {
	value := resolver.data.GetImplemented()
	return value
}

func (resolver *complianceControlResolver) InterpretationText(ctx context.Context) string {
	value := resolver.data.GetInterpretationText()
	return value
}

func (resolver *complianceControlResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *complianceControlResolver) StandardId(ctx context.Context) string {
	value := resolver.data.GetStandardId()
	return value
}

type complianceControlGroupResolver struct {
	root *Resolver
	data *v1.ComplianceControlGroup
}

func (resolver *Resolver) wrapComplianceControlGroup(value *v1.ComplianceControlGroup, ok bool, err error) (*complianceControlGroupResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceControlGroupResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceControlGroups(values []*v1.ComplianceControlGroup, err error) ([]*complianceControlGroupResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceControlGroupResolver, len(values))
	for i, v := range values {
		output[i] = &complianceControlGroupResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceControlGroupResolver) Description(ctx context.Context) string {
	value := resolver.data.GetDescription()
	return value
}

func (resolver *complianceControlGroupResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *complianceControlGroupResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *complianceControlGroupResolver) NumImplementedChecks(ctx context.Context) int32 {
	value := resolver.data.GetNumImplementedChecks()
	return value
}

func (resolver *complianceControlGroupResolver) StandardId(ctx context.Context) string {
	value := resolver.data.GetStandardId()
	return value
}

type complianceControlResultResolver struct {
	root *Resolver
	data *storage.ComplianceControlResult
}

func (resolver *Resolver) wrapComplianceControlResult(value *storage.ComplianceControlResult, ok bool, err error) (*complianceControlResultResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceControlResultResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceControlResults(values []*storage.ComplianceControlResult, err error) ([]*complianceControlResultResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceControlResultResolver, len(values))
	for i, v := range values {
		output[i] = &complianceControlResultResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceControlResultResolver) ControlId(ctx context.Context) string {
	value := resolver.data.GetControlId()
	return value
}

func (resolver *complianceControlResultResolver) Resource(ctx context.Context) (*complianceResourceResolver, error) {
	value := resolver.data.GetResource()
	return resolver.root.wrapComplianceResource(value, true, nil)
}

func (resolver *complianceControlResultResolver) Value(ctx context.Context) (*complianceResultValueResolver, error) {
	value := resolver.data.GetValue()
	return resolver.root.wrapComplianceResultValue(value, true, nil)
}

type complianceResourceResolver struct {
	root *Resolver
	data *storage.ComplianceResource
}

func (resolver *Resolver) wrapComplianceResource(value *storage.ComplianceResource, ok bool, err error) (*complianceResourceResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceResourceResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceResources(values []*storage.ComplianceResource, err error) ([]*complianceResourceResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceResourceResolver, len(values))
	for i, v := range values {
		output[i] = &complianceResourceResolver{resolver, v}
	}
	return output, nil
}

type complianceResourceResourceResolver struct {
	resolver interface{}
}

func (resolver *complianceResourceResolver) Resource() *complianceResourceResourceResolver {
	if val := resolver.data.GetCluster(); val != nil {
		return &complianceResourceResourceResolver{
			resolver: &complianceResource_ClusterNameResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetDeployment(); val != nil {
		return &complianceResourceResourceResolver{
			resolver: &complianceResource_DeploymentNameResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetNode(); val != nil {
		return &complianceResourceResourceResolver{
			resolver: &complianceResource_NodeNameResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetImage(); val != nil {
		return &complianceResourceResourceResolver{
			resolver: &imageNameResolver{resolver.root, val},
		}
	}
	return nil
}

func (resolver *complianceResourceResourceResolver) ToComplianceResource_ClusterName() (*complianceResource_ClusterNameResolver, bool) {
	res, ok := resolver.resolver.(*complianceResource_ClusterNameResolver)
	return res, ok
}

func (resolver *complianceResourceResourceResolver) ToComplianceResource_DeploymentName() (*complianceResource_DeploymentNameResolver, bool) {
	res, ok := resolver.resolver.(*complianceResource_DeploymentNameResolver)
	return res, ok
}

func (resolver *complianceResourceResourceResolver) ToComplianceResource_NodeName() (*complianceResource_NodeNameResolver, bool) {
	res, ok := resolver.resolver.(*complianceResource_NodeNameResolver)
	return res, ok
}

func (resolver *complianceResourceResourceResolver) ToImageName() (*imageNameResolver, bool) {
	res, ok := resolver.resolver.(*imageNameResolver)
	return res, ok
}

type complianceResource_ClusterNameResolver struct {
	root *Resolver
	data *storage.ComplianceResource_ClusterName
}

func (resolver *Resolver) wrapComplianceResource_ClusterName(value *storage.ComplianceResource_ClusterName, ok bool, err error) (*complianceResource_ClusterNameResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceResource_ClusterNameResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceResource_ClusterNames(values []*storage.ComplianceResource_ClusterName, err error) ([]*complianceResource_ClusterNameResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceResource_ClusterNameResolver, len(values))
	for i, v := range values {
		output[i] = &complianceResource_ClusterNameResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceResource_ClusterNameResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *complianceResource_ClusterNameResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

type complianceResource_DeploymentNameResolver struct {
	root *Resolver
	data *storage.ComplianceResource_DeploymentName
}

func (resolver *Resolver) wrapComplianceResource_DeploymentName(value *storage.ComplianceResource_DeploymentName, ok bool, err error) (*complianceResource_DeploymentNameResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceResource_DeploymentNameResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceResource_DeploymentNames(values []*storage.ComplianceResource_DeploymentName, err error) ([]*complianceResource_DeploymentNameResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceResource_DeploymentNameResolver, len(values))
	for i, v := range values {
		output[i] = &complianceResource_DeploymentNameResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceResource_DeploymentNameResolver) Cluster(ctx context.Context) (*complianceResource_ClusterNameResolver, error) {
	value := resolver.data.GetCluster()
	return resolver.root.wrapComplianceResource_ClusterName(value, true, nil)
}

func (resolver *complianceResource_DeploymentNameResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *complianceResource_DeploymentNameResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *complianceResource_DeploymentNameResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	return value
}

type complianceResource_NodeNameResolver struct {
	root *Resolver
	data *storage.ComplianceResource_NodeName
}

func (resolver *Resolver) wrapComplianceResource_NodeName(value *storage.ComplianceResource_NodeName, ok bool, err error) (*complianceResource_NodeNameResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceResource_NodeNameResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceResource_NodeNames(values []*storage.ComplianceResource_NodeName, err error) ([]*complianceResource_NodeNameResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceResource_NodeNameResolver, len(values))
	for i, v := range values {
		output[i] = &complianceResource_NodeNameResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceResource_NodeNameResolver) Cluster(ctx context.Context) (*complianceResource_ClusterNameResolver, error) {
	value := resolver.data.GetCluster()
	return resolver.root.wrapComplianceResource_ClusterName(value, true, nil)
}

func (resolver *complianceResource_NodeNameResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *complianceResource_NodeNameResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

type complianceResultValueResolver struct {
	root *Resolver
	data *storage.ComplianceResultValue
}

func (resolver *Resolver) wrapComplianceResultValue(value *storage.ComplianceResultValue, ok bool, err error) (*complianceResultValueResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceResultValueResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceResultValues(values []*storage.ComplianceResultValue, err error) ([]*complianceResultValueResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceResultValueResolver, len(values))
	for i, v := range values {
		output[i] = &complianceResultValueResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceResultValueResolver) Evidence(ctx context.Context) ([]*complianceResultValue_EvidenceResolver, error) {
	value := resolver.data.GetEvidence()
	return resolver.root.wrapComplianceResultValue_Evidences(value, nil)
}

func (resolver *complianceResultValueResolver) OverallState(ctx context.Context) string {
	value := resolver.data.GetOverallState()
	return value.String()
}

type complianceResultValue_EvidenceResolver struct {
	root *Resolver
	data *storage.ComplianceResultValue_Evidence
}

func (resolver *Resolver) wrapComplianceResultValue_Evidence(value *storage.ComplianceResultValue_Evidence, ok bool, err error) (*complianceResultValue_EvidenceResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceResultValue_EvidenceResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceResultValue_Evidences(values []*storage.ComplianceResultValue_Evidence, err error) ([]*complianceResultValue_EvidenceResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceResultValue_EvidenceResolver, len(values))
	for i, v := range values {
		output[i] = &complianceResultValue_EvidenceResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceResultValue_EvidenceResolver) Message(ctx context.Context) string {
	value := resolver.data.GetMessage()
	return value
}

func (resolver *complianceResultValue_EvidenceResolver) MessageId(ctx context.Context) int32 {
	value := resolver.data.GetMessageId()
	return value
}

func (resolver *complianceResultValue_EvidenceResolver) State(ctx context.Context) string {
	value := resolver.data.GetState()
	return value.String()
}

type complianceRunResolver struct {
	root *Resolver
	data *v1.ComplianceRun
}

func (resolver *Resolver) wrapComplianceRun(value *v1.ComplianceRun, ok bool, err error) (*complianceRunResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceRunResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceRuns(values []*v1.ComplianceRun, err error) ([]*complianceRunResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceRunResolver, len(values))
	for i, v := range values {
		output[i] = &complianceRunResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceRunResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *complianceRunResolver) ErrorMessage(ctx context.Context) string {
	value := resolver.data.GetErrorMessage()
	return value
}

func (resolver *complianceRunResolver) FinishTime(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetFinishTime()
	return timestamp(value)
}

func (resolver *complianceRunResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *complianceRunResolver) ScheduleId(ctx context.Context) string {
	value := resolver.data.GetScheduleId()
	return value
}

func (resolver *complianceRunResolver) StandardId(ctx context.Context) string {
	value := resolver.data.GetStandardId()
	return value
}

func (resolver *complianceRunResolver) StartTime(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetStartTime()
	return timestamp(value)
}

func (resolver *complianceRunResolver) State(ctx context.Context) string {
	value := resolver.data.GetState()
	return value.String()
}

type complianceRunMetadataResolver struct {
	root *Resolver
	data *storage.ComplianceRunMetadata
}

func (resolver *Resolver) wrapComplianceRunMetadata(value *storage.ComplianceRunMetadata, ok bool, err error) (*complianceRunMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceRunMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceRunMetadatas(values []*storage.ComplianceRunMetadata, err error) ([]*complianceRunMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceRunMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &complianceRunMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceRunMetadataResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *complianceRunMetadataResolver) ErrorMessage(ctx context.Context) string {
	value := resolver.data.GetErrorMessage()
	return value
}

func (resolver *complianceRunMetadataResolver) FinishTimestamp(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetFinishTimestamp()
	return timestamp(value)
}

func (resolver *complianceRunMetadataResolver) RunId(ctx context.Context) string {
	value := resolver.data.GetRunId()
	return value
}

func (resolver *complianceRunMetadataResolver) StandardId(ctx context.Context) string {
	value := resolver.data.GetStandardId()
	return value
}

func (resolver *complianceRunMetadataResolver) StartTimestamp(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetStartTimestamp()
	return timestamp(value)
}

func (resolver *complianceRunMetadataResolver) Success(ctx context.Context) bool {
	value := resolver.data.GetSuccess()
	return value
}

type complianceRunScheduleResolver struct {
	root *Resolver
	data *storage.ComplianceRunSchedule
}

func (resolver *Resolver) wrapComplianceRunSchedule(value *storage.ComplianceRunSchedule, ok bool, err error) (*complianceRunScheduleResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceRunScheduleResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceRunSchedules(values []*storage.ComplianceRunSchedule, err error) ([]*complianceRunScheduleResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceRunScheduleResolver, len(values))
	for i, v := range values {
		output[i] = &complianceRunScheduleResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceRunScheduleResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *complianceRunScheduleResolver) CrontabSpec(ctx context.Context) string {
	value := resolver.data.GetCrontabSpec()
	return value
}

func (resolver *complianceRunScheduleResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *complianceRunScheduleResolver) StandardId(ctx context.Context) string {
	value := resolver.data.GetStandardId()
	return value
}

func (resolver *complianceRunScheduleResolver) Suspended(ctx context.Context) bool {
	value := resolver.data.GetSuspended()
	return value
}

type complianceRunScheduleInfoResolver struct {
	root *Resolver
	data *v1.ComplianceRunScheduleInfo
}

func (resolver *Resolver) wrapComplianceRunScheduleInfo(value *v1.ComplianceRunScheduleInfo, ok bool, err error) (*complianceRunScheduleInfoResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceRunScheduleInfoResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceRunScheduleInfos(values []*v1.ComplianceRunScheduleInfo, err error) ([]*complianceRunScheduleInfoResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceRunScheduleInfoResolver, len(values))
	for i, v := range values {
		output[i] = &complianceRunScheduleInfoResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceRunScheduleInfoResolver) LastCompletedRun(ctx context.Context) (*complianceRunResolver, error) {
	value := resolver.data.GetLastCompletedRun()
	return resolver.root.wrapComplianceRun(value, true, nil)
}

func (resolver *complianceRunScheduleInfoResolver) LastRun(ctx context.Context) (*complianceRunResolver, error) {
	value := resolver.data.GetLastRun()
	return resolver.root.wrapComplianceRun(value, true, nil)
}

func (resolver *complianceRunScheduleInfoResolver) NextRunTime(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetNextRunTime()
	return timestamp(value)
}

func (resolver *complianceRunScheduleInfoResolver) Schedule(ctx context.Context) (*complianceRunScheduleResolver, error) {
	value := resolver.data.GetSchedule()
	return resolver.root.wrapComplianceRunSchedule(value, true, nil)
}

func toComplianceRun_State(value *string) v1.ComplianceRun_State {
	if value != nil {
		return v1.ComplianceRun_State(v1.ComplianceRun_State_value[*value])
	}
	return v1.ComplianceRun_State(0)
}

func toComplianceRun_States(values *[]string) []v1.ComplianceRun_State {
	if values == nil {
		return nil
	}
	output := make([]v1.ComplianceRun_State, len(*values))
	for i, v := range *values {
		output[i] = toComplianceRun_State(&v)
	}
	return output
}

type complianceStandardResolver struct {
	root *Resolver
	data *v1.ComplianceStandard
}

func (resolver *Resolver) wrapComplianceStandard(value *v1.ComplianceStandard, ok bool, err error) (*complianceStandardResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceStandardResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceStandards(values []*v1.ComplianceStandard, err error) ([]*complianceStandardResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceStandardResolver, len(values))
	for i, v := range values {
		output[i] = &complianceStandardResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceStandardResolver) Controls(ctx context.Context) ([]*complianceControlResolver, error) {
	value := resolver.data.GetControls()
	return resolver.root.wrapComplianceControls(value, nil)
}

func (resolver *complianceStandardResolver) Groups(ctx context.Context) ([]*complianceControlGroupResolver, error) {
	value := resolver.data.GetGroups()
	return resolver.root.wrapComplianceControlGroups(value, nil)
}

func (resolver *complianceStandardResolver) Metadata(ctx context.Context) (*complianceStandardMetadataResolver, error) {
	value := resolver.data.GetMetadata()
	return resolver.root.wrapComplianceStandardMetadata(value, true, nil)
}

type complianceStandardMetadataResolver struct {
	root *Resolver
	data *v1.ComplianceStandardMetadata
}

func (resolver *Resolver) wrapComplianceStandardMetadata(value *v1.ComplianceStandardMetadata, ok bool, err error) (*complianceStandardMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &complianceStandardMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComplianceStandardMetadatas(values []*v1.ComplianceStandardMetadata, err error) ([]*complianceStandardMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*complianceStandardMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &complianceStandardMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *complianceStandardMetadataResolver) Description(ctx context.Context) string {
	value := resolver.data.GetDescription()
	return value
}

func (resolver *complianceStandardMetadataResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *complianceStandardMetadataResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *complianceStandardMetadataResolver) NumImplementedChecks(ctx context.Context) int32 {
	value := resolver.data.GetNumImplementedChecks()
	return value
}

func toComplianceState(value *string) storage.ComplianceState {
	if value != nil {
		return storage.ComplianceState(storage.ComplianceState_value[*value])
	}
	return storage.ComplianceState(0)
}

func toComplianceStates(values *[]string) []storage.ComplianceState {
	if values == nil {
		return nil
	}
	output := make([]storage.ComplianceState, len(*values))
	for i, v := range *values {
		output[i] = toComplianceState(&v)
	}
	return output
}

type componentResolver struct {
	root *Resolver
	data *storage.Component
}

func (resolver *Resolver) wrapComponent(value *storage.Component, ok bool, err error) (*componentResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &componentResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapComponents(values []*storage.Component, err error) ([]*componentResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*componentResolver, len(values))
	for i, v := range values {
		output[i] = &componentResolver{resolver, v}
	}
	return output, nil
}

func (resolver *componentResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *componentResolver) Version(ctx context.Context) string {
	value := resolver.data.GetVersion()
	return value
}

type containerResolver struct {
	root *Resolver
	data *storage.Container
}

func (resolver *Resolver) wrapContainer(value *storage.Container, ok bool, err error) (*containerResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainers(values []*storage.Container, err error) ([]*containerResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerResolver, len(values))
	for i, v := range values {
		output[i] = &containerResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerResolver) Config(ctx context.Context) (*containerConfigResolver, error) {
	value := resolver.data.GetConfig()
	return resolver.root.wrapContainerConfig(value, true, nil)
}

func (resolver *containerResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *containerResolver) Image(ctx context.Context) (*containerImageResolver, error) {
	value := resolver.data.GetImage()
	return resolver.root.wrapContainerImage(value, true, nil)
}

func (resolver *containerResolver) Instances(ctx context.Context) ([]*containerInstanceResolver, error) {
	value := resolver.data.GetInstances()
	return resolver.root.wrapContainerInstances(value, nil)
}

func (resolver *containerResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *containerResolver) Ports(ctx context.Context) ([]*portConfigResolver, error) {
	value := resolver.data.GetPorts()
	return resolver.root.wrapPortConfigs(value, nil)
}

func (resolver *containerResolver) Resources(ctx context.Context) (*resourcesResolver, error) {
	value := resolver.data.GetResources()
	return resolver.root.wrapResources(value, true, nil)
}

func (resolver *containerResolver) Secrets(ctx context.Context) ([]*embeddedSecretResolver, error) {
	value := resolver.data.GetSecrets()
	return resolver.root.wrapEmbeddedSecrets(value, nil)
}

func (resolver *containerResolver) SecurityContext(ctx context.Context) (*securityContextResolver, error) {
	value := resolver.data.GetSecurityContext()
	return resolver.root.wrapSecurityContext(value, true, nil)
}

func (resolver *containerResolver) Volumes(ctx context.Context) ([]*volumeResolver, error) {
	value := resolver.data.GetVolumes()
	return resolver.root.wrapVolumes(value, nil)
}

type containerConfigResolver struct {
	root *Resolver
	data *storage.ContainerConfig
}

func (resolver *Resolver) wrapContainerConfig(value *storage.ContainerConfig, ok bool, err error) (*containerConfigResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerConfigResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainerConfigs(values []*storage.ContainerConfig, err error) ([]*containerConfigResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerConfigResolver, len(values))
	for i, v := range values {
		output[i] = &containerConfigResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerConfigResolver) Args(ctx context.Context) []string {
	value := resolver.data.GetArgs()
	return value
}

func (resolver *containerConfigResolver) Command(ctx context.Context) []string {
	value := resolver.data.GetCommand()
	return value
}

func (resolver *containerConfigResolver) Directory(ctx context.Context) string {
	value := resolver.data.GetDirectory()
	return value
}

func (resolver *containerConfigResolver) Env(ctx context.Context) ([]*containerConfig_EnvironmentConfigResolver, error) {
	value := resolver.data.GetEnv()
	return resolver.root.wrapContainerConfig_EnvironmentConfigs(value, nil)
}

func (resolver *containerConfigResolver) Uid(ctx context.Context) int32 {
	value := resolver.data.GetUid()
	return int32(value)
}

func (resolver *containerConfigResolver) User(ctx context.Context) string {
	value := resolver.data.GetUser()
	return value
}

type containerConfig_EnvironmentConfigResolver struct {
	root *Resolver
	data *storage.ContainerConfig_EnvironmentConfig
}

func (resolver *Resolver) wrapContainerConfig_EnvironmentConfig(value *storage.ContainerConfig_EnvironmentConfig, ok bool, err error) (*containerConfig_EnvironmentConfigResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerConfig_EnvironmentConfigResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainerConfig_EnvironmentConfigs(values []*storage.ContainerConfig_EnvironmentConfig, err error) ([]*containerConfig_EnvironmentConfigResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerConfig_EnvironmentConfigResolver, len(values))
	for i, v := range values {
		output[i] = &containerConfig_EnvironmentConfigResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerConfig_EnvironmentConfigResolver) EnvVarSource(ctx context.Context) string {
	value := resolver.data.GetEnvVarSource()
	return value.String()
}

func (resolver *containerConfig_EnvironmentConfigResolver) Key(ctx context.Context) string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *containerConfig_EnvironmentConfigResolver) Value(ctx context.Context) string {
	value := resolver.data.GetValue()
	return value
}

func toContainerConfig_EnvironmentConfig_EnvVarSource(value *string) storage.ContainerConfig_EnvironmentConfig_EnvVarSource {
	if value != nil {
		return storage.ContainerConfig_EnvironmentConfig_EnvVarSource(storage.ContainerConfig_EnvironmentConfig_EnvVarSource_value[*value])
	}
	return storage.ContainerConfig_EnvironmentConfig_EnvVarSource(0)
}

func toContainerConfig_EnvironmentConfig_EnvVarSources(values *[]string) []storage.ContainerConfig_EnvironmentConfig_EnvVarSource {
	if values == nil {
		return nil
	}
	output := make([]storage.ContainerConfig_EnvironmentConfig_EnvVarSource, len(*values))
	for i, v := range *values {
		output[i] = toContainerConfig_EnvironmentConfig_EnvVarSource(&v)
	}
	return output
}

type containerImageResolver struct {
	root *Resolver
	data *storage.ContainerImage
}

func (resolver *Resolver) wrapContainerImage(value *storage.ContainerImage, ok bool, err error) (*containerImageResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerImageResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainerImages(values []*storage.ContainerImage, err error) ([]*containerImageResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerImageResolver, len(values))
	for i, v := range values {
		output[i] = &containerImageResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerImageResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *containerImageResolver) Name(ctx context.Context) (*imageNameResolver, error) {
	value := resolver.data.GetName()
	return resolver.root.wrapImageName(value, true, nil)
}

func (resolver *containerImageResolver) NotPullable(ctx context.Context) bool {
	value := resolver.data.GetNotPullable()
	return value
}

type containerInstanceResolver struct {
	root *Resolver
	data *storage.ContainerInstance
}

func (resolver *Resolver) wrapContainerInstance(value *storage.ContainerInstance, ok bool, err error) (*containerInstanceResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerInstanceResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainerInstances(values []*storage.ContainerInstance, err error) ([]*containerInstanceResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerInstanceResolver, len(values))
	for i, v := range values {
		output[i] = &containerInstanceResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerInstanceResolver) ContainerIps(ctx context.Context) []string {
	value := resolver.data.GetContainerIps()
	return value
}

func (resolver *containerInstanceResolver) ContainingPodId(ctx context.Context) string {
	value := resolver.data.GetContainingPodId()
	return value
}

func (resolver *containerInstanceResolver) InstanceId(ctx context.Context) (*containerInstanceIDResolver, error) {
	value := resolver.data.GetInstanceId()
	return resolver.root.wrapContainerInstanceID(value, true, nil)
}

func (resolver *containerInstanceResolver) Started(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetStarted()
	return timestamp(value)
}

type containerInstanceIDResolver struct {
	root *Resolver
	data *storage.ContainerInstanceID
}

func (resolver *Resolver) wrapContainerInstanceID(value *storage.ContainerInstanceID, ok bool, err error) (*containerInstanceIDResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerInstanceIDResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainerInstanceIDs(values []*storage.ContainerInstanceID, err error) ([]*containerInstanceIDResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerInstanceIDResolver, len(values))
	for i, v := range values {
		output[i] = &containerInstanceIDResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerInstanceIDResolver) ContainerRuntime(ctx context.Context) string {
	value := resolver.data.GetContainerRuntime()
	return value.String()
}

func (resolver *containerInstanceIDResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *containerInstanceIDResolver) Node(ctx context.Context) string {
	value := resolver.data.GetNode()
	return value
}

func toContainerRuntime(value *string) storage.ContainerRuntime {
	if value != nil {
		return storage.ContainerRuntime(storage.ContainerRuntime_value[*value])
	}
	return storage.ContainerRuntime(0)
}

func toContainerRuntimes(values *[]string) []storage.ContainerRuntime {
	if values == nil {
		return nil
	}
	output := make([]storage.ContainerRuntime, len(*values))
	for i, v := range *values {
		output[i] = toContainerRuntime(&v)
	}
	return output
}

type containerRuntimeInfoResolver struct {
	root *Resolver
	data *storage.ContainerRuntimeInfo
}

func (resolver *Resolver) wrapContainerRuntimeInfo(value *storage.ContainerRuntimeInfo, ok bool, err error) (*containerRuntimeInfoResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &containerRuntimeInfoResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapContainerRuntimeInfos(values []*storage.ContainerRuntimeInfo, err error) ([]*containerRuntimeInfoResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*containerRuntimeInfoResolver, len(values))
	for i, v := range values {
		output[i] = &containerRuntimeInfoResolver{resolver, v}
	}
	return output, nil
}

func (resolver *containerRuntimeInfoResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value.String()
}

func (resolver *containerRuntimeInfoResolver) Version(ctx context.Context) string {
	value := resolver.data.GetVersion()
	return value
}

type deploymentResolver struct {
	root *Resolver
	data *storage.Deployment
	list *storage.ListDeployment
}

func (resolver *Resolver) wrapDeployment(value *storage.Deployment, ok bool, err error) (*deploymentResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &deploymentResolver{resolver, value, nil}, nil
}

func (resolver *Resolver) wrapDeployments(values []*storage.Deployment, err error) ([]*deploymentResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*deploymentResolver, len(values))
	for i, v := range values {
		output[i] = &deploymentResolver{resolver, v, nil}
	}
	return output, nil
}

func (resolver *Resolver) wrapListDeployments(values []*storage.ListDeployment, err error) ([]*deploymentResolver, error) {
	if err != nil || values == nil {
		return nil, err
	}
	output := make([]*deploymentResolver, len(values))
	for i, v := range values {
		output[i] = &deploymentResolver{resolver, nil, v}
	}
	return output, nil
}

func (resolver *deploymentResolver) ensureData(ctx context.Context) {
	if resolver.data == nil {
		resolver.data = resolver.root.getDeployment(ctx, resolver.list.GetId())
	}
}

func (resolver *deploymentResolver) Annotations(ctx context.Context) labels {
	resolver.ensureData(ctx)
	value := resolver.data.GetAnnotations()
	return labelsResolver(value)
}

func (resolver *deploymentResolver) AutomountServiceAccountToken(ctx context.Context) bool {
	resolver.ensureData(ctx)
	value := resolver.data.GetAutomountServiceAccountToken()
	return value
}

func (resolver *deploymentResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	if resolver.data == nil {
		value = resolver.list.GetClusterId()
	}
	return value
}

func (resolver *deploymentResolver) ClusterName(ctx context.Context) string {
	resolver.ensureData(ctx)
	value := resolver.data.GetClusterName()
	return value
}

func (resolver *deploymentResolver) Containers(ctx context.Context) ([]*containerResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetContainers()
	return resolver.root.wrapContainers(value, nil)
}

func (resolver *deploymentResolver) Created(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetCreated()
	if resolver.data == nil {
		value = resolver.list.GetCreated()
	}
	return timestamp(value)
}

func (resolver *deploymentResolver) HostNetwork(ctx context.Context) bool {
	resolver.ensureData(ctx)
	value := resolver.data.GetHostNetwork()
	return value
}

func (resolver *deploymentResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	if resolver.data == nil {
		value = resolver.list.GetId()
	}
	return graphql.ID(value)
}

func (resolver *deploymentResolver) ImagePullSecrets(ctx context.Context) []string {
	resolver.ensureData(ctx)
	value := resolver.data.GetImagePullSecrets()
	return value
}

func (resolver *deploymentResolver) Inactive(ctx context.Context) bool {
	resolver.ensureData(ctx)
	value := resolver.data.GetInactive()
	return value
}

func (resolver *deploymentResolver) LabelSelector(ctx context.Context) (*labelSelectorResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetLabelSelector()
	return resolver.root.wrapLabelSelector(value, true, nil)
}

func (resolver *deploymentResolver) Labels(ctx context.Context) labels {
	resolver.ensureData(ctx)
	value := resolver.data.GetLabels()
	return labelsResolver(value)
}

func (resolver *deploymentResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	if resolver.data == nil {
		value = resolver.list.GetName()
	}
	return value
}

func (resolver *deploymentResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	if resolver.data == nil {
		value = resolver.list.GetNamespace()
	}
	return value
}

func (resolver *deploymentResolver) NamespaceId(ctx context.Context) string {
	resolver.ensureData(ctx)
	value := resolver.data.GetNamespaceId()
	return value
}

func (resolver *deploymentResolver) PodLabels(ctx context.Context) labels {
	resolver.ensureData(ctx)
	value := resolver.data.GetPodLabels()
	return labelsResolver(value)
}

func (resolver *deploymentResolver) Ports(ctx context.Context) ([]*portConfigResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetPorts()
	return resolver.root.wrapPortConfigs(value, nil)
}

func (resolver *deploymentResolver) Priority(ctx context.Context) int32 {
	value := resolver.data.GetPriority()
	if resolver.data == nil {
		value = resolver.list.GetPriority()
	}
	return int32(value)
}

func (resolver *deploymentResolver) Replicas(ctx context.Context) int32 {
	resolver.ensureData(ctx)
	value := resolver.data.GetReplicas()
	return int32(value)
}

func (resolver *deploymentResolver) ServiceAccount(ctx context.Context) string {
	resolver.ensureData(ctx)
	value := resolver.data.GetServiceAccount()
	return value
}

func (resolver *deploymentResolver) StateTimestamp(ctx context.Context) int32 {
	resolver.ensureData(ctx)
	value := resolver.data.GetStateTimestamp()
	return int32(value)
}

func (resolver *deploymentResolver) Tolerations(ctx context.Context) ([]*tolerationResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetTolerations()
	return resolver.root.wrapTolerations(value, nil)
}

func (resolver *deploymentResolver) Type(ctx context.Context) string {
	resolver.ensureData(ctx)
	value := resolver.data.GetType()
	return value
}

type dockerfileLineRuleFieldResolver struct {
	root *Resolver
	data *storage.DockerfileLineRuleField
}

func (resolver *Resolver) wrapDockerfileLineRuleField(value *storage.DockerfileLineRuleField, ok bool, err error) (*dockerfileLineRuleFieldResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &dockerfileLineRuleFieldResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapDockerfileLineRuleFields(values []*storage.DockerfileLineRuleField, err error) ([]*dockerfileLineRuleFieldResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*dockerfileLineRuleFieldResolver, len(values))
	for i, v := range values {
		output[i] = &dockerfileLineRuleFieldResolver{resolver, v}
	}
	return output, nil
}

func (resolver *dockerfileLineRuleFieldResolver) Instruction(ctx context.Context) string {
	value := resolver.data.GetInstruction()
	return value
}

func (resolver *dockerfileLineRuleFieldResolver) Value(ctx context.Context) string {
	value := resolver.data.GetValue()
	return value
}

type dynamicClusterConfigResolver struct {
	root *Resolver
	data *storage.DynamicClusterConfig
}

func (resolver *Resolver) wrapDynamicClusterConfig(value *storage.DynamicClusterConfig, ok bool, err error) (*dynamicClusterConfigResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &dynamicClusterConfigResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapDynamicClusterConfigs(values []*storage.DynamicClusterConfig, err error) ([]*dynamicClusterConfigResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*dynamicClusterConfigResolver, len(values))
	for i, v := range values {
		output[i] = &dynamicClusterConfigResolver{resolver, v}
	}
	return output, nil
}

func (resolver *dynamicClusterConfigResolver) AdmissionControllerConfig(ctx context.Context) (*admissionControllerConfigResolver, error) {
	value := resolver.data.GetAdmissionControllerConfig()
	return resolver.root.wrapAdmissionControllerConfig(value, true, nil)
}

func (resolver *dynamicClusterConfigResolver) RegistryOverride(ctx context.Context) string {
	value := resolver.data.GetRegistryOverride()
	return value
}

type emailResolver struct {
	root *Resolver
	data *storage.Email
}

func (resolver *Resolver) wrapEmail(value *storage.Email, ok bool, err error) (*emailResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &emailResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapEmails(values []*storage.Email, err error) ([]*emailResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*emailResolver, len(values))
	for i, v := range values {
		output[i] = &emailResolver{resolver, v}
	}
	return output, nil
}

func (resolver *emailResolver) DisableTLS(ctx context.Context) bool {
	value := resolver.data.GetDisableTLS()
	return value
}

func (resolver *emailResolver) From(ctx context.Context) string {
	value := resolver.data.GetFrom()
	return value
}

func (resolver *emailResolver) Password(ctx context.Context) string {
	value := resolver.data.GetPassword()
	return value
}

func (resolver *emailResolver) Sender(ctx context.Context) string {
	value := resolver.data.GetSender()
	return value
}

func (resolver *emailResolver) Server(ctx context.Context) string {
	value := resolver.data.GetServer()
	return value
}

func (resolver *emailResolver) UseSTARTTLS(ctx context.Context) bool {
	value := resolver.data.GetUseSTARTTLS()
	return value
}

func (resolver *emailResolver) Username(ctx context.Context) string {
	value := resolver.data.GetUsername()
	return value
}

func toEmbeddedImageScanComponent_SourceType(value *string) storage.EmbeddedImageScanComponent_SourceType {
	if value != nil {
		return storage.EmbeddedImageScanComponent_SourceType(storage.EmbeddedImageScanComponent_SourceType_value[*value])
	}
	return storage.EmbeddedImageScanComponent_SourceType(0)
}

func toEmbeddedImageScanComponent_SourceTypes(values *[]string) []storage.EmbeddedImageScanComponent_SourceType {
	if values == nil {
		return nil
	}
	output := make([]storage.EmbeddedImageScanComponent_SourceType, len(*values))
	for i, v := range *values {
		output[i] = toEmbeddedImageScanComponent_SourceType(&v)
	}
	return output
}

type embeddedSecretResolver struct {
	root *Resolver
	data *storage.EmbeddedSecret
}

func (resolver *Resolver) wrapEmbeddedSecret(value *storage.EmbeddedSecret, ok bool, err error) (*embeddedSecretResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &embeddedSecretResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapEmbeddedSecrets(values []*storage.EmbeddedSecret, err error) ([]*embeddedSecretResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*embeddedSecretResolver, len(values))
	for i, v := range values {
		output[i] = &embeddedSecretResolver{resolver, v}
	}
	return output, nil
}

func (resolver *embeddedSecretResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *embeddedSecretResolver) Path(ctx context.Context) string {
	value := resolver.data.GetPath()
	return value
}

func toEmbeddedVulnerability_ScoreVersion(value *string) storage.EmbeddedVulnerability_ScoreVersion {
	if value != nil {
		return storage.EmbeddedVulnerability_ScoreVersion(storage.EmbeddedVulnerability_ScoreVersion_value[*value])
	}
	return storage.EmbeddedVulnerability_ScoreVersion(0)
}

func toEmbeddedVulnerability_ScoreVersions(values *[]string) []storage.EmbeddedVulnerability_ScoreVersion {
	if values == nil {
		return nil
	}
	output := make([]storage.EmbeddedVulnerability_ScoreVersion, len(*values))
	for i, v := range *values {
		output[i] = toEmbeddedVulnerability_ScoreVersion(&v)
	}
	return output
}

func toEmbeddedVulnerability_VulnerabilityType(value *string) storage.EmbeddedVulnerability_VulnerabilityType {
	if value != nil {
		return storage.EmbeddedVulnerability_VulnerabilityType(storage.EmbeddedVulnerability_VulnerabilityType_value[*value])
	}
	return storage.EmbeddedVulnerability_VulnerabilityType(0)
}

func toEmbeddedVulnerability_VulnerabilityTypes(values *[]string) []storage.EmbeddedVulnerability_VulnerabilityType {
	if values == nil {
		return nil
	}
	output := make([]storage.EmbeddedVulnerability_VulnerabilityType, len(*values))
	for i, v := range *values {
		output[i] = toEmbeddedVulnerability_VulnerabilityType(&v)
	}
	return output
}

func toEnforcementAction(value *string) storage.EnforcementAction {
	if value != nil {
		return storage.EnforcementAction(storage.EnforcementAction_value[*value])
	}
	return storage.EnforcementAction(0)
}

func toEnforcementActions(values *[]string) []storage.EnforcementAction {
	if values == nil {
		return nil
	}
	output := make([]storage.EnforcementAction, len(*values))
	for i, v := range *values {
		output[i] = toEnforcementAction(&v)
	}
	return output
}

type generateTokenResponseResolver struct {
	root *Resolver
	data *v1.GenerateTokenResponse
}

func (resolver *Resolver) wrapGenerateTokenResponse(value *v1.GenerateTokenResponse, ok bool, err error) (*generateTokenResponseResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &generateTokenResponseResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapGenerateTokenResponses(values []*v1.GenerateTokenResponse, err error) ([]*generateTokenResponseResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*generateTokenResponseResolver, len(values))
	for i, v := range values {
		output[i] = &generateTokenResponseResolver{resolver, v}
	}
	return output, nil
}

func (resolver *generateTokenResponseResolver) Metadata(ctx context.Context) (*tokenMetadataResolver, error) {
	value := resolver.data.GetMetadata()
	return resolver.root.wrapTokenMetadata(value, true, nil)
}

func (resolver *generateTokenResponseResolver) Token(ctx context.Context) string {
	value := resolver.data.GetToken()
	return value
}

type genericResolver struct {
	root *Resolver
	data *storage.Generic
}

func (resolver *Resolver) wrapGeneric(value *storage.Generic, ok bool, err error) (*genericResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &genericResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapGenerics(values []*storage.Generic, err error) ([]*genericResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*genericResolver, len(values))
	for i, v := range values {
		output[i] = &genericResolver{resolver, v}
	}
	return output, nil
}

func (resolver *genericResolver) AuditLoggingEnabled(ctx context.Context) bool {
	value := resolver.data.GetAuditLoggingEnabled()
	return value
}

func (resolver *genericResolver) CaCert(ctx context.Context) string {
	value := resolver.data.GetCaCert()
	return value
}

func (resolver *genericResolver) Endpoint(ctx context.Context) string {
	value := resolver.data.GetEndpoint()
	return value
}

func (resolver *genericResolver) ExtraFields(ctx context.Context) ([]*keyValuePairResolver, error) {
	value := resolver.data.GetExtraFields()
	return resolver.root.wrapKeyValuePairs(value, nil)
}

func (resolver *genericResolver) Headers(ctx context.Context) ([]*keyValuePairResolver, error) {
	value := resolver.data.GetHeaders()
	return resolver.root.wrapKeyValuePairs(value, nil)
}

func (resolver *genericResolver) Password(ctx context.Context) string {
	value := resolver.data.GetPassword()
	return value
}

func (resolver *genericResolver) SkipTLSVerify(ctx context.Context) bool {
	value := resolver.data.GetSkipTLSVerify()
	return value
}

func (resolver *genericResolver) Username(ctx context.Context) string {
	value := resolver.data.GetUsername()
	return value
}

type getComplianceRunStatusesResponseResolver struct {
	root *Resolver
	data *v1.GetComplianceRunStatusesResponse
}

func (resolver *Resolver) wrapGetComplianceRunStatusesResponse(value *v1.GetComplianceRunStatusesResponse, ok bool, err error) (*getComplianceRunStatusesResponseResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &getComplianceRunStatusesResponseResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapGetComplianceRunStatusesResponses(values []*v1.GetComplianceRunStatusesResponse, err error) ([]*getComplianceRunStatusesResponseResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*getComplianceRunStatusesResponseResolver, len(values))
	for i, v := range values {
		output[i] = &getComplianceRunStatusesResponseResolver{resolver, v}
	}
	return output, nil
}

func (resolver *getComplianceRunStatusesResponseResolver) InvalidRunIds(ctx context.Context) []string {
	value := resolver.data.GetInvalidRunIds()
	return value
}

func (resolver *getComplianceRunStatusesResponseResolver) Runs(ctx context.Context) ([]*complianceRunResolver, error) {
	value := resolver.data.GetRuns()
	return resolver.root.wrapComplianceRuns(value, nil)
}

type googleProviderMetadataResolver struct {
	root *Resolver
	data *storage.GoogleProviderMetadata
}

func (resolver *Resolver) wrapGoogleProviderMetadata(value *storage.GoogleProviderMetadata, ok bool, err error) (*googleProviderMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &googleProviderMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapGoogleProviderMetadatas(values []*storage.GoogleProviderMetadata, err error) ([]*googleProviderMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*googleProviderMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &googleProviderMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *googleProviderMetadataResolver) ClusterName(ctx context.Context) string {
	value := resolver.data.GetClusterName()
	return value
}

func (resolver *googleProviderMetadataResolver) Project(ctx context.Context) string {
	value := resolver.data.GetProject()
	return value
}

type groupResolver struct {
	root *Resolver
	data *storage.Group
}

func (resolver *Resolver) wrapGroup(value *storage.Group, ok bool, err error) (*groupResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &groupResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapGroups(values []*storage.Group, err error) ([]*groupResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*groupResolver, len(values))
	for i, v := range values {
		output[i] = &groupResolver{resolver, v}
	}
	return output, nil
}

func (resolver *groupResolver) Props(ctx context.Context) (*groupPropertiesResolver, error) {
	value := resolver.data.GetProps()
	return resolver.root.wrapGroupProperties(value, true, nil)
}

func (resolver *groupResolver) RoleName(ctx context.Context) string {
	value := resolver.data.GetRoleName()
	return value
}

type groupPropertiesResolver struct {
	root *Resolver
	data *storage.GroupProperties
}

func (resolver *Resolver) wrapGroupProperties(value *storage.GroupProperties, ok bool, err error) (*groupPropertiesResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &groupPropertiesResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapGroupPropertieses(values []*storage.GroupProperties, err error) ([]*groupPropertiesResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*groupPropertiesResolver, len(values))
	for i, v := range values {
		output[i] = &groupPropertiesResolver{resolver, v}
	}
	return output, nil
}

func (resolver *groupPropertiesResolver) AuthProviderId(ctx context.Context) string {
	value := resolver.data.GetAuthProviderId()
	return value
}

func (resolver *groupPropertiesResolver) Key(ctx context.Context) string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *groupPropertiesResolver) Value(ctx context.Context) string {
	value := resolver.data.GetValue()
	return value
}

type hostMountPolicyResolver struct {
	root *Resolver
	data *storage.HostMountPolicy
}

func (resolver *Resolver) wrapHostMountPolicy(value *storage.HostMountPolicy, ok bool, err error) (*hostMountPolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &hostMountPolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapHostMountPolicies(values []*storage.HostMountPolicy, err error) ([]*hostMountPolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*hostMountPolicyResolver, len(values))
	for i, v := range values {
		output[i] = &hostMountPolicyResolver{resolver, v}
	}
	return output, nil
}

type imageResolver struct {
	root *Resolver
	data *storage.Image
	list *storage.ListImage
}

func (resolver *Resolver) wrapImage(value *storage.Image, ok bool, err error) (*imageResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageResolver{resolver, value, nil}, nil
}

func (resolver *Resolver) wrapImages(values []*storage.Image, err error) ([]*imageResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageResolver, len(values))
	for i, v := range values {
		output[i] = &imageResolver{resolver, v, nil}
	}
	return output, nil
}

func (resolver *Resolver) wrapListImages(values []*storage.ListImage, err error) ([]*imageResolver, error) {
	if err != nil || values == nil {
		return nil, err
	}
	output := make([]*imageResolver, len(values))
	for i, v := range values {
		output[i] = &imageResolver{resolver, nil, v}
	}
	return output, nil
}

func (resolver *imageResolver) ensureData(ctx context.Context) {
	if resolver.data == nil {
		resolver.data = resolver.root.getImage(ctx, resolver.list.GetId())
	}
}

func (resolver *imageResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	if resolver.data == nil {
		value = resolver.list.GetId()
	}
	return graphql.ID(value)
}

func (resolver *imageResolver) LastUpdated(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetLastUpdated()
	if resolver.data == nil {
		value = resolver.list.GetLastUpdated()
	}
	return timestamp(value)
}

func (resolver *imageResolver) Metadata(ctx context.Context) (*imageMetadataResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetMetadata()
	return resolver.root.wrapImageMetadata(value, true, nil)
}

func (resolver *imageResolver) Name(ctx context.Context) (*imageNameResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetName()
	return resolver.root.wrapImageName(value, true, nil)
}

func (resolver *imageResolver) NotPullable(ctx context.Context) bool {
	resolver.ensureData(ctx)
	value := resolver.data.GetNotPullable()
	return value
}

func (resolver *imageResolver) Priority(ctx context.Context) int32 {
	value := resolver.data.GetPriority()
	if resolver.data == nil {
		value = resolver.list.GetPriority()
	}
	return int32(value)
}

func (resolver *imageResolver) Scan(ctx context.Context) (*imageScanResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetScan()
	return resolver.root.wrapImageScan(value, true, nil)
}

type imageComponentResolver struct {
	root *Resolver
	data *storage.ImageComponent
}

func (resolver *Resolver) wrapImageComponent(value *storage.ImageComponent, ok bool, err error) (*imageComponentResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageComponentResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageComponents(values []*storage.ImageComponent, err error) ([]*imageComponentResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageComponentResolver, len(values))
	for i, v := range values {
		output[i] = &imageComponentResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageComponentResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *imageComponentResolver) License(ctx context.Context) (*imageComponent_LicenseResolver, error) {
	value := resolver.data.GetLicense()
	return resolver.root.wrapImageComponent_License(value, true, nil)
}

func (resolver *imageComponentResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *imageComponentResolver) Priority(ctx context.Context) int32 {
	value := resolver.data.GetPriority()
	return int32(value)
}

func (resolver *imageComponentResolver) Version(ctx context.Context) string {
	value := resolver.data.GetVersion()
	return value
}

type imageComponent_LicenseResolver struct {
	root *Resolver
	data *storage.ImageComponent_License
}

func (resolver *Resolver) wrapImageComponent_License(value *storage.ImageComponent_License, ok bool, err error) (*imageComponent_LicenseResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageComponent_LicenseResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageComponent_Licenses(values []*storage.ImageComponent_License, err error) ([]*imageComponent_LicenseResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageComponent_LicenseResolver, len(values))
	for i, v := range values {
		output[i] = &imageComponent_LicenseResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageComponent_LicenseResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *imageComponent_LicenseResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value
}

func (resolver *imageComponent_LicenseResolver) Url(ctx context.Context) string {
	value := resolver.data.GetUrl()
	return value
}

type imageLayerResolver struct {
	root *Resolver
	data *storage.ImageLayer
}

func (resolver *Resolver) wrapImageLayer(value *storage.ImageLayer, ok bool, err error) (*imageLayerResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageLayerResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageLayers(values []*storage.ImageLayer, err error) ([]*imageLayerResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageLayerResolver, len(values))
	for i, v := range values {
		output[i] = &imageLayerResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageLayerResolver) Author(ctx context.Context) string {
	value := resolver.data.GetAuthor()
	return value
}

func (resolver *imageLayerResolver) Created(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetCreated()
	return timestamp(value)
}

func (resolver *imageLayerResolver) Empty(ctx context.Context) bool {
	value := resolver.data.GetEmpty()
	return value
}

func (resolver *imageLayerResolver) Instruction(ctx context.Context) string {
	value := resolver.data.GetInstruction()
	return value
}

func (resolver *imageLayerResolver) Value(ctx context.Context) string {
	value := resolver.data.GetValue()
	return value
}

type imageMetadataResolver struct {
	root *Resolver
	data *storage.ImageMetadata
}

func (resolver *Resolver) wrapImageMetadata(value *storage.ImageMetadata, ok bool, err error) (*imageMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageMetadatas(values []*storage.ImageMetadata, err error) ([]*imageMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &imageMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageMetadataResolver) LayerShas(ctx context.Context) []string {
	value := resolver.data.GetLayerShas()
	return value
}

func (resolver *imageMetadataResolver) V1(ctx context.Context) (*v1MetadataResolver, error) {
	value := resolver.data.GetV1()
	return resolver.root.wrapV1Metadata(value, true, nil)
}

func (resolver *imageMetadataResolver) V2(ctx context.Context) (*v2MetadataResolver, error) {
	value := resolver.data.GetV2()
	return resolver.root.wrapV2Metadata(value, true, nil)
}

type imageNameResolver struct {
	root *Resolver
	data *storage.ImageName
}

func (resolver *Resolver) wrapImageName(value *storage.ImageName, ok bool, err error) (*imageNameResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageNameResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageNames(values []*storage.ImageName, err error) ([]*imageNameResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageNameResolver, len(values))
	for i, v := range values {
		output[i] = &imageNameResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageNameResolver) FullName(ctx context.Context) string {
	value := resolver.data.GetFullName()
	return value
}

func (resolver *imageNameResolver) Registry(ctx context.Context) string {
	value := resolver.data.GetRegistry()
	return value
}

func (resolver *imageNameResolver) Remote(ctx context.Context) string {
	value := resolver.data.GetRemote()
	return value
}

func (resolver *imageNameResolver) Tag(ctx context.Context) string {
	value := resolver.data.GetTag()
	return value
}

type imageNamePolicyResolver struct {
	root *Resolver
	data *storage.ImageNamePolicy
}

func (resolver *Resolver) wrapImageNamePolicy(value *storage.ImageNamePolicy, ok bool, err error) (*imageNamePolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageNamePolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageNamePolicies(values []*storage.ImageNamePolicy, err error) ([]*imageNamePolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageNamePolicyResolver, len(values))
	for i, v := range values {
		output[i] = &imageNamePolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageNamePolicyResolver) Registry(ctx context.Context) string {
	value := resolver.data.GetRegistry()
	return value
}

func (resolver *imageNamePolicyResolver) Remote(ctx context.Context) string {
	value := resolver.data.GetRemote()
	return value
}

func (resolver *imageNamePolicyResolver) Tag(ctx context.Context) string {
	value := resolver.data.GetTag()
	return value
}

type imagePullSecretResolver struct {
	root *Resolver
	data *storage.ImagePullSecret
}

func (resolver *Resolver) wrapImagePullSecret(value *storage.ImagePullSecret, ok bool, err error) (*imagePullSecretResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imagePullSecretResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImagePullSecrets(values []*storage.ImagePullSecret, err error) ([]*imagePullSecretResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imagePullSecretResolver, len(values))
	for i, v := range values {
		output[i] = &imagePullSecretResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imagePullSecretResolver) Registries(ctx context.Context) ([]*imagePullSecret_RegistryResolver, error) {
	value := resolver.data.GetRegistries()
	return resolver.root.wrapImagePullSecret_Registries(value, nil)
}

type imagePullSecret_RegistryResolver struct {
	root *Resolver
	data *storage.ImagePullSecret_Registry
}

func (resolver *Resolver) wrapImagePullSecret_Registry(value *storage.ImagePullSecret_Registry, ok bool, err error) (*imagePullSecret_RegistryResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imagePullSecret_RegistryResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImagePullSecret_Registries(values []*storage.ImagePullSecret_Registry, err error) ([]*imagePullSecret_RegistryResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imagePullSecret_RegistryResolver, len(values))
	for i, v := range values {
		output[i] = &imagePullSecret_RegistryResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imagePullSecret_RegistryResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *imagePullSecret_RegistryResolver) Username(ctx context.Context) string {
	value := resolver.data.GetUsername()
	return value
}

type imageScanResolver struct {
	root *Resolver
	data *storage.ImageScan
}

func (resolver *Resolver) wrapImageScan(value *storage.ImageScan, ok bool, err error) (*imageScanResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &imageScanResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapImageScans(values []*storage.ImageScan, err error) ([]*imageScanResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*imageScanResolver, len(values))
	for i, v := range values {
		output[i] = &imageScanResolver{resolver, v}
	}
	return output, nil
}

func (resolver *imageScanResolver) ScanTime(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetScanTime()
	return timestamp(value)
}

type jiraResolver struct {
	root *Resolver
	data *storage.Jira
}

func (resolver *Resolver) wrapJira(value *storage.Jira, ok bool, err error) (*jiraResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &jiraResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapJiras(values []*storage.Jira, err error) ([]*jiraResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*jiraResolver, len(values))
	for i, v := range values {
		output[i] = &jiraResolver{resolver, v}
	}
	return output, nil
}

func (resolver *jiraResolver) IssueType(ctx context.Context) string {
	value := resolver.data.GetIssueType()
	return value
}

func (resolver *jiraResolver) Password(ctx context.Context) string {
	value := resolver.data.GetPassword()
	return value
}

func (resolver *jiraResolver) Url(ctx context.Context) string {
	value := resolver.data.GetUrl()
	return value
}

func (resolver *jiraResolver) Username(ctx context.Context) string {
	value := resolver.data.GetUsername()
	return value
}

type k8SRoleResolver struct {
	root *Resolver
	data *storage.K8SRole
}

func (resolver *Resolver) wrapK8SRole(value *storage.K8SRole, ok bool, err error) (*k8SRoleResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &k8SRoleResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapK8SRoles(values []*storage.K8SRole, err error) ([]*k8SRoleResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*k8SRoleResolver, len(values))
	for i, v := range values {
		output[i] = &k8SRoleResolver{resolver, v}
	}
	return output, nil
}

func (resolver *k8SRoleResolver) Annotations(ctx context.Context) labels {
	value := resolver.data.GetAnnotations()
	return labelsResolver(value)
}

func (resolver *k8SRoleResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *k8SRoleResolver) ClusterName(ctx context.Context) string {
	value := resolver.data.GetClusterName()
	return value
}

func (resolver *k8SRoleResolver) ClusterRole(ctx context.Context) bool {
	value := resolver.data.GetClusterRole()
	return value
}

func (resolver *k8SRoleResolver) CreatedAt(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetCreatedAt()
	return timestamp(value)
}

func (resolver *k8SRoleResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *k8SRoleResolver) Labels(ctx context.Context) labels {
	value := resolver.data.GetLabels()
	return labelsResolver(value)
}

func (resolver *k8SRoleResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *k8SRoleResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	return value
}

func (resolver *k8SRoleResolver) Rules(ctx context.Context) ([]*policyRuleResolver, error) {
	value := resolver.data.GetRules()
	return resolver.root.wrapPolicyRules(value, nil)
}

type k8SRoleBindingResolver struct {
	root *Resolver
	data *storage.K8SRoleBinding
}

func (resolver *Resolver) wrapK8SRoleBinding(value *storage.K8SRoleBinding, ok bool, err error) (*k8SRoleBindingResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &k8SRoleBindingResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapK8SRoleBindings(values []*storage.K8SRoleBinding, err error) ([]*k8SRoleBindingResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*k8SRoleBindingResolver, len(values))
	for i, v := range values {
		output[i] = &k8SRoleBindingResolver{resolver, v}
	}
	return output, nil
}

func (resolver *k8SRoleBindingResolver) Annotations(ctx context.Context) labels {
	value := resolver.data.GetAnnotations()
	return labelsResolver(value)
}

func (resolver *k8SRoleBindingResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *k8SRoleBindingResolver) ClusterName(ctx context.Context) string {
	value := resolver.data.GetClusterName()
	return value
}

func (resolver *k8SRoleBindingResolver) ClusterRole(ctx context.Context) bool {
	value := resolver.data.GetClusterRole()
	return value
}

func (resolver *k8SRoleBindingResolver) CreatedAt(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetCreatedAt()
	return timestamp(value)
}

func (resolver *k8SRoleBindingResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *k8SRoleBindingResolver) Labels(ctx context.Context) labels {
	value := resolver.data.GetLabels()
	return labelsResolver(value)
}

func (resolver *k8SRoleBindingResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *k8SRoleBindingResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	return value
}

func (resolver *k8SRoleBindingResolver) RoleId(ctx context.Context) string {
	value := resolver.data.GetRoleId()
	return value
}

func (resolver *k8SRoleBindingResolver) Subjects(ctx context.Context) ([]*subjectResolver, error) {
	value := resolver.data.GetSubjects()
	return resolver.root.wrapSubjects(value, nil)
}

type keyValuePairResolver struct {
	root *Resolver
	data *storage.KeyValuePair
}

func (resolver *Resolver) wrapKeyValuePair(value *storage.KeyValuePair, ok bool, err error) (*keyValuePairResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &keyValuePairResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapKeyValuePairs(values []*storage.KeyValuePair, err error) ([]*keyValuePairResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*keyValuePairResolver, len(values))
	for i, v := range values {
		output[i] = &keyValuePairResolver{resolver, v}
	}
	return output, nil
}

func (resolver *keyValuePairResolver) Key(ctx context.Context) string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *keyValuePairResolver) Value(ctx context.Context) string {
	value := resolver.data.GetValue()
	return value
}

type keyValuePolicyResolver struct {
	root *Resolver
	data *storage.KeyValuePolicy
}

func (resolver *Resolver) wrapKeyValuePolicy(value *storage.KeyValuePolicy, ok bool, err error) (*keyValuePolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &keyValuePolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapKeyValuePolicies(values []*storage.KeyValuePolicy, err error) ([]*keyValuePolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*keyValuePolicyResolver, len(values))
	for i, v := range values {
		output[i] = &keyValuePolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *keyValuePolicyResolver) EnvVarSource(ctx context.Context) string {
	value := resolver.data.GetEnvVarSource()
	return value.String()
}

func (resolver *keyValuePolicyResolver) Key(ctx context.Context) string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *keyValuePolicyResolver) Value(ctx context.Context) string {
	value := resolver.data.GetValue()
	return value
}

func toL4Protocol(value *string) storage.L4Protocol {
	if value != nil {
		return storage.L4Protocol(storage.L4Protocol_value[*value])
	}
	return storage.L4Protocol(0)
}

func toL4Protocols(values *[]string) []storage.L4Protocol {
	if values == nil {
		return nil
	}
	output := make([]storage.L4Protocol, len(*values))
	for i, v := range *values {
		output[i] = toL4Protocol(&v)
	}
	return output
}

type labelSelectorResolver struct {
	root *Resolver
	data *storage.LabelSelector
}

func (resolver *Resolver) wrapLabelSelector(value *storage.LabelSelector, ok bool, err error) (*labelSelectorResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &labelSelectorResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapLabelSelectors(values []*storage.LabelSelector, err error) ([]*labelSelectorResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*labelSelectorResolver, len(values))
	for i, v := range values {
		output[i] = &labelSelectorResolver{resolver, v}
	}
	return output, nil
}

func (resolver *labelSelectorResolver) MatchLabels(ctx context.Context) labels {
	value := resolver.data.GetMatchLabels()
	return labelsResolver(value)
}

func (resolver *labelSelectorResolver) Requirements(ctx context.Context) ([]*labelSelector_RequirementResolver, error) {
	value := resolver.data.GetRequirements()
	return resolver.root.wrapLabelSelector_Requirements(value, nil)
}

func toLabelSelector_Operator(value *string) storage.LabelSelector_Operator {
	if value != nil {
		return storage.LabelSelector_Operator(storage.LabelSelector_Operator_value[*value])
	}
	return storage.LabelSelector_Operator(0)
}

func toLabelSelector_Operators(values *[]string) []storage.LabelSelector_Operator {
	if values == nil {
		return nil
	}
	output := make([]storage.LabelSelector_Operator, len(*values))
	for i, v := range *values {
		output[i] = toLabelSelector_Operator(&v)
	}
	return output
}

type labelSelector_RequirementResolver struct {
	root *Resolver
	data *storage.LabelSelector_Requirement
}

func (resolver *Resolver) wrapLabelSelector_Requirement(value *storage.LabelSelector_Requirement, ok bool, err error) (*labelSelector_RequirementResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &labelSelector_RequirementResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapLabelSelector_Requirements(values []*storage.LabelSelector_Requirement, err error) ([]*labelSelector_RequirementResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*labelSelector_RequirementResolver, len(values))
	for i, v := range values {
		output[i] = &labelSelector_RequirementResolver{resolver, v}
	}
	return output, nil
}

func (resolver *labelSelector_RequirementResolver) Key(ctx context.Context) string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *labelSelector_RequirementResolver) Op(ctx context.Context) string {
	value := resolver.data.GetOp()
	return value.String()
}

func (resolver *labelSelector_RequirementResolver) Values(ctx context.Context) []string {
	value := resolver.data.GetValues()
	return value
}

type licenseResolver struct {
	root *Resolver
	data *storage.License
}

func (resolver *Resolver) wrapLicense(value *storage.License, ok bool, err error) (*licenseResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &licenseResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapLicenses(values []*storage.License, err error) ([]*licenseResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*licenseResolver, len(values))
	for i, v := range values {
		output[i] = &licenseResolver{resolver, v}
	}
	return output, nil
}

func (resolver *licenseResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *licenseResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value
}

func (resolver *licenseResolver) Url(ctx context.Context) string {
	value := resolver.data.GetUrl()
	return value
}

func toLifecycleStage(value *string) storage.LifecycleStage {
	if value != nil {
		return storage.LifecycleStage(storage.LifecycleStage_value[*value])
	}
	return storage.LifecycleStage(0)
}

func toLifecycleStages(values *[]string) []storage.LifecycleStage {
	if values == nil {
		return nil
	}
	output := make([]storage.LifecycleStage, len(*values))
	for i, v := range *values {
		output[i] = toLifecycleStage(&v)
	}
	return output
}

type metadataResolver struct {
	root *Resolver
	data *v1.Metadata
}

func (resolver *Resolver) wrapMetadata(value *v1.Metadata, ok bool, err error) (*metadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &metadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapMetadatas(values []*v1.Metadata, err error) ([]*metadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*metadataResolver, len(values))
	for i, v := range values {
		output[i] = &metadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *metadataResolver) BuildFlavor(ctx context.Context) string {
	value := resolver.data.GetBuildFlavor()
	return value
}

func (resolver *metadataResolver) LicenseStatus(ctx context.Context) string {
	value := resolver.data.GetLicenseStatus()
	return value.String()
}

func (resolver *metadataResolver) ReleaseBuild(ctx context.Context) bool {
	value := resolver.data.GetReleaseBuild()
	return value
}

func (resolver *metadataResolver) Version(ctx context.Context) string {
	value := resolver.data.GetVersion()
	return value
}

func toMetadata_LicenseStatus(value *string) v1.Metadata_LicenseStatus {
	if value != nil {
		return v1.Metadata_LicenseStatus(v1.Metadata_LicenseStatus_value[*value])
	}
	return v1.Metadata_LicenseStatus(0)
}

func toMetadata_LicenseStatuses(values *[]string) []v1.Metadata_LicenseStatus {
	if values == nil {
		return nil
	}
	output := make([]v1.Metadata_LicenseStatus, len(*values))
	for i, v := range *values {
		output[i] = toMetadata_LicenseStatus(&v)
	}
	return output
}

type namespaceResolver struct {
	root *Resolver
	data *v1.Namespace
}

func (resolver *Resolver) wrapNamespace(value *v1.Namespace, ok bool, err error) (*namespaceResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &namespaceResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNamespaces(values []*v1.Namespace, err error) ([]*namespaceResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*namespaceResolver, len(values))
	for i, v := range values {
		output[i] = &namespaceResolver{resolver, v}
	}
	return output, nil
}

func (resolver *namespaceResolver) Metadata(ctx context.Context) (*namespaceMetadataResolver, error) {
	value := resolver.data.GetMetadata()
	return resolver.root.wrapNamespaceMetadata(value, true, nil)
}

func (resolver *namespaceResolver) NumDeployments(ctx context.Context) int32 {
	value := resolver.data.GetNumDeployments()
	return value
}

func (resolver *namespaceResolver) NumNetworkPolicies(ctx context.Context) int32 {
	value := resolver.data.GetNumNetworkPolicies()
	return value
}

func (resolver *namespaceResolver) NumSecrets(ctx context.Context) int32 {
	value := resolver.data.GetNumSecrets()
	return value
}

type namespaceMetadataResolver struct {
	root *Resolver
	data *storage.NamespaceMetadata
}

func (resolver *Resolver) wrapNamespaceMetadata(value *storage.NamespaceMetadata, ok bool, err error) (*namespaceMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &namespaceMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNamespaceMetadatas(values []*storage.NamespaceMetadata, err error) ([]*namespaceMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*namespaceMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &namespaceMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *namespaceMetadataResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *namespaceMetadataResolver) ClusterName(ctx context.Context) string {
	value := resolver.data.GetClusterName()
	return value
}

func (resolver *namespaceMetadataResolver) CreationTime(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetCreationTime()
	return timestamp(value)
}

func (resolver *namespaceMetadataResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *namespaceMetadataResolver) Labels(ctx context.Context) labels {
	value := resolver.data.GetLabels()
	return labelsResolver(value)
}

func (resolver *namespaceMetadataResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *namespaceMetadataResolver) Priority(ctx context.Context) int32 {
	value := resolver.data.GetPriority()
	return int32(value)
}

type networkEntityInfoResolver struct {
	root *Resolver
	data *storage.NetworkEntityInfo
}

func (resolver *Resolver) wrapNetworkEntityInfo(value *storage.NetworkEntityInfo, ok bool, err error) (*networkEntityInfoResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &networkEntityInfoResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNetworkEntityInfos(values []*storage.NetworkEntityInfo, err error) ([]*networkEntityInfoResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*networkEntityInfoResolver, len(values))
	for i, v := range values {
		output[i] = &networkEntityInfoResolver{resolver, v}
	}
	return output, nil
}

func (resolver *networkEntityInfoResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *networkEntityInfoResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value.String()
}

type networkEntityInfoDescResolver struct {
	resolver interface{}
}

func (resolver *networkEntityInfoResolver) Desc() *networkEntityInfoDescResolver {
	if val := resolver.data.GetDeployment(); val != nil {
		return &networkEntityInfoDescResolver{
			resolver: &networkEntityInfo_DeploymentResolver{resolver.root, val},
		}
	}
	return nil
}

func (resolver *networkEntityInfoDescResolver) ToNetworkEntityInfo_Deployment() (*networkEntityInfo_DeploymentResolver, bool) {
	res, ok := resolver.resolver.(*networkEntityInfo_DeploymentResolver)
	return res, ok
}

type networkEntityInfo_DeploymentResolver struct {
	root *Resolver
	data *storage.NetworkEntityInfo_Deployment
}

func (resolver *Resolver) wrapNetworkEntityInfo_Deployment(value *storage.NetworkEntityInfo_Deployment, ok bool, err error) (*networkEntityInfo_DeploymentResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &networkEntityInfo_DeploymentResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNetworkEntityInfo_Deployments(values []*storage.NetworkEntityInfo_Deployment, err error) ([]*networkEntityInfo_DeploymentResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*networkEntityInfo_DeploymentResolver, len(values))
	for i, v := range values {
		output[i] = &networkEntityInfo_DeploymentResolver{resolver, v}
	}
	return output, nil
}

func (resolver *networkEntityInfo_DeploymentResolver) Cluster(ctx context.Context) string {
	value := resolver.data.GetCluster()
	return value
}

func (resolver *networkEntityInfo_DeploymentResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *networkEntityInfo_DeploymentResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	return value
}

func toNetworkEntityInfo_Type(value *string) storage.NetworkEntityInfo_Type {
	if value != nil {
		return storage.NetworkEntityInfo_Type(storage.NetworkEntityInfo_Type_value[*value])
	}
	return storage.NetworkEntityInfo_Type(0)
}

func toNetworkEntityInfo_Types(values *[]string) []storage.NetworkEntityInfo_Type {
	if values == nil {
		return nil
	}
	output := make([]storage.NetworkEntityInfo_Type, len(*values))
	for i, v := range *values {
		output[i] = toNetworkEntityInfo_Type(&v)
	}
	return output
}

type networkFlowResolver struct {
	root *Resolver
	data *storage.NetworkFlow
}

func (resolver *Resolver) wrapNetworkFlow(value *storage.NetworkFlow, ok bool, err error) (*networkFlowResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &networkFlowResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNetworkFlows(values []*storage.NetworkFlow, err error) ([]*networkFlowResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*networkFlowResolver, len(values))
	for i, v := range values {
		output[i] = &networkFlowResolver{resolver, v}
	}
	return output, nil
}

func (resolver *networkFlowResolver) LastSeenTimestamp(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetLastSeenTimestamp()
	return timestamp(value)
}

func (resolver *networkFlowResolver) Props(ctx context.Context) (*networkFlowPropertiesResolver, error) {
	value := resolver.data.GetProps()
	return resolver.root.wrapNetworkFlowProperties(value, true, nil)
}

type networkFlowPropertiesResolver struct {
	root *Resolver
	data *storage.NetworkFlowProperties
}

func (resolver *Resolver) wrapNetworkFlowProperties(value *storage.NetworkFlowProperties, ok bool, err error) (*networkFlowPropertiesResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &networkFlowPropertiesResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNetworkFlowPropertieses(values []*storage.NetworkFlowProperties, err error) ([]*networkFlowPropertiesResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*networkFlowPropertiesResolver, len(values))
	for i, v := range values {
		output[i] = &networkFlowPropertiesResolver{resolver, v}
	}
	return output, nil
}

func (resolver *networkFlowPropertiesResolver) DstEntity(ctx context.Context) (*networkEntityInfoResolver, error) {
	value := resolver.data.GetDstEntity()
	return resolver.root.wrapNetworkEntityInfo(value, true, nil)
}

func (resolver *networkFlowPropertiesResolver) DstPort(ctx context.Context) int32 {
	value := resolver.data.GetDstPort()
	return int32(value)
}

func (resolver *networkFlowPropertiesResolver) L4Protocol(ctx context.Context) string {
	value := resolver.data.GetL4Protocol()
	return value.String()
}

func (resolver *networkFlowPropertiesResolver) SrcEntity(ctx context.Context) (*networkEntityInfoResolver, error) {
	value := resolver.data.GetSrcEntity()
	return resolver.root.wrapNetworkEntityInfo(value, true, nil)
}

type nodeResolver struct {
	root *Resolver
	data *storage.Node
}

func (resolver *Resolver) wrapNode(value *storage.Node, ok bool, err error) (*nodeResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &nodeResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNodes(values []*storage.Node, err error) ([]*nodeResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*nodeResolver, len(values))
	for i, v := range values {
		output[i] = &nodeResolver{resolver, v}
	}
	return output, nil
}

func (resolver *nodeResolver) Annotations(ctx context.Context) labels {
	value := resolver.data.GetAnnotations()
	return labelsResolver(value)
}

func (resolver *nodeResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *nodeResolver) ClusterName(ctx context.Context) string {
	value := resolver.data.GetClusterName()
	return value
}

func (resolver *nodeResolver) ContainerRuntime(ctx context.Context) (*containerRuntimeInfoResolver, error) {
	value := resolver.data.GetContainerRuntime()
	return resolver.root.wrapContainerRuntimeInfo(value, true, nil)
}

func (resolver *nodeResolver) ContainerRuntimeVersion(ctx context.Context) string {
	value := resolver.data.GetContainerRuntimeVersion()
	return value
}

func (resolver *nodeResolver) ExternalIpAddresses(ctx context.Context) []string {
	value := resolver.data.GetExternalIpAddresses()
	return value
}

func (resolver *nodeResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *nodeResolver) InternalIpAddresses(ctx context.Context) []string {
	value := resolver.data.GetInternalIpAddresses()
	return value
}

func (resolver *nodeResolver) JoinedAt(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetJoinedAt()
	return timestamp(value)
}

func (resolver *nodeResolver) KernelVersion(ctx context.Context) string {
	value := resolver.data.GetKernelVersion()
	return value
}

func (resolver *nodeResolver) KubeletVersion(ctx context.Context) string {
	value := resolver.data.GetKubeletVersion()
	return value
}

func (resolver *nodeResolver) Labels(ctx context.Context) labels {
	value := resolver.data.GetLabels()
	return labelsResolver(value)
}

func (resolver *nodeResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *nodeResolver) OsImage(ctx context.Context) string {
	value := resolver.data.GetOsImage()
	return value
}

func (resolver *nodeResolver) Taints(ctx context.Context) ([]*taintResolver, error) {
	value := resolver.data.GetTaints()
	return resolver.root.wrapTaints(value, nil)
}

type notifierResolver struct {
	root *Resolver
	data *storage.Notifier
}

func (resolver *Resolver) wrapNotifier(value *storage.Notifier, ok bool, err error) (*notifierResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &notifierResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNotifiers(values []*storage.Notifier, err error) ([]*notifierResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*notifierResolver, len(values))
	for i, v := range values {
		output[i] = &notifierResolver{resolver, v}
	}
	return output, nil
}

func (resolver *notifierResolver) Enabled(ctx context.Context) bool {
	value := resolver.data.GetEnabled()
	return value
}

func (resolver *notifierResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *notifierResolver) LabelDefault(ctx context.Context) string {
	value := resolver.data.GetLabelDefault()
	return value
}

func (resolver *notifierResolver) LabelKey(ctx context.Context) string {
	value := resolver.data.GetLabelKey()
	return value
}

func (resolver *notifierResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *notifierResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value
}

func (resolver *notifierResolver) UiEndpoint(ctx context.Context) string {
	value := resolver.data.GetUiEndpoint()
	return value
}

type notifierConfigResolver struct {
	resolver interface{}
}

func (resolver *notifierResolver) Config() *notifierConfigResolver {
	if val := resolver.data.GetJira(); val != nil {
		return &notifierConfigResolver{
			resolver: &jiraResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetEmail(); val != nil {
		return &notifierConfigResolver{
			resolver: &emailResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetCscc(); val != nil {
		return &notifierConfigResolver{
			resolver: &cSCCResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetSplunk(); val != nil {
		return &notifierConfigResolver{
			resolver: &splunkResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetPagerduty(); val != nil {
		return &notifierConfigResolver{
			resolver: &pagerDutyResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetGeneric(); val != nil {
		return &notifierConfigResolver{
			resolver: &genericResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetSumologic(); val != nil {
		return &notifierConfigResolver{
			resolver: &sumoLogicResolver{resolver.root, val},
		}
	}
	return nil
}

func (resolver *notifierConfigResolver) ToJira() (*jiraResolver, bool) {
	res, ok := resolver.resolver.(*jiraResolver)
	return res, ok
}

func (resolver *notifierConfigResolver) ToEmail() (*emailResolver, bool) {
	res, ok := resolver.resolver.(*emailResolver)
	return res, ok
}

func (resolver *notifierConfigResolver) ToCSCC() (*cSCCResolver, bool) {
	res, ok := resolver.resolver.(*cSCCResolver)
	return res, ok
}

func (resolver *notifierConfigResolver) ToSplunk() (*splunkResolver, bool) {
	res, ok := resolver.resolver.(*splunkResolver)
	return res, ok
}

func (resolver *notifierConfigResolver) ToPagerDuty() (*pagerDutyResolver, bool) {
	res, ok := resolver.resolver.(*pagerDutyResolver)
	return res, ok
}

func (resolver *notifierConfigResolver) ToGeneric() (*genericResolver, bool) {
	res, ok := resolver.resolver.(*genericResolver)
	return res, ok
}

func (resolver *notifierConfigResolver) ToSumoLogic() (*sumoLogicResolver, bool) {
	res, ok := resolver.resolver.(*sumoLogicResolver)
	return res, ok
}

type numericalPolicyResolver struct {
	root *Resolver
	data *storage.NumericalPolicy
}

func (resolver *Resolver) wrapNumericalPolicy(value *storage.NumericalPolicy, ok bool, err error) (*numericalPolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &numericalPolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapNumericalPolicies(values []*storage.NumericalPolicy, err error) ([]*numericalPolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*numericalPolicyResolver, len(values))
	for i, v := range values {
		output[i] = &numericalPolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *numericalPolicyResolver) Op(ctx context.Context) string {
	value := resolver.data.GetOp()
	return value.String()
}

func (resolver *numericalPolicyResolver) Value(ctx context.Context) float64 {
	value := resolver.data.GetValue()
	return float64(value)
}

type orchestratorMetadataResolver struct {
	root *Resolver
	data *storage.OrchestratorMetadata
}

func (resolver *Resolver) wrapOrchestratorMetadata(value *storage.OrchestratorMetadata, ok bool, err error) (*orchestratorMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &orchestratorMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapOrchestratorMetadatas(values []*storage.OrchestratorMetadata, err error) ([]*orchestratorMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*orchestratorMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &orchestratorMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *orchestratorMetadataResolver) ApiVersions(ctx context.Context) []string {
	value := resolver.data.GetApiVersions()
	return value
}

func (resolver *orchestratorMetadataResolver) BuildDate(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetBuildDate()
	return timestamp(value)
}

func (resolver *orchestratorMetadataResolver) Version(ctx context.Context) string {
	value := resolver.data.GetVersion()
	return value
}

type pagerDutyResolver struct {
	root *Resolver
	data *storage.PagerDuty
}

func (resolver *Resolver) wrapPagerDuty(value *storage.PagerDuty, ok bool, err error) (*pagerDutyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &pagerDutyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPagerDuties(values []*storage.PagerDuty, err error) ([]*pagerDutyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*pagerDutyResolver, len(values))
	for i, v := range values {
		output[i] = &pagerDutyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *pagerDutyResolver) ApiKey(ctx context.Context) string {
	value := resolver.data.GetApiKey()
	return value
}

func toPermissionLevel(value *string) storage.PermissionLevel {
	if value != nil {
		return storage.PermissionLevel(storage.PermissionLevel_value[*value])
	}
	return storage.PermissionLevel(0)
}

func toPermissionLevels(values *[]string) []storage.PermissionLevel {
	if values == nil {
		return nil
	}
	output := make([]storage.PermissionLevel, len(*values))
	for i, v := range *values {
		output[i] = toPermissionLevel(&v)
	}
	return output
}

type permissionPolicyResolver struct {
	root *Resolver
	data *storage.PermissionPolicy
}

func (resolver *Resolver) wrapPermissionPolicy(value *storage.PermissionPolicy, ok bool, err error) (*permissionPolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &permissionPolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPermissionPolicies(values []*storage.PermissionPolicy, err error) ([]*permissionPolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*permissionPolicyResolver, len(values))
	for i, v := range values {
		output[i] = &permissionPolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *permissionPolicyResolver) PermissionLevel(ctx context.Context) string {
	value := resolver.data.GetPermissionLevel()
	return value.String()
}

type policyResolver struct {
	root *Resolver
	data *storage.Policy
}

func (resolver *Resolver) wrapPolicy(value *storage.Policy, ok bool, err error) (*policyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &policyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPolicies(values []*storage.Policy, err error) ([]*policyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*policyResolver, len(values))
	for i, v := range values {
		output[i] = &policyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *policyResolver) Categories(ctx context.Context) []string {
	value := resolver.data.GetCategories()
	return value
}

func (resolver *policyResolver) Description(ctx context.Context) string {
	value := resolver.data.GetDescription()
	return value
}

func (resolver *policyResolver) Disabled(ctx context.Context) bool {
	value := resolver.data.GetDisabled()
	return value
}

func (resolver *policyResolver) EnforcementActions(ctx context.Context) []string {
	value := resolver.data.GetEnforcementActions()
	return stringSlice(value)
}

func (resolver *policyResolver) Fields(ctx context.Context) (*policyFieldsResolver, error) {
	value := resolver.data.GetFields()
	return resolver.root.wrapPolicyFields(value, true, nil)
}

func (resolver *policyResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *policyResolver) LastUpdated(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetLastUpdated()
	return timestamp(value)
}

func (resolver *policyResolver) LifecycleStages(ctx context.Context) []string {
	value := resolver.data.GetLifecycleStages()
	return stringSlice(value)
}

func (resolver *policyResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *policyResolver) Notifiers(ctx context.Context) []string {
	value := resolver.data.GetNotifiers()
	return value
}

func (resolver *policyResolver) Rationale(ctx context.Context) string {
	value := resolver.data.GetRationale()
	return value
}

func (resolver *policyResolver) Remediation(ctx context.Context) string {
	value := resolver.data.GetRemediation()
	return value
}

func (resolver *policyResolver) Scope(ctx context.Context) ([]*scopeResolver, error) {
	value := resolver.data.GetScope()
	return resolver.root.wrapScopes(value, nil)
}

func (resolver *policyResolver) Severity(ctx context.Context) string {
	value := resolver.data.GetSeverity()
	return value.String()
}

func (resolver *policyResolver) Whitelists(ctx context.Context) ([]*whitelistResolver, error) {
	value := resolver.data.GetWhitelists()
	return resolver.root.wrapWhitelists(value, nil)
}

type policyFieldsResolver struct {
	root *Resolver
	data *storage.PolicyFields
}

func (resolver *Resolver) wrapPolicyFields(value *storage.PolicyFields, ok bool, err error) (*policyFieldsResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &policyFieldsResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPolicyFieldses(values []*storage.PolicyFields, err error) ([]*policyFieldsResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*policyFieldsResolver, len(values))
	for i, v := range values {
		output[i] = &policyFieldsResolver{resolver, v}
	}
	return output, nil
}

func (resolver *policyFieldsResolver) AddCapabilities(ctx context.Context) []string {
	value := resolver.data.GetAddCapabilities()
	return value
}

func (resolver *policyFieldsResolver) Args(ctx context.Context) string {
	value := resolver.data.GetArgs()
	return value
}

func (resolver *policyFieldsResolver) Command(ctx context.Context) string {
	value := resolver.data.GetCommand()
	return value
}

func (resolver *policyFieldsResolver) Component(ctx context.Context) (*componentResolver, error) {
	value := resolver.data.GetComponent()
	return resolver.root.wrapComponent(value, true, nil)
}

func (resolver *policyFieldsResolver) ContainerResourcePolicy(ctx context.Context) (*resourcePolicyResolver, error) {
	value := resolver.data.GetContainerResourcePolicy()
	return resolver.root.wrapResourcePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) Cve(ctx context.Context) string {
	value := resolver.data.GetCve()
	return value
}

func (resolver *policyFieldsResolver) Cvss(ctx context.Context) (*numericalPolicyResolver, error) {
	value := resolver.data.GetCvss()
	return resolver.root.wrapNumericalPolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) Directory(ctx context.Context) string {
	value := resolver.data.GetDirectory()
	return value
}

func (resolver *policyFieldsResolver) DisallowedAnnotation(ctx context.Context) (*keyValuePolicyResolver, error) {
	value := resolver.data.GetDisallowedAnnotation()
	return resolver.root.wrapKeyValuePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) DropCapabilities(ctx context.Context) []string {
	value := resolver.data.GetDropCapabilities()
	return value
}

func (resolver *policyFieldsResolver) Env(ctx context.Context) (*keyValuePolicyResolver, error) {
	value := resolver.data.GetEnv()
	return resolver.root.wrapKeyValuePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) FixedBy(ctx context.Context) string {
	value := resolver.data.GetFixedBy()
	return value
}

func (resolver *policyFieldsResolver) HostMountPolicy(ctx context.Context) (*hostMountPolicyResolver, error) {
	value := resolver.data.GetHostMountPolicy()
	return resolver.root.wrapHostMountPolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) ImageName(ctx context.Context) (*imageNamePolicyResolver, error) {
	value := resolver.data.GetImageName()
	return resolver.root.wrapImageNamePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) LineRule(ctx context.Context) (*dockerfileLineRuleFieldResolver, error) {
	value := resolver.data.GetLineRule()
	return resolver.root.wrapDockerfileLineRuleField(value, true, nil)
}

func (resolver *policyFieldsResolver) PermissionPolicy(ctx context.Context) (*permissionPolicyResolver, error) {
	value := resolver.data.GetPermissionPolicy()
	return resolver.root.wrapPermissionPolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) PortExposurePolicy(ctx context.Context) (*portExposurePolicyResolver, error) {
	value := resolver.data.GetPortExposurePolicy()
	return resolver.root.wrapPortExposurePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) PortPolicy(ctx context.Context) (*portPolicyResolver, error) {
	value := resolver.data.GetPortPolicy()
	return resolver.root.wrapPortPolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) ProcessPolicy(ctx context.Context) (*processPolicyResolver, error) {
	value := resolver.data.GetProcessPolicy()
	return resolver.root.wrapProcessPolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) RequiredAnnotation(ctx context.Context) (*keyValuePolicyResolver, error) {
	value := resolver.data.GetRequiredAnnotation()
	return resolver.root.wrapKeyValuePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) RequiredLabel(ctx context.Context) (*keyValuePolicyResolver, error) {
	value := resolver.data.GetRequiredLabel()
	return resolver.root.wrapKeyValuePolicy(value, true, nil)
}

func (resolver *policyFieldsResolver) User(ctx context.Context) string {
	value := resolver.data.GetUser()
	return value
}

func (resolver *policyFieldsResolver) VolumePolicy(ctx context.Context) (*volumePolicyResolver, error) {
	value := resolver.data.GetVolumePolicy()
	return resolver.root.wrapVolumePolicy(value, true, nil)
}

type policyRuleResolver struct {
	root *Resolver
	data *storage.PolicyRule
}

func (resolver *Resolver) wrapPolicyRule(value *storage.PolicyRule, ok bool, err error) (*policyRuleResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &policyRuleResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPolicyRules(values []*storage.PolicyRule, err error) ([]*policyRuleResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*policyRuleResolver, len(values))
	for i, v := range values {
		output[i] = &policyRuleResolver{resolver, v}
	}
	return output, nil
}

func (resolver *policyRuleResolver) ApiGroups(ctx context.Context) []string {
	value := resolver.data.GetApiGroups()
	return value
}

func (resolver *policyRuleResolver) NonResourceUrls(ctx context.Context) []string {
	value := resolver.data.GetNonResourceUrls()
	return value
}

func (resolver *policyRuleResolver) ResourceNames(ctx context.Context) []string {
	value := resolver.data.GetResourceNames()
	return value
}

func (resolver *policyRuleResolver) Resources(ctx context.Context) []string {
	value := resolver.data.GetResources()
	return value
}

func (resolver *policyRuleResolver) Verbs(ctx context.Context) []string {
	value := resolver.data.GetVerbs()
	return value
}

type portConfigResolver struct {
	root *Resolver
	data *storage.PortConfig
}

func (resolver *Resolver) wrapPortConfig(value *storage.PortConfig, ok bool, err error) (*portConfigResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &portConfigResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPortConfigs(values []*storage.PortConfig, err error) ([]*portConfigResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*portConfigResolver, len(values))
	for i, v := range values {
		output[i] = &portConfigResolver{resolver, v}
	}
	return output, nil
}

func (resolver *portConfigResolver) ContainerPort(ctx context.Context) int32 {
	value := resolver.data.GetContainerPort()
	return value
}

func (resolver *portConfigResolver) ExposedPort(ctx context.Context) int32 {
	value := resolver.data.GetExposedPort()
	return value
}

func (resolver *portConfigResolver) Exposure(ctx context.Context) string {
	value := resolver.data.GetExposure()
	return value.String()
}

func (resolver *portConfigResolver) ExposureInfos(ctx context.Context) ([]*portConfig_ExposureInfoResolver, error) {
	value := resolver.data.GetExposureInfos()
	return resolver.root.wrapPortConfig_ExposureInfos(value, nil)
}

func (resolver *portConfigResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *portConfigResolver) Protocol(ctx context.Context) string {
	value := resolver.data.GetProtocol()
	return value
}

type portConfig_ExposureInfoResolver struct {
	root *Resolver
	data *storage.PortConfig_ExposureInfo
}

func (resolver *Resolver) wrapPortConfig_ExposureInfo(value *storage.PortConfig_ExposureInfo, ok bool, err error) (*portConfig_ExposureInfoResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &portConfig_ExposureInfoResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPortConfig_ExposureInfos(values []*storage.PortConfig_ExposureInfo, err error) ([]*portConfig_ExposureInfoResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*portConfig_ExposureInfoResolver, len(values))
	for i, v := range values {
		output[i] = &portConfig_ExposureInfoResolver{resolver, v}
	}
	return output, nil
}

func (resolver *portConfig_ExposureInfoResolver) ExternalHostnames(ctx context.Context) []string {
	value := resolver.data.GetExternalHostnames()
	return value
}

func (resolver *portConfig_ExposureInfoResolver) ExternalIps(ctx context.Context) []string {
	value := resolver.data.GetExternalIps()
	return value
}

func (resolver *portConfig_ExposureInfoResolver) Level(ctx context.Context) string {
	value := resolver.data.GetLevel()
	return value.String()
}

func (resolver *portConfig_ExposureInfoResolver) NodePort(ctx context.Context) int32 {
	value := resolver.data.GetNodePort()
	return value
}

func (resolver *portConfig_ExposureInfoResolver) ServiceClusterIp(ctx context.Context) string {
	value := resolver.data.GetServiceClusterIp()
	return value
}

func (resolver *portConfig_ExposureInfoResolver) ServiceId(ctx context.Context) string {
	value := resolver.data.GetServiceId()
	return value
}

func (resolver *portConfig_ExposureInfoResolver) ServiceName(ctx context.Context) string {
	value := resolver.data.GetServiceName()
	return value
}

func (resolver *portConfig_ExposureInfoResolver) ServicePort(ctx context.Context) int32 {
	value := resolver.data.GetServicePort()
	return value
}

func toPortConfig_ExposureLevel(value *string) storage.PortConfig_ExposureLevel {
	if value != nil {
		return storage.PortConfig_ExposureLevel(storage.PortConfig_ExposureLevel_value[*value])
	}
	return storage.PortConfig_ExposureLevel(0)
}

func toPortConfig_ExposureLevels(values *[]string) []storage.PortConfig_ExposureLevel {
	if values == nil {
		return nil
	}
	output := make([]storage.PortConfig_ExposureLevel, len(*values))
	for i, v := range *values {
		output[i] = toPortConfig_ExposureLevel(&v)
	}
	return output
}

type portExposurePolicyResolver struct {
	root *Resolver
	data *storage.PortExposurePolicy
}

func (resolver *Resolver) wrapPortExposurePolicy(value *storage.PortExposurePolicy, ok bool, err error) (*portExposurePolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &portExposurePolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPortExposurePolicies(values []*storage.PortExposurePolicy, err error) ([]*portExposurePolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*portExposurePolicyResolver, len(values))
	for i, v := range values {
		output[i] = &portExposurePolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *portExposurePolicyResolver) ExposureLevels(ctx context.Context) []string {
	value := resolver.data.GetExposureLevels()
	return stringSlice(value)
}

type portPolicyResolver struct {
	root *Resolver
	data *storage.PortPolicy
}

func (resolver *Resolver) wrapPortPolicy(value *storage.PortPolicy, ok bool, err error) (*portPolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &portPolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapPortPolicies(values []*storage.PortPolicy, err error) ([]*portPolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*portPolicyResolver, len(values))
	for i, v := range values {
		output[i] = &portPolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *portPolicyResolver) Port(ctx context.Context) int32 {
	value := resolver.data.GetPort()
	return value
}

func (resolver *portPolicyResolver) Protocol(ctx context.Context) string {
	value := resolver.data.GetProtocol()
	return value
}

type processGroupResolver struct {
	root *Resolver
	data *v1.ProcessGroup
}

func (resolver *Resolver) wrapProcessGroup(value *v1.ProcessGroup, ok bool, err error) (*processGroupResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &processGroupResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapProcessGroups(values []*v1.ProcessGroup, err error) ([]*processGroupResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*processGroupResolver, len(values))
	for i, v := range values {
		output[i] = &processGroupResolver{resolver, v}
	}
	return output, nil
}

func (resolver *processGroupResolver) Args(ctx context.Context) string {
	value := resolver.data.GetArgs()
	return value
}

func (resolver *processGroupResolver) Signals(ctx context.Context) ([]*processIndicatorResolver, error) {
	value := resolver.data.GetSignals()
	return resolver.root.wrapProcessIndicators(value, nil)
}

type processIndicatorResolver struct {
	root *Resolver
	data *storage.ProcessIndicator
}

func (resolver *Resolver) wrapProcessIndicator(value *storage.ProcessIndicator, ok bool, err error) (*processIndicatorResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &processIndicatorResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapProcessIndicators(values []*storage.ProcessIndicator, err error) ([]*processIndicatorResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*processIndicatorResolver, len(values))
	for i, v := range values {
		output[i] = &processIndicatorResolver{resolver, v}
	}
	return output, nil
}

func (resolver *processIndicatorResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *processIndicatorResolver) ContainerName(ctx context.Context) string {
	value := resolver.data.GetContainerName()
	return value
}

func (resolver *processIndicatorResolver) ContainerStartTime(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetContainerStartTime()
	return timestamp(value)
}

func (resolver *processIndicatorResolver) DeploymentId(ctx context.Context) string {
	value := resolver.data.GetDeploymentId()
	return value
}

func (resolver *processIndicatorResolver) DeploymentStateTs(ctx context.Context) int32 {
	value := resolver.data.GetDeploymentStateTs()
	return int32(value)
}

func (resolver *processIndicatorResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *processIndicatorResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	return value
}

func (resolver *processIndicatorResolver) PodId(ctx context.Context) string {
	value := resolver.data.GetPodId()
	return value
}

func (resolver *processIndicatorResolver) Signal(ctx context.Context) (*processSignalResolver, error) {
	value := resolver.data.GetSignal()
	return resolver.root.wrapProcessSignal(value, true, nil)
}

type processNameGroupResolver struct {
	root *Resolver
	data *v1.ProcessNameGroup
}

func (resolver *Resolver) wrapProcessNameGroup(value *v1.ProcessNameGroup, ok bool, err error) (*processNameGroupResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &processNameGroupResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapProcessNameGroups(values []*v1.ProcessNameGroup, err error) ([]*processNameGroupResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*processNameGroupResolver, len(values))
	for i, v := range values {
		output[i] = &processNameGroupResolver{resolver, v}
	}
	return output, nil
}

func (resolver *processNameGroupResolver) Groups(ctx context.Context) ([]*processGroupResolver, error) {
	value := resolver.data.GetGroups()
	return resolver.root.wrapProcessGroups(value, nil)
}

func (resolver *processNameGroupResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *processNameGroupResolver) TimesExecuted(ctx context.Context) int32 {
	value := resolver.data.GetTimesExecuted()
	return int32(value)
}

type processPolicyResolver struct {
	root *Resolver
	data *storage.ProcessPolicy
}

func (resolver *Resolver) wrapProcessPolicy(value *storage.ProcessPolicy, ok bool, err error) (*processPolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &processPolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapProcessPolicies(values []*storage.ProcessPolicy, err error) ([]*processPolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*processPolicyResolver, len(values))
	for i, v := range values {
		output[i] = &processPolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *processPolicyResolver) Ancestor(ctx context.Context) string {
	value := resolver.data.GetAncestor()
	return value
}

func (resolver *processPolicyResolver) Args(ctx context.Context) string {
	value := resolver.data.GetArgs()
	return value
}

func (resolver *processPolicyResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *processPolicyResolver) Uid(ctx context.Context) string {
	value := resolver.data.GetUid()
	return value
}

type processSignalResolver struct {
	root *Resolver
	data *storage.ProcessSignal
}

func (resolver *Resolver) wrapProcessSignal(value *storage.ProcessSignal, ok bool, err error) (*processSignalResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &processSignalResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapProcessSignals(values []*storage.ProcessSignal, err error) ([]*processSignalResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*processSignalResolver, len(values))
	for i, v := range values {
		output[i] = &processSignalResolver{resolver, v}
	}
	return output, nil
}

func (resolver *processSignalResolver) Args(ctx context.Context) string {
	value := resolver.data.GetArgs()
	return value
}

func (resolver *processSignalResolver) ContainerId(ctx context.Context) string {
	value := resolver.data.GetContainerId()
	return value
}

func (resolver *processSignalResolver) ExecFilePath(ctx context.Context) string {
	value := resolver.data.GetExecFilePath()
	return value
}

func (resolver *processSignalResolver) Gid(ctx context.Context) int32 {
	value := resolver.data.GetGid()
	return int32(value)
}

func (resolver *processSignalResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *processSignalResolver) Lineage(ctx context.Context) []string {
	value := resolver.data.GetLineage()
	return value
}

func (resolver *processSignalResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *processSignalResolver) Pid(ctx context.Context) int32 {
	value := resolver.data.GetPid()
	return int32(value)
}

func (resolver *processSignalResolver) Time(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetTime()
	return timestamp(value)
}

func (resolver *processSignalResolver) Uid(ctx context.Context) int32 {
	value := resolver.data.GetUid()
	return int32(value)
}

type providerMetadataResolver struct {
	root *Resolver
	data *storage.ProviderMetadata
}

func (resolver *Resolver) wrapProviderMetadata(value *storage.ProviderMetadata, ok bool, err error) (*providerMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &providerMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapProviderMetadatas(values []*storage.ProviderMetadata, err error) ([]*providerMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*providerMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &providerMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *providerMetadataResolver) Region(ctx context.Context) string {
	value := resolver.data.GetRegion()
	return value
}

func (resolver *providerMetadataResolver) Verified(ctx context.Context) bool {
	value := resolver.data.GetVerified()
	return value
}

func (resolver *providerMetadataResolver) Zone(ctx context.Context) string {
	value := resolver.data.GetZone()
	return value
}

type providerMetadataProviderResolver struct {
	resolver interface{}
}

func (resolver *providerMetadataResolver) Provider() *providerMetadataProviderResolver {
	if val := resolver.data.GetGoogle(); val != nil {
		return &providerMetadataProviderResolver{
			resolver: &googleProviderMetadataResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetAws(); val != nil {
		return &providerMetadataProviderResolver{
			resolver: &aWSProviderMetadataResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetAzure(); val != nil {
		return &providerMetadataProviderResolver{
			resolver: &azureProviderMetadataResolver{resolver.root, val},
		}
	}
	return nil
}

func (resolver *providerMetadataProviderResolver) ToGoogleProviderMetadata() (*googleProviderMetadataResolver, bool) {
	res, ok := resolver.resolver.(*googleProviderMetadataResolver)
	return res, ok
}

func (resolver *providerMetadataProviderResolver) ToAWSProviderMetadata() (*aWSProviderMetadataResolver, bool) {
	res, ok := resolver.resolver.(*aWSProviderMetadataResolver)
	return res, ok
}

func (resolver *providerMetadataProviderResolver) ToAzureProviderMetadata() (*azureProviderMetadataResolver, bool) {
	res, ok := resolver.resolver.(*azureProviderMetadataResolver)
	return res, ok
}

type resourcePolicyResolver struct {
	root *Resolver
	data *storage.ResourcePolicy
}

func (resolver *Resolver) wrapResourcePolicy(value *storage.ResourcePolicy, ok bool, err error) (*resourcePolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &resourcePolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapResourcePolicies(values []*storage.ResourcePolicy, err error) ([]*resourcePolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*resourcePolicyResolver, len(values))
	for i, v := range values {
		output[i] = &resourcePolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *resourcePolicyResolver) CpuResourceLimit(ctx context.Context) (*numericalPolicyResolver, error) {
	value := resolver.data.GetCpuResourceLimit()
	return resolver.root.wrapNumericalPolicy(value, true, nil)
}

func (resolver *resourcePolicyResolver) CpuResourceRequest(ctx context.Context) (*numericalPolicyResolver, error) {
	value := resolver.data.GetCpuResourceRequest()
	return resolver.root.wrapNumericalPolicy(value, true, nil)
}

func (resolver *resourcePolicyResolver) MemoryResourceLimit(ctx context.Context) (*numericalPolicyResolver, error) {
	value := resolver.data.GetMemoryResourceLimit()
	return resolver.root.wrapNumericalPolicy(value, true, nil)
}

func (resolver *resourcePolicyResolver) MemoryResourceRequest(ctx context.Context) (*numericalPolicyResolver, error) {
	value := resolver.data.GetMemoryResourceRequest()
	return resolver.root.wrapNumericalPolicy(value, true, nil)
}

type resourcesResolver struct {
	root *Resolver
	data *storage.Resources
}

func (resolver *Resolver) wrapResources(value *storage.Resources, ok bool, err error) (*resourcesResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &resourcesResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapResourceses(values []*storage.Resources, err error) ([]*resourcesResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*resourcesResolver, len(values))
	for i, v := range values {
		output[i] = &resourcesResolver{resolver, v}
	}
	return output, nil
}

func (resolver *resourcesResolver) CpuCoresLimit(ctx context.Context) float64 {
	value := resolver.data.GetCpuCoresLimit()
	return float64(value)
}

func (resolver *resourcesResolver) CpuCoresRequest(ctx context.Context) float64 {
	value := resolver.data.GetCpuCoresRequest()
	return float64(value)
}

func (resolver *resourcesResolver) MemoryMbLimit(ctx context.Context) float64 {
	value := resolver.data.GetMemoryMbLimit()
	return float64(value)
}

func (resolver *resourcesResolver) MemoryMbRequest(ctx context.Context) float64 {
	value := resolver.data.GetMemoryMbRequest()
	return float64(value)
}

type riskResolver struct {
	root *Resolver
	data *storage.Risk
}

func (resolver *Resolver) wrapRisk(value *storage.Risk, ok bool, err error) (*riskResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &riskResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapRisks(values []*storage.Risk, err error) ([]*riskResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*riskResolver, len(values))
	for i, v := range values {
		output[i] = &riskResolver{resolver, v}
	}
	return output, nil
}

func (resolver *riskResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *riskResolver) Results(ctx context.Context) ([]*risk_ResultResolver, error) {
	value := resolver.data.GetResults()
	return resolver.root.wrapRisk_Results(value, nil)
}

func (resolver *riskResolver) Score(ctx context.Context) float64 {
	value := resolver.data.GetScore()
	return float64(value)
}

func (resolver *riskResolver) Subject(ctx context.Context) (*riskSubjectResolver, error) {
	value := resolver.data.GetSubject()
	return resolver.root.wrapRiskSubject(value, true, nil)
}

type riskSubjectResolver struct {
	root *Resolver
	data *storage.RiskSubject
}

func (resolver *Resolver) wrapRiskSubject(value *storage.RiskSubject, ok bool, err error) (*riskSubjectResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &riskSubjectResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapRiskSubjects(values []*storage.RiskSubject, err error) ([]*riskSubjectResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*riskSubjectResolver, len(values))
	for i, v := range values {
		output[i] = &riskSubjectResolver{resolver, v}
	}
	return output, nil
}

func (resolver *riskSubjectResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *riskSubjectResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *riskSubjectResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	return value
}

func (resolver *riskSubjectResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value.String()
}

func toRiskSubjectType(value *string) storage.RiskSubjectType {
	if value != nil {
		return storage.RiskSubjectType(storage.RiskSubjectType_value[*value])
	}
	return storage.RiskSubjectType(0)
}

func toRiskSubjectTypes(values *[]string) []storage.RiskSubjectType {
	if values == nil {
		return nil
	}
	output := make([]storage.RiskSubjectType, len(*values))
	for i, v := range *values {
		output[i] = toRiskSubjectType(&v)
	}
	return output
}

type risk_ResultResolver struct {
	root *Resolver
	data *storage.Risk_Result
}

func (resolver *Resolver) wrapRisk_Result(value *storage.Risk_Result, ok bool, err error) (*risk_ResultResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &risk_ResultResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapRisk_Results(values []*storage.Risk_Result, err error) ([]*risk_ResultResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*risk_ResultResolver, len(values))
	for i, v := range values {
		output[i] = &risk_ResultResolver{resolver, v}
	}
	return output, nil
}

func (resolver *risk_ResultResolver) Factors(ctx context.Context) ([]*risk_Result_FactorResolver, error) {
	value := resolver.data.GetFactors()
	return resolver.root.wrapRisk_Result_Factors(value, nil)
}

func (resolver *risk_ResultResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *risk_ResultResolver) Score(ctx context.Context) float64 {
	value := resolver.data.GetScore()
	return float64(value)
}

type risk_Result_FactorResolver struct {
	root *Resolver
	data *storage.Risk_Result_Factor
}

func (resolver *Resolver) wrapRisk_Result_Factor(value *storage.Risk_Result_Factor, ok bool, err error) (*risk_Result_FactorResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &risk_Result_FactorResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapRisk_Result_Factors(values []*storage.Risk_Result_Factor, err error) ([]*risk_Result_FactorResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*risk_Result_FactorResolver, len(values))
	for i, v := range values {
		output[i] = &risk_Result_FactorResolver{resolver, v}
	}
	return output, nil
}

func (resolver *risk_Result_FactorResolver) Message(ctx context.Context) string {
	value := resolver.data.GetMessage()
	return value
}

func (resolver *risk_Result_FactorResolver) Url(ctx context.Context) string {
	value := resolver.data.GetUrl()
	return value
}

type roleResolver struct {
	root *Resolver
	data *storage.Role
}

func (resolver *Resolver) wrapRole(value *storage.Role, ok bool, err error) (*roleResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &roleResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapRoles(values []*storage.Role, err error) ([]*roleResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*roleResolver, len(values))
	for i, v := range values {
		output[i] = &roleResolver{resolver, v}
	}
	return output, nil
}

func (resolver *roleResolver) GlobalAccess(ctx context.Context) string {
	value := resolver.data.GetGlobalAccess()
	return value.String()
}

func (resolver *roleResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

type scopeResolver struct {
	root *Resolver
	data *storage.Scope
}

func (resolver *Resolver) wrapScope(value *storage.Scope, ok bool, err error) (*scopeResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &scopeResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapScopes(values []*storage.Scope, err error) ([]*scopeResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*scopeResolver, len(values))
	for i, v := range values {
		output[i] = &scopeResolver{resolver, v}
	}
	return output, nil
}

func (resolver *scopeResolver) Cluster(ctx context.Context) string {
	value := resolver.data.GetCluster()
	return value
}

func (resolver *scopeResolver) Label(ctx context.Context) (*scope_LabelResolver, error) {
	value := resolver.data.GetLabel()
	return resolver.root.wrapScope_Label(value, true, nil)
}

func (resolver *scopeResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	return value
}

type scope_LabelResolver struct {
	root *Resolver
	data *storage.Scope_Label
}

func (resolver *Resolver) wrapScope_Label(value *storage.Scope_Label, ok bool, err error) (*scope_LabelResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &scope_LabelResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapScope_Labels(values []*storage.Scope_Label, err error) ([]*scope_LabelResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*scope_LabelResolver, len(values))
	for i, v := range values {
		output[i] = &scope_LabelResolver{resolver, v}
	}
	return output, nil
}

func (resolver *scope_LabelResolver) Key(ctx context.Context) string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *scope_LabelResolver) Value(ctx context.Context) string {
	value := resolver.data.GetValue()
	return value
}

func toSearchCategory(value *string) v1.SearchCategory {
	if value != nil {
		return v1.SearchCategory(v1.SearchCategory_value[*value])
	}
	return v1.SearchCategory(0)
}

func toSearchCategories(values *[]string) []v1.SearchCategory {
	if values == nil {
		return nil
	}
	output := make([]v1.SearchCategory, len(*values))
	for i, v := range *values {
		output[i] = toSearchCategory(&v)
	}
	return output
}

type searchResultResolver struct {
	root *Resolver
	data *v1.SearchResult
}

func (resolver *Resolver) wrapSearchResult(value *v1.SearchResult, ok bool, err error) (*searchResultResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &searchResultResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSearchResults(values []*v1.SearchResult, err error) ([]*searchResultResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*searchResultResolver, len(values))
	for i, v := range values {
		output[i] = &searchResultResolver{resolver, v}
	}
	return output, nil
}

func (resolver *searchResultResolver) Category(ctx context.Context) string {
	value := resolver.data.GetCategory()
	return value.String()
}

func (resolver *searchResultResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *searchResultResolver) Location(ctx context.Context) string {
	value := resolver.data.GetLocation()
	return value
}

func (resolver *searchResultResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *searchResultResolver) Score(ctx context.Context) float64 {
	value := resolver.data.GetScore()
	return value
}

type secretResolver struct {
	root *Resolver
	data *storage.Secret
	list *storage.ListSecret
}

func (resolver *Resolver) wrapSecret(value *storage.Secret, ok bool, err error) (*secretResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &secretResolver{resolver, value, nil}, nil
}

func (resolver *Resolver) wrapSecrets(values []*storage.Secret, err error) ([]*secretResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*secretResolver, len(values))
	for i, v := range values {
		output[i] = &secretResolver{resolver, v, nil}
	}
	return output, nil
}

func (resolver *Resolver) wrapListSecrets(values []*storage.ListSecret, err error) ([]*secretResolver, error) {
	if err != nil || values == nil {
		return nil, err
	}
	output := make([]*secretResolver, len(values))
	for i, v := range values {
		output[i] = &secretResolver{resolver, nil, v}
	}
	return output, nil
}

func (resolver *secretResolver) ensureData(ctx context.Context) {
	if resolver.data == nil {
		resolver.data = resolver.root.getSecret(ctx, resolver.list.GetId())
	}
}

func (resolver *secretResolver) Annotations(ctx context.Context) labels {
	resolver.ensureData(ctx)
	value := resolver.data.GetAnnotations()
	return labelsResolver(value)
}

func (resolver *secretResolver) ClusterId(ctx context.Context) string {
	resolver.ensureData(ctx)
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *secretResolver) ClusterName(ctx context.Context) string {
	value := resolver.data.GetClusterName()
	if resolver.data == nil {
		value = resolver.list.GetClusterName()
	}
	return value
}

func (resolver *secretResolver) CreatedAt(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetCreatedAt()
	if resolver.data == nil {
		value = resolver.list.GetCreatedAt()
	}
	return timestamp(value)
}

func (resolver *secretResolver) Files(ctx context.Context) ([]*secretDataFileResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetFiles()
	return resolver.root.wrapSecretDataFiles(value, nil)
}

func (resolver *secretResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	if resolver.data == nil {
		value = resolver.list.GetId()
	}
	return graphql.ID(value)
}

func (resolver *secretResolver) Labels(ctx context.Context) labels {
	resolver.ensureData(ctx)
	value := resolver.data.GetLabels()
	return labelsResolver(value)
}

func (resolver *secretResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	if resolver.data == nil {
		value = resolver.list.GetName()
	}
	return value
}

func (resolver *secretResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	if resolver.data == nil {
		value = resolver.list.GetNamespace()
	}
	return value
}

func (resolver *secretResolver) Relationship(ctx context.Context) (*secretRelationshipResolver, error) {
	resolver.ensureData(ctx)
	value := resolver.data.GetRelationship()
	return resolver.root.wrapSecretRelationship(value, true, nil)
}

func (resolver *secretResolver) Type(ctx context.Context) string {
	resolver.ensureData(ctx)
	value := resolver.data.GetType()
	return value
}

type secretContainerRelationshipResolver struct {
	root *Resolver
	data *storage.SecretContainerRelationship
}

func (resolver *Resolver) wrapSecretContainerRelationship(value *storage.SecretContainerRelationship, ok bool, err error) (*secretContainerRelationshipResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &secretContainerRelationshipResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecretContainerRelationships(values []*storage.SecretContainerRelationship, err error) ([]*secretContainerRelationshipResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*secretContainerRelationshipResolver, len(values))
	for i, v := range values {
		output[i] = &secretContainerRelationshipResolver{resolver, v}
	}
	return output, nil
}

func (resolver *secretContainerRelationshipResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *secretContainerRelationshipResolver) Path(ctx context.Context) string {
	value := resolver.data.GetPath()
	return value
}

type secretDataFileResolver struct {
	root *Resolver
	data *storage.SecretDataFile
}

func (resolver *Resolver) wrapSecretDataFile(value *storage.SecretDataFile, ok bool, err error) (*secretDataFileResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &secretDataFileResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecretDataFiles(values []*storage.SecretDataFile, err error) ([]*secretDataFileResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*secretDataFileResolver, len(values))
	for i, v := range values {
		output[i] = &secretDataFileResolver{resolver, v}
	}
	return output, nil
}

func (resolver *secretDataFileResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *secretDataFileResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value.String()
}

type secretDataFileMetadataResolver struct {
	resolver interface{}
}

func (resolver *secretDataFileResolver) Metadata() *secretDataFileMetadataResolver {
	if val := resolver.data.GetCert(); val != nil {
		return &secretDataFileMetadataResolver{
			resolver: &certResolver{resolver.root, val},
		}
	}
	if val := resolver.data.GetImagePullSecret(); val != nil {
		return &secretDataFileMetadataResolver{
			resolver: &imagePullSecretResolver{resolver.root, val},
		}
	}
	return nil
}

func (resolver *secretDataFileMetadataResolver) ToCert() (*certResolver, bool) {
	res, ok := resolver.resolver.(*certResolver)
	return res, ok
}

func (resolver *secretDataFileMetadataResolver) ToImagePullSecret() (*imagePullSecretResolver, bool) {
	res, ok := resolver.resolver.(*imagePullSecretResolver)
	return res, ok
}

type secretDeploymentRelationshipResolver struct {
	root *Resolver
	data *storage.SecretDeploymentRelationship
}

func (resolver *Resolver) wrapSecretDeploymentRelationship(value *storage.SecretDeploymentRelationship, ok bool, err error) (*secretDeploymentRelationshipResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &secretDeploymentRelationshipResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecretDeploymentRelationships(values []*storage.SecretDeploymentRelationship, err error) ([]*secretDeploymentRelationshipResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*secretDeploymentRelationshipResolver, len(values))
	for i, v := range values {
		output[i] = &secretDeploymentRelationshipResolver{resolver, v}
	}
	return output, nil
}

func (resolver *secretDeploymentRelationshipResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *secretDeploymentRelationshipResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

type secretRelationshipResolver struct {
	root *Resolver
	data *storage.SecretRelationship
}

func (resolver *Resolver) wrapSecretRelationship(value *storage.SecretRelationship, ok bool, err error) (*secretRelationshipResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &secretRelationshipResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecretRelationships(values []*storage.SecretRelationship, err error) ([]*secretRelationshipResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*secretRelationshipResolver, len(values))
	for i, v := range values {
		output[i] = &secretRelationshipResolver{resolver, v}
	}
	return output, nil
}

func (resolver *secretRelationshipResolver) ContainerRelationships(ctx context.Context) ([]*secretContainerRelationshipResolver, error) {
	value := resolver.data.GetContainerRelationships()
	return resolver.root.wrapSecretContainerRelationships(value, nil)
}

func (resolver *secretRelationshipResolver) DeploymentRelationships(ctx context.Context) ([]*secretDeploymentRelationshipResolver, error) {
	value := resolver.data.GetDeploymentRelationships()
	return resolver.root.wrapSecretDeploymentRelationships(value, nil)
}

func (resolver *secretRelationshipResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func toSecretType(value *string) storage.SecretType {
	if value != nil {
		return storage.SecretType(storage.SecretType_value[*value])
	}
	return storage.SecretType(0)
}

func toSecretTypes(values *[]string) []storage.SecretType {
	if values == nil {
		return nil
	}
	output := make([]storage.SecretType, len(*values))
	for i, v := range *values {
		output[i] = toSecretType(&v)
	}
	return output
}

type securityContextResolver struct {
	root *Resolver
	data *storage.SecurityContext
}

func (resolver *Resolver) wrapSecurityContext(value *storage.SecurityContext, ok bool, err error) (*securityContextResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &securityContextResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecurityContexts(values []*storage.SecurityContext, err error) ([]*securityContextResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*securityContextResolver, len(values))
	for i, v := range values {
		output[i] = &securityContextResolver{resolver, v}
	}
	return output, nil
}

func (resolver *securityContextResolver) AddCapabilities(ctx context.Context) []string {
	value := resolver.data.GetAddCapabilities()
	return value
}

func (resolver *securityContextResolver) DropCapabilities(ctx context.Context) []string {
	value := resolver.data.GetDropCapabilities()
	return value
}

func (resolver *securityContextResolver) Privileged(ctx context.Context) bool {
	value := resolver.data.GetPrivileged()
	return value
}

func (resolver *securityContextResolver) ReadOnlyRootFilesystem(ctx context.Context) bool {
	value := resolver.data.GetReadOnlyRootFilesystem()
	return value
}

func (resolver *securityContextResolver) Selinux(ctx context.Context) (*securityContext_SELinuxResolver, error) {
	value := resolver.data.GetSelinux()
	return resolver.root.wrapSecurityContext_SELinux(value, true, nil)
}

type securityContext_SELinuxResolver struct {
	root *Resolver
	data *storage.SecurityContext_SELinux
}

func (resolver *Resolver) wrapSecurityContext_SELinux(value *storage.SecurityContext_SELinux, ok bool, err error) (*securityContext_SELinuxResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &securityContext_SELinuxResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSecurityContext_SELinuxs(values []*storage.SecurityContext_SELinux, err error) ([]*securityContext_SELinuxResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*securityContext_SELinuxResolver, len(values))
	for i, v := range values {
		output[i] = &securityContext_SELinuxResolver{resolver, v}
	}
	return output, nil
}

func (resolver *securityContext_SELinuxResolver) Level(ctx context.Context) string {
	value := resolver.data.GetLevel()
	return value
}

func (resolver *securityContext_SELinuxResolver) Role(ctx context.Context) string {
	value := resolver.data.GetRole()
	return value
}

func (resolver *securityContext_SELinuxResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value
}

func (resolver *securityContext_SELinuxResolver) User(ctx context.Context) string {
	value := resolver.data.GetUser()
	return value
}

type serviceAccountResolver struct {
	root *Resolver
	data *storage.ServiceAccount
}

func (resolver *Resolver) wrapServiceAccount(value *storage.ServiceAccount, ok bool, err error) (*serviceAccountResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &serviceAccountResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapServiceAccounts(values []*storage.ServiceAccount, err error) ([]*serviceAccountResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*serviceAccountResolver, len(values))
	for i, v := range values {
		output[i] = &serviceAccountResolver{resolver, v}
	}
	return output, nil
}

func (resolver *serviceAccountResolver) Annotations(ctx context.Context) labels {
	value := resolver.data.GetAnnotations()
	return labelsResolver(value)
}

func (resolver *serviceAccountResolver) AutomountToken(ctx context.Context) bool {
	value := resolver.data.GetAutomountToken()
	return value
}

func (resolver *serviceAccountResolver) ClusterId(ctx context.Context) string {
	value := resolver.data.GetClusterId()
	return value
}

func (resolver *serviceAccountResolver) ClusterName(ctx context.Context) string {
	value := resolver.data.GetClusterName()
	return value
}

func (resolver *serviceAccountResolver) CreatedAt(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetCreatedAt()
	return timestamp(value)
}

func (resolver *serviceAccountResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *serviceAccountResolver) ImagePullSecrets(ctx context.Context) []string {
	value := resolver.data.GetImagePullSecrets()
	return value
}

func (resolver *serviceAccountResolver) Labels(ctx context.Context) labels {
	value := resolver.data.GetLabels()
	return labelsResolver(value)
}

func (resolver *serviceAccountResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *serviceAccountResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	return value
}

func (resolver *serviceAccountResolver) Secrets(ctx context.Context) []string {
	value := resolver.data.GetSecrets()
	return value
}

func toSeverity(value *string) storage.Severity {
	if value != nil {
		return storage.Severity(storage.Severity_value[*value])
	}
	return storage.Severity(0)
}

func toSeverities(values *[]string) []storage.Severity {
	if values == nil {
		return nil
	}
	output := make([]storage.Severity, len(*values))
	for i, v := range *values {
		output[i] = toSeverity(&v)
	}
	return output
}

type splunkResolver struct {
	root *Resolver
	data *storage.Splunk
}

func (resolver *Resolver) wrapSplunk(value *storage.Splunk, ok bool, err error) (*splunkResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &splunkResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSplunks(values []*storage.Splunk, err error) ([]*splunkResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*splunkResolver, len(values))
	for i, v := range values {
		output[i] = &splunkResolver{resolver, v}
	}
	return output, nil
}

func (resolver *splunkResolver) AuditLoggingEnabled(ctx context.Context) bool {
	value := resolver.data.GetAuditLoggingEnabled()
	return value
}

func (resolver *splunkResolver) HttpEndpoint(ctx context.Context) string {
	value := resolver.data.GetHttpEndpoint()
	return value
}

func (resolver *splunkResolver) HttpToken(ctx context.Context) string {
	value := resolver.data.GetHttpToken()
	return value
}

func (resolver *splunkResolver) Insecure(ctx context.Context) bool {
	value := resolver.data.GetInsecure()
	return value
}

func (resolver *splunkResolver) Truncate(ctx context.Context) int32 {
	value := resolver.data.GetTruncate()
	return int32(value)
}

type subjectResolver struct {
	root *Resolver
	data *storage.Subject
}

func (resolver *Resolver) wrapSubject(value *storage.Subject, ok bool, err error) (*subjectResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &subjectResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSubjects(values []*storage.Subject, err error) ([]*subjectResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*subjectResolver, len(values))
	for i, v := range values {
		output[i] = &subjectResolver{resolver, v}
	}
	return output, nil
}

func (resolver *subjectResolver) Kind(ctx context.Context) string {
	value := resolver.data.GetKind()
	return value.String()
}

func (resolver *subjectResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *subjectResolver) Namespace(ctx context.Context) string {
	value := resolver.data.GetNamespace()
	return value
}

func toSubjectKind(value *string) storage.SubjectKind {
	if value != nil {
		return storage.SubjectKind(storage.SubjectKind_value[*value])
	}
	return storage.SubjectKind(0)
}

func toSubjectKinds(values *[]string) []storage.SubjectKind {
	if values == nil {
		return nil
	}
	output := make([]storage.SubjectKind, len(*values))
	for i, v := range *values {
		output[i] = toSubjectKind(&v)
	}
	return output
}

type sumoLogicResolver struct {
	root *Resolver
	data *storage.SumoLogic
}

func (resolver *Resolver) wrapSumoLogic(value *storage.SumoLogic, ok bool, err error) (*sumoLogicResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &sumoLogicResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapSumoLogics(values []*storage.SumoLogic, err error) ([]*sumoLogicResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*sumoLogicResolver, len(values))
	for i, v := range values {
		output[i] = &sumoLogicResolver{resolver, v}
	}
	return output, nil
}

func (resolver *sumoLogicResolver) HttpSourceAddress(ctx context.Context) string {
	value := resolver.data.GetHttpSourceAddress()
	return value
}

func (resolver *sumoLogicResolver) SkipTLSVerify(ctx context.Context) bool {
	value := resolver.data.GetSkipTLSVerify()
	return value
}

type taintResolver struct {
	root *Resolver
	data *storage.Taint
}

func (resolver *Resolver) wrapTaint(value *storage.Taint, ok bool, err error) (*taintResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &taintResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapTaints(values []*storage.Taint, err error) ([]*taintResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*taintResolver, len(values))
	for i, v := range values {
		output[i] = &taintResolver{resolver, v}
	}
	return output, nil
}

func (resolver *taintResolver) Key(ctx context.Context) string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *taintResolver) TaintEffect(ctx context.Context) string {
	value := resolver.data.GetTaintEffect()
	return value.String()
}

func (resolver *taintResolver) Value(ctx context.Context) string {
	value := resolver.data.GetValue()
	return value
}

func toTaintEffect(value *string) storage.TaintEffect {
	if value != nil {
		return storage.TaintEffect(storage.TaintEffect_value[*value])
	}
	return storage.TaintEffect(0)
}

func toTaintEffects(values *[]string) []storage.TaintEffect {
	if values == nil {
		return nil
	}
	output := make([]storage.TaintEffect, len(*values))
	for i, v := range *values {
		output[i] = toTaintEffect(&v)
	}
	return output
}

type tokenMetadataResolver struct {
	root *Resolver
	data *storage.TokenMetadata
}

func (resolver *Resolver) wrapTokenMetadata(value *storage.TokenMetadata, ok bool, err error) (*tokenMetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &tokenMetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapTokenMetadatas(values []*storage.TokenMetadata, err error) ([]*tokenMetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*tokenMetadataResolver, len(values))
	for i, v := range values {
		output[i] = &tokenMetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *tokenMetadataResolver) Expiration(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetExpiration()
	return timestamp(value)
}

func (resolver *tokenMetadataResolver) Id(ctx context.Context) graphql.ID {
	value := resolver.data.GetId()
	return graphql.ID(value)
}

func (resolver *tokenMetadataResolver) IssuedAt(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetIssuedAt()
	return timestamp(value)
}

func (resolver *tokenMetadataResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *tokenMetadataResolver) Revoked(ctx context.Context) bool {
	value := resolver.data.GetRevoked()
	return value
}

func (resolver *tokenMetadataResolver) Role(ctx context.Context) string {
	value := resolver.data.GetRole()
	return value
}

type tolerationResolver struct {
	root *Resolver
	data *storage.Toleration
}

func (resolver *Resolver) wrapToleration(value *storage.Toleration, ok bool, err error) (*tolerationResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &tolerationResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapTolerations(values []*storage.Toleration, err error) ([]*tolerationResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*tolerationResolver, len(values))
	for i, v := range values {
		output[i] = &tolerationResolver{resolver, v}
	}
	return output, nil
}

func (resolver *tolerationResolver) Key(ctx context.Context) string {
	value := resolver.data.GetKey()
	return value
}

func (resolver *tolerationResolver) Operator(ctx context.Context) string {
	value := resolver.data.GetOperator()
	return value.String()
}

func (resolver *tolerationResolver) TaintEffect(ctx context.Context) string {
	value := resolver.data.GetTaintEffect()
	return value.String()
}

func (resolver *tolerationResolver) Value(ctx context.Context) string {
	value := resolver.data.GetValue()
	return value
}

func toToleration_Operator(value *string) storage.Toleration_Operator {
	if value != nil {
		return storage.Toleration_Operator(storage.Toleration_Operator_value[*value])
	}
	return storage.Toleration_Operator(0)
}

func toToleration_Operators(values *[]string) []storage.Toleration_Operator {
	if values == nil {
		return nil
	}
	output := make([]storage.Toleration_Operator, len(*values))
	for i, v := range *values {
		output[i] = toToleration_Operator(&v)
	}
	return output
}

type tolerationsConfigResolver struct {
	root *Resolver
	data *storage.TolerationsConfig
}

func (resolver *Resolver) wrapTolerationsConfig(value *storage.TolerationsConfig, ok bool, err error) (*tolerationsConfigResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &tolerationsConfigResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapTolerationsConfigs(values []*storage.TolerationsConfig, err error) ([]*tolerationsConfigResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*tolerationsConfigResolver, len(values))
	for i, v := range values {
		output[i] = &tolerationsConfigResolver{resolver, v}
	}
	return output, nil
}

func (resolver *tolerationsConfigResolver) Disabled(ctx context.Context) bool {
	value := resolver.data.GetDisabled()
	return value
}

type upgradeProgressResolver struct {
	root *Resolver
	data *storage.UpgradeProgress
}

func (resolver *Resolver) wrapUpgradeProgress(value *storage.UpgradeProgress, ok bool, err error) (*upgradeProgressResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &upgradeProgressResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapUpgradeProgresses(values []*storage.UpgradeProgress, err error) ([]*upgradeProgressResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*upgradeProgressResolver, len(values))
	for i, v := range values {
		output[i] = &upgradeProgressResolver{resolver, v}
	}
	return output, nil
}

func (resolver *upgradeProgressResolver) Since(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetSince()
	return timestamp(value)
}

func (resolver *upgradeProgressResolver) UpgradeState(ctx context.Context) string {
	value := resolver.data.GetUpgradeState()
	return value.String()
}

func (resolver *upgradeProgressResolver) UpgradeStatusDetail(ctx context.Context) string {
	value := resolver.data.GetUpgradeStatusDetail()
	return value
}

func toUpgradeProgress_UpgradeState(value *string) storage.UpgradeProgress_UpgradeState {
	if value != nil {
		return storage.UpgradeProgress_UpgradeState(storage.UpgradeProgress_UpgradeState_value[*value])
	}
	return storage.UpgradeProgress_UpgradeState(0)
}

func toUpgradeProgress_UpgradeStates(values *[]string) []storage.UpgradeProgress_UpgradeState {
	if values == nil {
		return nil
	}
	output := make([]storage.UpgradeProgress_UpgradeState, len(*values))
	for i, v := range *values {
		output[i] = toUpgradeProgress_UpgradeState(&v)
	}
	return output
}

type v1MetadataResolver struct {
	root *Resolver
	data *storage.V1Metadata
}

func (resolver *Resolver) wrapV1Metadata(value *storage.V1Metadata, ok bool, err error) (*v1MetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &v1MetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapV1Metadatas(values []*storage.V1Metadata, err error) ([]*v1MetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*v1MetadataResolver, len(values))
	for i, v := range values {
		output[i] = &v1MetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *v1MetadataResolver) Author(ctx context.Context) string {
	value := resolver.data.GetAuthor()
	return value
}

func (resolver *v1MetadataResolver) Command(ctx context.Context) []string {
	value := resolver.data.GetCommand()
	return value
}

func (resolver *v1MetadataResolver) Created(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetCreated()
	return timestamp(value)
}

func (resolver *v1MetadataResolver) Digest(ctx context.Context) string {
	value := resolver.data.GetDigest()
	return value
}

func (resolver *v1MetadataResolver) Entrypoint(ctx context.Context) []string {
	value := resolver.data.GetEntrypoint()
	return value
}

func (resolver *v1MetadataResolver) Layers(ctx context.Context) ([]*imageLayerResolver, error) {
	value := resolver.data.GetLayers()
	return resolver.root.wrapImageLayers(value, nil)
}

func (resolver *v1MetadataResolver) User(ctx context.Context) string {
	value := resolver.data.GetUser()
	return value
}

func (resolver *v1MetadataResolver) Volumes(ctx context.Context) []string {
	value := resolver.data.GetVolumes()
	return value
}

type v2MetadataResolver struct {
	root *Resolver
	data *storage.V2Metadata
}

func (resolver *Resolver) wrapV2Metadata(value *storage.V2Metadata, ok bool, err error) (*v2MetadataResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &v2MetadataResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapV2Metadatas(values []*storage.V2Metadata, err error) ([]*v2MetadataResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*v2MetadataResolver, len(values))
	for i, v := range values {
		output[i] = &v2MetadataResolver{resolver, v}
	}
	return output, nil
}

func (resolver *v2MetadataResolver) Digest(ctx context.Context) string {
	value := resolver.data.GetDigest()
	return value
}

func toViolationState(value *string) storage.ViolationState {
	if value != nil {
		return storage.ViolationState(storage.ViolationState_value[*value])
	}
	return storage.ViolationState(0)
}

func toViolationStates(values *[]string) []storage.ViolationState {
	if values == nil {
		return nil
	}
	output := make([]storage.ViolationState, len(*values))
	for i, v := range *values {
		output[i] = toViolationState(&v)
	}
	return output
}

type volumeResolver struct {
	root *Resolver
	data *storage.Volume
}

func (resolver *Resolver) wrapVolume(value *storage.Volume, ok bool, err error) (*volumeResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &volumeResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapVolumes(values []*storage.Volume, err error) ([]*volumeResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*volumeResolver, len(values))
	for i, v := range values {
		output[i] = &volumeResolver{resolver, v}
	}
	return output, nil
}

func (resolver *volumeResolver) Destination(ctx context.Context) string {
	value := resolver.data.GetDestination()
	return value
}

func (resolver *volumeResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *volumeResolver) ReadOnly(ctx context.Context) bool {
	value := resolver.data.GetReadOnly()
	return value
}

func (resolver *volumeResolver) Source(ctx context.Context) string {
	value := resolver.data.GetSource()
	return value
}

func (resolver *volumeResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value
}

type volumePolicyResolver struct {
	root *Resolver
	data *storage.VolumePolicy
}

func (resolver *Resolver) wrapVolumePolicy(value *storage.VolumePolicy, ok bool, err error) (*volumePolicyResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &volumePolicyResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapVolumePolicies(values []*storage.VolumePolicy, err error) ([]*volumePolicyResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*volumePolicyResolver, len(values))
	for i, v := range values {
		output[i] = &volumePolicyResolver{resolver, v}
	}
	return output, nil
}

func (resolver *volumePolicyResolver) Destination(ctx context.Context) string {
	value := resolver.data.GetDestination()
	return value
}

func (resolver *volumePolicyResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *volumePolicyResolver) Source(ctx context.Context) string {
	value := resolver.data.GetSource()
	return value
}

func (resolver *volumePolicyResolver) Type(ctx context.Context) string {
	value := resolver.data.GetType()
	return value
}

type whitelistResolver struct {
	root *Resolver
	data *storage.Whitelist
}

func (resolver *Resolver) wrapWhitelist(value *storage.Whitelist, ok bool, err error) (*whitelistResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &whitelistResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapWhitelists(values []*storage.Whitelist, err error) ([]*whitelistResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*whitelistResolver, len(values))
	for i, v := range values {
		output[i] = &whitelistResolver{resolver, v}
	}
	return output, nil
}

func (resolver *whitelistResolver) Deployment(ctx context.Context) (*whitelist_DeploymentResolver, error) {
	value := resolver.data.GetDeployment()
	return resolver.root.wrapWhitelist_Deployment(value, true, nil)
}

func (resolver *whitelistResolver) Expiration(ctx context.Context) (*graphql.Time, error) {
	value := resolver.data.GetExpiration()
	return timestamp(value)
}

func (resolver *whitelistResolver) Image(ctx context.Context) (*whitelist_ImageResolver, error) {
	value := resolver.data.GetImage()
	return resolver.root.wrapWhitelist_Image(value, true, nil)
}

func (resolver *whitelistResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

type whitelist_DeploymentResolver struct {
	root *Resolver
	data *storage.Whitelist_Deployment
}

func (resolver *Resolver) wrapWhitelist_Deployment(value *storage.Whitelist_Deployment, ok bool, err error) (*whitelist_DeploymentResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &whitelist_DeploymentResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapWhitelist_Deployments(values []*storage.Whitelist_Deployment, err error) ([]*whitelist_DeploymentResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*whitelist_DeploymentResolver, len(values))
	for i, v := range values {
		output[i] = &whitelist_DeploymentResolver{resolver, v}
	}
	return output, nil
}

func (resolver *whitelist_DeploymentResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}

func (resolver *whitelist_DeploymentResolver) Scope(ctx context.Context) (*scopeResolver, error) {
	value := resolver.data.GetScope()
	return resolver.root.wrapScope(value, true, nil)
}

type whitelist_ImageResolver struct {
	root *Resolver
	data *storage.Whitelist_Image
}

func (resolver *Resolver) wrapWhitelist_Image(value *storage.Whitelist_Image, ok bool, err error) (*whitelist_ImageResolver, error) {
	if !ok || err != nil || value == nil {
		return nil, err
	}
	return &whitelist_ImageResolver{resolver, value}, nil
}

func (resolver *Resolver) wrapWhitelist_Images(values []*storage.Whitelist_Image, err error) ([]*whitelist_ImageResolver, error) {
	if err != nil || len(values) == 0 {
		return nil, err
	}
	output := make([]*whitelist_ImageResolver, len(values))
	for i, v := range values {
		output[i] = &whitelist_ImageResolver{resolver, v}
	}
	return output, nil
}

func (resolver *whitelist_ImageResolver) Name(ctx context.Context) string {
	value := resolver.data.GetName()
	return value
}
