// Code generated by pg-bindings generator. DO NOT EDIT.

package postgres

import (
	"context"
	"reflect"
	"time"

	"github.com/gogo/protobuf/proto"
	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/stackrox/rox/central/globaldb"
	"github.com/stackrox/rox/central/metrics"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/logging"
	ops "github.com/stackrox/rox/pkg/metrics"
	"github.com/stackrox/rox/pkg/postgres/pgutils"
	"github.com/stackrox/rox/pkg/postgres/walker"
)

const (
	baseTable  = "image_cves"
	countStmt  = "SELECT COUNT(*) FROM image_cves"
	existsStmt = "SELECT EXISTS(SELECT 1 FROM image_cves WHERE id = $1)"

	getStmt     = "SELECT serialized FROM image_cves WHERE id = $1"
	deleteStmt  = "DELETE FROM image_cves WHERE id = $1"
	walkStmt    = "SELECT serialized FROM image_cves"
	getIDsStmt  = "SELECT id FROM image_cves"
	getManyStmt = "SELECT serialized FROM image_cves WHERE id = ANY($1::text[])"

	deleteManyStmt = "DELETE FROM image_cves WHERE id = ANY($1::text[])"

	batchAfter = 100

	// using copyFrom, we may not even want to batch.  It would probably be simpler
	// to deal with failures if we just sent it all.  Something to think about as we
	// proceed and move into more e2e and larger performance testing
	batchSize = 10000
)

var (
	schema = walker.Walk(reflect.TypeOf((*storage.CVE)(nil)), baseTable)
	log    = logging.LoggerForModule()
)

func init() {
	globaldb.RegisterTable(schema)
}

type Store interface {
	Count(ctx context.Context) (int, error)
	Exists(ctx context.Context, id string) (bool, error)
	Get(ctx context.Context, id string) (*storage.CVE, bool, error)
	Upsert(ctx context.Context, obj *storage.CVE) error
	UpsertMany(ctx context.Context, objs []*storage.CVE) error
	Delete(ctx context.Context, id string) error
	GetIDs(ctx context.Context) ([]string, error)
	GetMany(ctx context.Context, ids []string) ([]*storage.CVE, []int, error)
	DeleteMany(ctx context.Context, ids []string) error

	Walk(ctx context.Context, fn func(obj *storage.CVE) error) error

	AckKeysIndexed(ctx context.Context, keys ...string) error
	GetKeysToIndex(ctx context.Context) ([]string, error)
}

type storeImpl struct {
	db *pgxpool.Pool
}

func createTableImageCves(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists image_cves (
    id varchar,
    cvss numeric,
    impactscore numeric,
    summary varchar,
    link varchar,
    publishedon timestamp,
    createdat timestamp,
    lastmodified timestamp,
    scoreversion integer,
    cvssv2_vector varchar,
    cvssv2_attackvector integer,
    cvssv2_accesscomplexity integer,
    cvssv2_authentication integer,
    cvssv2_confidentiality integer,
    cvssv2_integrity integer,
    cvssv2_availability integer,
    cvssv2_exploitabilityscore numeric,
    cvssv2_impactscore numeric,
    cvssv2_score numeric,
    cvssv2_severity integer,
    cvssv3_vector varchar,
    cvssv3_exploitabilityscore numeric,
    cvssv3_impactscore numeric,
    cvssv3_attackvector integer,
    cvssv3_attackcomplexity integer,
    cvssv3_privilegesrequired integer,
    cvssv3_userinteraction integer,
    cvssv3_scope integer,
    cvssv3_confidentiality integer,
    cvssv3_integrity integer,
    cvssv3_availability integer,
    cvssv3_score numeric,
    cvssv3_severity integer,
    suppressed bool,
    suppressactivation timestamp,
    suppressexpiry timestamp,
    severity integer,
    serialized bytea,
    PRIMARY KEY(id)
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		log.Panicf("Error creating table %s: %v", table, err)
	}

	indexes := []string{}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			log.Panicf("Error creating index %s: %v", index, err)
		}
	}

	createTableImageCvesReferences(ctx, db)
}

func createTableImageCvesReferences(ctx context.Context, db *pgxpool.Pool) {
	table := `
create table if not exists image_cves_References (
    cveid varchar,
    idx integer,
    uri varchar,
    tags text[],
    PRIMARY KEY(cveid, idx),
    CONSTRAINT fk_parent_table_0 FOREIGN KEY (cveid) REFERENCES image_cves(id) ON DELETE CASCADE
)
`

	_, err := db.Exec(ctx, table)
	if err != nil {
		log.Panicf("Error creating table %s: %v", table, err)
	}

	indexes := []string{

		"create index if not exists imageCvesReferences_idx on image_cves_References using btree(idx)",
	}
	for _, index := range indexes {
		if _, err := db.Exec(ctx, index); err != nil {
			log.Panicf("Error creating index %s: %v", index, err)
		}
	}

}

func insertIntoImageCves(ctx context.Context, tx pgx.Tx, obj *storage.CVE) error {

	serialized, marshalErr := obj.Marshal()
	if marshalErr != nil {
		return marshalErr
	}

	values := []interface{}{
		// parent primary keys start
		obj.GetId(),
		obj.GetCvss(),
		obj.GetImpactScore(),
		obj.GetSummary(),
		obj.GetLink(),
		pgutils.NilOrTime(obj.GetPublishedOn()),
		pgutils.NilOrTime(obj.GetCreatedAt()),
		pgutils.NilOrTime(obj.GetLastModified()),
		obj.GetScoreVersion(),
		obj.GetCvssV2().GetVector(),
		obj.GetCvssV2().GetAttackVector(),
		obj.GetCvssV2().GetAccessComplexity(),
		obj.GetCvssV2().GetAuthentication(),
		obj.GetCvssV2().GetConfidentiality(),
		obj.GetCvssV2().GetIntegrity(),
		obj.GetCvssV2().GetAvailability(),
		obj.GetCvssV2().GetExploitabilityScore(),
		obj.GetCvssV2().GetImpactScore(),
		obj.GetCvssV2().GetScore(),
		obj.GetCvssV2().GetSeverity(),
		obj.GetCvssV3().GetVector(),
		obj.GetCvssV3().GetExploitabilityScore(),
		obj.GetCvssV3().GetImpactScore(),
		obj.GetCvssV3().GetAttackVector(),
		obj.GetCvssV3().GetAttackComplexity(),
		obj.GetCvssV3().GetPrivilegesRequired(),
		obj.GetCvssV3().GetUserInteraction(),
		obj.GetCvssV3().GetScope(),
		obj.GetCvssV3().GetConfidentiality(),
		obj.GetCvssV3().GetIntegrity(),
		obj.GetCvssV3().GetAvailability(),
		obj.GetCvssV3().GetScore(),
		obj.GetCvssV3().GetSeverity(),
		obj.GetSuppressed(),
		pgutils.NilOrTime(obj.GetSuppressActivation()),
		pgutils.NilOrTime(obj.GetSuppressExpiry()),
		obj.GetSeverity(),
		serialized,
	}

	finalStr := "INSERT INTO image_cves (id, cvss, impactscore, summary, link, publishedon, createdat, lastmodified, scoreversion, cvssv2_vector, cvssv2_attackvector, cvssv2_accesscomplexity, cvssv2_authentication, cvssv2_confidentiality, cvssv2_integrity, cvssv2_availability, cvssv2_exploitabilityscore, cvssv2_impactscore, cvssv2_score, cvssv2_severity, cvssv3_vector, cvssv3_exploitabilityscore, cvssv3_impactscore, cvssv3_attackvector, cvssv3_attackcomplexity, cvssv3_privilegesrequired, cvssv3_userinteraction, cvssv3_scope, cvssv3_confidentiality, cvssv3_integrity, cvssv3_availability, cvssv3_score, cvssv3_severity, suppressed, suppressactivation, suppressexpiry, severity, serialized) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38) ON CONFLICT(id) DO UPDATE SET id = EXCLUDED.id, cvss = EXCLUDED.cvss, impactscore = EXCLUDED.impactscore, summary = EXCLUDED.summary, link = EXCLUDED.link, publishedon = EXCLUDED.publishedon, createdat = EXCLUDED.createdat, lastmodified = EXCLUDED.lastmodified, scoreversion = EXCLUDED.scoreversion, cvssv2_vector = EXCLUDED.cvssv2_vector, cvssv2_attackvector = EXCLUDED.cvssv2_attackvector, cvssv2_accesscomplexity = EXCLUDED.cvssv2_accesscomplexity, cvssv2_authentication = EXCLUDED.cvssv2_authentication, cvssv2_confidentiality = EXCLUDED.cvssv2_confidentiality, cvssv2_integrity = EXCLUDED.cvssv2_integrity, cvssv2_availability = EXCLUDED.cvssv2_availability, cvssv2_exploitabilityscore = EXCLUDED.cvssv2_exploitabilityscore, cvssv2_impactscore = EXCLUDED.cvssv2_impactscore, cvssv2_score = EXCLUDED.cvssv2_score, cvssv2_severity = EXCLUDED.cvssv2_severity, cvssv3_vector = EXCLUDED.cvssv3_vector, cvssv3_exploitabilityscore = EXCLUDED.cvssv3_exploitabilityscore, cvssv3_impactscore = EXCLUDED.cvssv3_impactscore, cvssv3_attackvector = EXCLUDED.cvssv3_attackvector, cvssv3_attackcomplexity = EXCLUDED.cvssv3_attackcomplexity, cvssv3_privilegesrequired = EXCLUDED.cvssv3_privilegesrequired, cvssv3_userinteraction = EXCLUDED.cvssv3_userinteraction, cvssv3_scope = EXCLUDED.cvssv3_scope, cvssv3_confidentiality = EXCLUDED.cvssv3_confidentiality, cvssv3_integrity = EXCLUDED.cvssv3_integrity, cvssv3_availability = EXCLUDED.cvssv3_availability, cvssv3_score = EXCLUDED.cvssv3_score, cvssv3_severity = EXCLUDED.cvssv3_severity, suppressed = EXCLUDED.suppressed, suppressactivation = EXCLUDED.suppressactivation, suppressexpiry = EXCLUDED.suppressexpiry, severity = EXCLUDED.severity, serialized = EXCLUDED.serialized"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	var query string

	for childIdx, child := range obj.GetReferences() {
		if err := insertIntoImageCvesReferences(ctx, tx, child, obj.GetId(), childIdx); err != nil {
			return err
		}
	}

	query = "delete from image_cves_References where cveid = $1 AND idx >= $2"
	_, err = tx.Exec(ctx, query, obj.GetId(), len(obj.GetReferences()))
	if err != nil {
		return err
	}
	return nil
}

func insertIntoImageCvesReferences(ctx context.Context, tx pgx.Tx, obj *storage.CVE_Reference, cveid string, idx int) error {

	values := []interface{}{
		// parent primary keys start
		cveid,
		idx,
		obj.GetURI(),
		obj.GetTags(),
	}

	finalStr := "INSERT INTO image_cves_References (cveid, idx, uri, tags) VALUES($1, $2, $3, $4) ON CONFLICT(cveid, idx) DO UPDATE SET cveid = EXCLUDED.cveid, idx = EXCLUDED.idx, uri = EXCLUDED.uri, tags = EXCLUDED.tags"
	_, err := tx.Exec(ctx, finalStr, values...)
	if err != nil {
		return err
	}

	return nil
}

func (s *storeImpl) copyFromImageCves(ctx context.Context, tx pgx.Tx, objs ...*storage.CVE) error {

	inputRows := [][]interface{}{}

	var err error

	// This is a copy so first we must delete the rows and re-add them
	// Which is essentially the desired behaviour of an upsert.
	var deletes []string

	copyCols := []string{

		"id",

		"cvss",

		"impactscore",

		"summary",

		"link",

		"publishedon",

		"createdat",

		"lastmodified",

		"scoreversion",

		"cvssv2_vector",

		"cvssv2_attackvector",

		"cvssv2_accesscomplexity",

		"cvssv2_authentication",

		"cvssv2_confidentiality",

		"cvssv2_integrity",

		"cvssv2_availability",

		"cvssv2_exploitabilityscore",

		"cvssv2_impactscore",

		"cvssv2_score",

		"cvssv2_severity",

		"cvssv3_vector",

		"cvssv3_exploitabilityscore",

		"cvssv3_impactscore",

		"cvssv3_attackvector",

		"cvssv3_attackcomplexity",

		"cvssv3_privilegesrequired",

		"cvssv3_userinteraction",

		"cvssv3_scope",

		"cvssv3_confidentiality",

		"cvssv3_integrity",

		"cvssv3_availability",

		"cvssv3_score",

		"cvssv3_severity",

		"suppressed",

		"suppressactivation",

		"suppressexpiry",

		"severity",

		"serialized",
	}

	for idx, obj := range objs {
		// Todo: ROX-9499 Figure out how to more cleanly template around this issue.
		log.Debugf("This is here for now because there is an issue with pods_TerminatedInstances where the obj in the loop is not used as it only consists of the parent id and the idx.  Putting this here as a stop gap to simply use the object.  %s", obj)

		serialized, marshalErr := obj.Marshal()
		if marshalErr != nil {
			return marshalErr
		}

		inputRows = append(inputRows, []interface{}{

			obj.GetId(),

			obj.GetCvss(),

			obj.GetImpactScore(),

			obj.GetSummary(),

			obj.GetLink(),

			pgutils.NilOrTime(obj.GetPublishedOn()),

			pgutils.NilOrTime(obj.GetCreatedAt()),

			pgutils.NilOrTime(obj.GetLastModified()),

			obj.GetScoreVersion(),

			obj.GetCvssV2().GetVector(),

			obj.GetCvssV2().GetAttackVector(),

			obj.GetCvssV2().GetAccessComplexity(),

			obj.GetCvssV2().GetAuthentication(),

			obj.GetCvssV2().GetConfidentiality(),

			obj.GetCvssV2().GetIntegrity(),

			obj.GetCvssV2().GetAvailability(),

			obj.GetCvssV2().GetExploitabilityScore(),

			obj.GetCvssV2().GetImpactScore(),

			obj.GetCvssV2().GetScore(),

			obj.GetCvssV2().GetSeverity(),

			obj.GetCvssV3().GetVector(),

			obj.GetCvssV3().GetExploitabilityScore(),

			obj.GetCvssV3().GetImpactScore(),

			obj.GetCvssV3().GetAttackVector(),

			obj.GetCvssV3().GetAttackComplexity(),

			obj.GetCvssV3().GetPrivilegesRequired(),

			obj.GetCvssV3().GetUserInteraction(),

			obj.GetCvssV3().GetScope(),

			obj.GetCvssV3().GetConfidentiality(),

			obj.GetCvssV3().GetIntegrity(),

			obj.GetCvssV3().GetAvailability(),

			obj.GetCvssV3().GetScore(),

			obj.GetCvssV3().GetSeverity(),

			obj.GetSuppressed(),

			pgutils.NilOrTime(obj.GetSuppressActivation()),

			pgutils.NilOrTime(obj.GetSuppressExpiry()),

			obj.GetSeverity(),

			serialized,
		})

		// Add the id to be deleted.
		deletes = append(deletes, obj.GetId())

		// if we hit our batch size we need to push the data
		if (idx+1)%batchSize == 0 || idx == len(objs)-1 {
			// copy does not upsert so have to delete first.  parent deletion cascades so only need to
			// delete for the top level parent

			_, err = tx.Exec(ctx, deleteManyStmt, deletes)
			if err != nil {
				return err
			}
			// clear the inserts and vals for the next batch
			deletes = nil

			_, err = tx.CopyFrom(ctx, pgx.Identifier{"image_cves"}, copyCols, pgx.CopyFromRows(inputRows))

			if err != nil {
				return err
			}

			// clear the input rows for the next batch
			inputRows = inputRows[:0]
		}
	}

	for _, obj := range objs {

		if err = s.copyFromImageCvesReferences(ctx, tx, obj.GetId(), obj.GetReferences()...); err != nil {
			return err
		}
	}

	return err
}

func (s *storeImpl) copyFromImageCvesReferences(ctx context.Context, tx pgx.Tx, cveid string, objs ...*storage.CVE_Reference) error {

	inputRows := [][]interface{}{}

	var err error

	copyCols := []string{

		"cveid",

		"idx",

		"uri",

		"tags",
	}

	for idx, obj := range objs {
		// Todo: ROX-9499 Figure out how to more cleanly template around this issue.
		log.Debugf("This is here for now because there is an issue with pods_TerminatedInstances where the obj in the loop is not used as it only consists of the parent id and the idx.  Putting this here as a stop gap to simply use the object.  %s", obj)

		inputRows = append(inputRows, []interface{}{

			cveid,

			idx,

			obj.GetURI(),

			obj.GetTags(),
		})

		// if we hit our batch size we need to push the data
		if (idx+1)%batchSize == 0 || idx == len(objs)-1 {
			// copy does not upsert so have to delete first.  parent deletion cascades so only need to
			// delete for the top level parent

			_, err = tx.CopyFrom(ctx, pgx.Identifier{"image_cves_references"}, copyCols, pgx.CopyFromRows(inputRows))

			if err != nil {
				return err
			}

			// clear the input rows for the next batch
			inputRows = inputRows[:0]
		}
	}

	return err
}

// New returns a new Store instance using the provided sql instance.
func New(ctx context.Context, db *pgxpool.Pool) Store {
	createTableImageCves(ctx, db)

	return &storeImpl{
		db: db,
	}
}

func (s *storeImpl) copyFrom(ctx context.Context, objs ...*storage.CVE) error {
	conn, release := s.acquireConn(ctx, ops.Get, "CVE")
	defer release()

	tx, err := conn.Begin(ctx)
	if err != nil {
		return err
	}

	if err := s.copyFromImageCves(ctx, tx, objs...); err != nil {
		if err := tx.Rollback(ctx); err != nil {
			return err
		}
		return err
	}
	if err := tx.Commit(ctx); err != nil {
		return err
	}
	return nil
}

func (s *storeImpl) upsert(ctx context.Context, objs ...*storage.CVE) error {
	conn, release := s.acquireConn(ctx, ops.Get, "CVE")
	defer release()

	for _, obj := range objs {
		tx, err := conn.Begin(ctx)
		if err != nil {
			return err
		}

		if err := insertIntoImageCves(ctx, tx, obj); err != nil {
			if err := tx.Rollback(ctx); err != nil {
				return err
			}
			return err
		}
		if err := tx.Commit(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (s *storeImpl) Upsert(ctx context.Context, obj *storage.CVE) error {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Upsert, "CVE")

	return s.upsert(ctx, obj)
}

func (s *storeImpl) UpsertMany(ctx context.Context, objs []*storage.CVE) error {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.UpdateMany, "CVE")

	if len(objs) < batchAfter {
		return s.upsert(ctx, objs...)
	} else {
		return s.copyFrom(ctx, objs...)
	}
}

// Count returns the number of objects in the store
func (s *storeImpl) Count(ctx context.Context) (int, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Count, "CVE")

	row := s.db.QueryRow(ctx, countStmt)
	var count int
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// Exists returns if the id exists in the store
func (s *storeImpl) Exists(ctx context.Context, id string) (bool, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Exists, "CVE")

	row := s.db.QueryRow(ctx, existsStmt, id)
	var exists bool
	if err := row.Scan(&exists); err != nil {
		return false, pgutils.ErrNilIfNoRows(err)
	}
	return exists, nil
}

// Get returns the object, if it exists from the store
func (s *storeImpl) Get(ctx context.Context, id string) (*storage.CVE, bool, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Get, "CVE")

	conn, release := s.acquireConn(ctx, ops.Get, "CVE")
	defer release()

	row := conn.QueryRow(ctx, getStmt, id)
	var data []byte
	if err := row.Scan(&data); err != nil {
		return nil, false, pgutils.ErrNilIfNoRows(err)
	}

	var msg storage.CVE
	if err := proto.Unmarshal(data, &msg); err != nil {
		return nil, false, err
	}
	return &msg, true, nil
}

func (s *storeImpl) acquireConn(ctx context.Context, op ops.Op, typ string) (*pgxpool.Conn, func()) {
	defer metrics.SetAcquireDBConnDuration(time.Now(), op, typ)
	conn, err := s.db.Acquire(ctx)
	if err != nil {
		panic(err)
	}
	return conn, conn.Release
}

// Delete removes the specified ID from the store
func (s *storeImpl) Delete(ctx context.Context, id string) error {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Remove, "CVE")

	conn, release := s.acquireConn(ctx, ops.Remove, "CVE")
	defer release()

	if _, err := conn.Exec(ctx, deleteStmt, id); err != nil {
		return err
	}
	return nil
}

// GetIDs returns all the IDs for the store
func (s *storeImpl) GetIDs(ctx context.Context) ([]string, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.GetAll, "storage.CVEIDs")

	rows, err := s.db.Query(ctx, getIDsStmt)
	if err != nil {
		return nil, pgutils.ErrNilIfNoRows(err)
	}
	defer rows.Close()
	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	return ids, nil
}

// GetMany returns the objects specified by the IDs or the index in the missing indices slice
func (s *storeImpl) GetMany(ctx context.Context, ids []string) ([]*storage.CVE, []int, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.GetMany, "CVE")

	conn, release := s.acquireConn(ctx, ops.GetMany, "CVE")
	defer release()

	rows, err := conn.Query(ctx, getManyStmt, ids)
	if err != nil {
		if err == pgx.ErrNoRows {
			missingIndices := make([]int, 0, len(ids))
			for i := range ids {
				missingIndices = append(missingIndices, i)
			}
			return nil, missingIndices, nil
		}
		return nil, nil, err
	}
	defer rows.Close()
	resultsByID := make(map[string]*storage.CVE)
	for rows.Next() {
		var data []byte
		if err := rows.Scan(&data); err != nil {
			return nil, nil, err
		}
		msg := &storage.CVE{}
		if err := proto.Unmarshal(data, msg); err != nil {
			return nil, nil, err
		}
		resultsByID[msg.GetId()] = msg
	}
	missingIndices := make([]int, 0, len(ids)-len(resultsByID))
	// It is important that the elems are populated in the same order as the input ids
	// slice, since some calling code relies on that to maintain order.
	elems := make([]*storage.CVE, 0, len(resultsByID))
	for i, id := range ids {
		if result, ok := resultsByID[id]; !ok {
			missingIndices = append(missingIndices, i)
		} else {
			elems = append(elems, result)
		}
	}
	return elems, missingIndices, nil
}

// Delete removes the specified IDs from the store
func (s *storeImpl) DeleteMany(ctx context.Context, ids []string) error {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.RemoveMany, "CVE")

	conn, release := s.acquireConn(ctx, ops.RemoveMany, "CVE")
	defer release()
	if _, err := conn.Exec(ctx, deleteManyStmt, ids); err != nil {
		return err
	}
	return nil
}

// Walk iterates over all of the objects in the store and applies the closure
func (s *storeImpl) Walk(ctx context.Context, fn func(obj *storage.CVE) error) error {
	rows, err := s.db.Query(ctx, walkStmt)
	if err != nil {
		return pgutils.ErrNilIfNoRows(err)
	}
	defer rows.Close()
	for rows.Next() {
		var data []byte
		if err := rows.Scan(&data); err != nil {
			return err
		}
		var msg storage.CVE
		if err := proto.Unmarshal(data, &msg); err != nil {
			return err
		}
		if err := fn(&msg); err != nil {
			return err
		}
	}
	return nil
}

//// Used for testing

func dropTableImageCves(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS image_cves CASCADE")
	dropTableImageCvesReferences(ctx, db)

}

func dropTableImageCvesReferences(ctx context.Context, db *pgxpool.Pool) {
	_, _ = db.Exec(ctx, "DROP TABLE IF EXISTS image_cves_References CASCADE")

}

func Destroy(ctx context.Context, db *pgxpool.Pool) {
	dropTableImageCves(ctx, db)
}

//// Stubs for satisfying legacy interfaces

// AckKeysIndexed acknowledges the passed keys were indexed
func (s *storeImpl) AckKeysIndexed(ctx context.Context, keys ...string) error {
	return nil
}

// GetKeysToIndex returns the keys that need to be indexed
func (s *storeImpl) GetKeysToIndex(ctx context.Context) ([]string, error) {
	return nil, nil
}
