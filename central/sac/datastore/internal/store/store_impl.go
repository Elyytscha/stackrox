// Code generated by boltbindings generator. DO NOT EDIT.

package store

import (
	bbolt "github.com/etcd-io/bbolt"
	proto1 "github.com/gogo/protobuf/proto"
	metrics "github.com/stackrox/rox/central/metrics"
	storage "github.com/stackrox/rox/generated/storage"
	bolthelper "github.com/stackrox/rox/pkg/bolthelper"
	proto "github.com/stackrox/rox/pkg/bolthelper/crud/proto"
	ops "github.com/stackrox/rox/pkg/metrics"
	"time"
)

var (
	bucketName = []byte("authzPlugins")
)

type store struct {
	crud proto.MessageCrud
}

func key(msg proto1.Message) []byte {
	return []byte(msg.(*storage.AuthzPluginConfig).GetId())
}

func alloc() proto1.Message {
	return new(storage.AuthzPluginConfig)
}

func newStore(db *bbolt.DB) (*store, error) {
	if err := bolthelper.RegisterBucket(db, bucketName); err != nil {
		return nil, err
	}
	return &store{crud: proto.NewMessageCrud(db, bucketName, key, alloc)}, nil
}

func (s *store) DeleteAuthzPluginConfig(id string) error {
	defer metrics.SetBoltOperationDurationTime(time.Now(), ops.Remove, "AuthzPluginConfig")
	return s.crud.Delete(id)
}

func (s *store) GetAuthzPluginConfig(id string) (*storage.AuthzPluginConfig, error) {
	defer metrics.SetBoltOperationDurationTime(time.Now(), ops.Get, "AuthzPluginConfig")
	msg, err := s.crud.Read(id)
	if err != nil {
		return nil, err
	}
	if msg == nil {
		return nil, nil
	}
	storedKey := msg.(*storage.AuthzPluginConfig)
	return storedKey, nil
}

func (s *store) ListAuthzPluginConfigs() ([]*storage.AuthzPluginConfig, error) {
	defer metrics.SetBoltOperationDurationTime(time.Now(), ops.GetAll, "AuthzPluginConfig")
	msgs, err := s.crud.ReadAll()
	if err != nil {
		return nil, err
	}
	storedKeys := make([]*storage.AuthzPluginConfig, len(msgs))
	for i, msg := range msgs {
		storedKeys[i] = msg.(*storage.AuthzPluginConfig)
	}
	return storedKeys, nil
}

func (s *store) UpsertAuthzPluginConfig(authzpluginconfig *storage.AuthzPluginConfig) error {
	defer metrics.SetBoltOperationDurationTime(time.Now(), ops.Upsert, "AuthzPluginConfig")
	return s.crud.Upsert(authzpluginconfig)
}

func (s *store) UpsertAuthzPluginConfigs(authzpluginconfigs []*storage.AuthzPluginConfig) error {
	msgs := make([]proto1.Message, len(authzpluginconfigs))
	for i, key := range authzpluginconfigs {
		msgs[i] = key
	}
	return s.crud.UpsertBatch(msgs)
}
