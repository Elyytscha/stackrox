// Code generated by pg-bindings generator. DO NOT EDIT.

package postgres

import (
	"bytes"
	"context"
	"reflect"
	"time"

	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/types"
	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/stackrox/rox/central/globaldb"
	"github.com/stackrox/rox/central/metrics"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/pkg/logging"
	ops "github.com/stackrox/rox/pkg/metrics"
)

const (
	countStmt  = "SELECT COUNT(*) FROM Deployment"
	existsStmt = "SELECT EXISTS(SELECT 1 FROM Deployment WHERE Id = $1)"

	getStmt        = "SELECT serialized FROM Deployment WHERE Id = $1"
	deleteStmt     = "DELETE FROM Deployment WHERE Id = $1"
	walkStmt       = "SELECT serialized FROM Deployment"
	getIDsStmt     = "SELECT Id FROM Deployment"
	getManyStmt    = "SELECT serialized FROM Deployment WHERE Id = ANY($1::text[])"
	deleteManyStmt = "DELETE FROM Deployment WHERE Id = ANY($1::text[])"
)

var (
	log = logging.LoggerForModule()

	table = "Deployment"

	marshaler = &jsonpb.Marshaler{EnumsAsInts: true, EmitDefaults: true}
)

type Store interface {
	Count() (int, error)
	Exists(id string) (bool, error)
	Get(id string) (*storage.Deployment, bool, error)
	Upsert(obj *storage.Deployment) error
	UpsertMany(objs []*storage.Deployment) error
	Delete(id string) error
	GetIDs() ([]string, error)
	GetMany(ids []string) ([]*storage.Deployment, []int, error)
	DeleteMany(ids []string) error

	Walk(fn func(obj *storage.Deployment) error) error
	AckKeysIndexed(keys ...string) error
	GetKeysToIndex() ([]string, error)
}

type storeImpl struct {
	db *pgxpool.Pool
}

const (
	batchInsertTemplate = "<no value>"
)

// New returns a new Store instance using the provided sql instance.
func New(db *pgxpool.Pool) Store {
	globaldb.RegisterTable(table, "Deployment")

	for _, table := range []string{
		"create table if not exists Deployment(serialized jsonb not null, Id varchar, Name varchar, Type varchar, Namespace varchar, NamespaceId varchar, OrchestratorComponent bool, Labels jsonb, PodLabels jsonb, Created timestamp, ClusterId varchar, ClusterName varchar, Annotations jsonb, Priority numeric, ImagePullSecrets text[], ServiceAccount varchar, ServiceAccountPermissionLevel integer, RiskScore numeric, ProcessTags text[], PRIMARY KEY (Id));",
		"create index if not exists Deployment_Id on Deployment using hash(Id)",
		"create table if not exists Deployment_Containers(parent_Id varchar not null, idx integer not null, Image_Id varchar, Image_Name_Registry varchar, Image_Name_Remote varchar, Image_Name_Tag varchar, Image_Name_FullName varchar, SecurityContext_Privileged bool, SecurityContext_DropCapabilities text[], SecurityContext_AddCapabilities text[], SecurityContext_ReadOnlyRootFilesystem bool, Resources_CpuCoresRequest numeric, Resources_CpuCoresLimit numeric, Resources_MemoryMbRequest numeric, Resources_MemoryMbLimit numeric, PRIMARY KEY (parent_Id, idx), CONSTRAINT fk_parent_table FOREIGN KEY (parent_Id) REFERENCES Deployment(Id) ON DELETE CASCADE);",
		"create table if not exists Deployment_Containers_Volumes(parent_parent_Id varchar not null, parent_idx integer not null, idx integer not null, Name varchar, Source varchar, Destination varchar, ReadOnly bool, Type varchar, PRIMARY KEY (parent_parent_Id, parent_idx, idx), CONSTRAINT fk_parent_table FOREIGN KEY (parent_parent_Id, parent_idx) REFERENCES Deployment_Containers(parent_Id, idx) ON DELETE CASCADE);",
		"create table if not exists Deployment_Containers_Secrets(parent_parent_Id varchar not null, parent_idx integer not null, idx integer not null, Name varchar, Path varchar, PRIMARY KEY (parent_parent_Id, parent_idx, idx), CONSTRAINT fk_parent_table FOREIGN KEY (parent_parent_Id, parent_idx) REFERENCES Deployment_Containers(parent_Id, idx) ON DELETE CASCADE);",
		"create table if not exists Deployment_Containers_Env(parent_parent_Id varchar not null, parent_idx integer not null, idx integer not null, Key varchar, Value varchar, EnvVarSource integer, PRIMARY KEY (parent_parent_Id, parent_idx, idx), CONSTRAINT fk_parent_table FOREIGN KEY (parent_parent_Id, parent_idx) REFERENCES Deployment_Containers(parent_Id, idx) ON DELETE CASCADE);",
		"create table if not exists Deployment_Ports(parent_Id varchar not null, idx integer not null, ContainerPort numeric, Protocol varchar, Exposure integer, PRIMARY KEY (parent_Id, idx), CONSTRAINT fk_parent_table FOREIGN KEY (parent_Id) REFERENCES Deployment(Id) ON DELETE CASCADE);",
		"create table if not exists Deployment_Ports_ExposureInfos(parent_parent_Id varchar not null, parent_idx integer not null, idx integer not null, Level integer, ServiceName varchar, ServicePort numeric, NodePort numeric, ExternalIps text[], ExternalHostnames text[], PRIMARY KEY (parent_parent_Id, parent_idx, idx), CONSTRAINT fk_parent_table FOREIGN KEY (parent_parent_Id, parent_idx) REFERENCES Deployment_Ports(parent_Id, idx) ON DELETE CASCADE);",
	} {
		_, err := db.Exec(context.Background(), table)
		if err != nil {
			panic("error creating table: " + table)
		}
	}

	//
	return &storeImpl{
		db: db,
	}
	//
}

// Count returns the number of objects in the store
func (s *storeImpl) Count() (int, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Count, "Deployment")

	row := s.db.QueryRow(context.Background(), countStmt)
	var count int
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// Exists returns if the id exists in the store
func (s *storeImpl) Exists(id string) (bool, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Exists, "Deployment")

	row := s.db.QueryRow(context.Background(), existsStmt, id)
	var exists bool
	if err := row.Scan(&exists); err != nil {
		return false, nilNoRows(err)
	}
	return exists, nil
}

func nilNoRows(err error) error {
	if err == pgx.ErrNoRows {
		return nil
	}
	return err
}

// Get returns the object, if it exists from the store
func (s *storeImpl) Get(id string) (*storage.Deployment, bool, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Get, "Deployment")

	conn, release := s.acquireConn(ops.Get, "Deployment")
	defer release()

	row := conn.QueryRow(context.Background(), getStmt, id)
	var data []byte
	if err := row.Scan(&data); err != nil {
		return nil, false, nilNoRows(err)
	}

	var msg storage.Deployment
	buf := bytes.NewBuffer(data)
	defer metrics.SetJSONPBOperationDurationTime(time.Now(), "Unmarshal", "Deployment")
	if err := jsonpb.Unmarshal(buf, &msg); err != nil {
		return nil, false, err
	}
	return &msg, true, nil
}

func convertEnumSliceToIntArray(i interface{}) []int32 {
	enumSlice := reflect.ValueOf(i)
	enumSliceLen := enumSlice.Len()
	resultSlice := make([]int32, 0, enumSliceLen)
	for i := 0; i < enumSlice.Len(); i++ {
		resultSlice = append(resultSlice, int32(enumSlice.Index(i).Int()))
	}
	return resultSlice
}

func nilOrStringTimestamp(t *types.Timestamp) *string {
	if t == nil {
		return nil
	}
	s := t.String()
	return &s
}

// Upsert inserts the object into the DB
func (s *storeImpl) Upsert(obj0 *storage.Deployment) error {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Add, "Deployment")

	t := time.Now()
	serialized, err := marshaler.MarshalToString(obj0)
	if err != nil {
		return err
	}
	metrics.SetJSONPBOperationDurationTime(t, "Marshal", "Deployment")
	conn, release := s.acquireConn(ops.Add, "Deployment")
	defer release()

	tx, err := conn.BeginTx(context.Background(), pgx.TxOptions{})
	if err != nil {
		return err
	}
	doRollback := true
	defer func() {
		if doRollback {
			if rollbackErr := tx.Rollback(context.Background()); rollbackErr != nil {
				log.Errorf("error rolling backing: %v", err)
			}
		}
	}()

	localQuery := "insert into Deployment(serialized, Id, Name, Type, Namespace, NamespaceId, OrchestratorComponent, Labels, PodLabels, Created, ClusterId, ClusterName, Annotations, Priority, ImagePullSecrets, ServiceAccount, ServiceAccountPermissionLevel, RiskScore, ProcessTags) values($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19) on conflict(Id) do update set serialized = EXCLUDED.serialized, Id = EXCLUDED.Id, Name = EXCLUDED.Name, Type = EXCLUDED.Type, Namespace = EXCLUDED.Namespace, NamespaceId = EXCLUDED.NamespaceId, OrchestratorComponent = EXCLUDED.OrchestratorComponent, Labels = EXCLUDED.Labels, PodLabels = EXCLUDED.PodLabels, Created = EXCLUDED.Created, ClusterId = EXCLUDED.ClusterId, ClusterName = EXCLUDED.ClusterName, Annotations = EXCLUDED.Annotations, Priority = EXCLUDED.Priority, ImagePullSecrets = EXCLUDED.ImagePullSecrets, ServiceAccount = EXCLUDED.ServiceAccount, ServiceAccountPermissionLevel = EXCLUDED.ServiceAccountPermissionLevel, RiskScore = EXCLUDED.RiskScore, ProcessTags = EXCLUDED.ProcessTags"
	_, err = tx.Exec(context.Background(), localQuery, serialized, obj0.GetId(), obj0.GetName(), obj0.GetType(), obj0.GetNamespace(), obj0.GetNamespaceId(), obj0.GetOrchestratorComponent(), obj0.GetLabels(), obj0.GetPodLabels(), nilOrStringTimestamp(obj0.GetCreated()), obj0.GetClusterId(), obj0.GetClusterName(), obj0.GetAnnotations(), obj0.GetPriority(), obj0.GetImagePullSecrets(), obj0.GetServiceAccount(), obj0.GetServiceAccountPermissionLevel(), obj0.GetRiskScore(), obj0.GetProcessTags())
	if err != nil {
		return err
	}
	for idx1, obj1 := range obj0.GetContainers() {
		localQuery := "insert into Deployment_Containers(parent_Id, idx, Image_Id, Image_Name_Registry, Image_Name_Remote, Image_Name_Tag, Image_Name_FullName, SecurityContext_Privileged, SecurityContext_DropCapabilities, SecurityContext_AddCapabilities, SecurityContext_ReadOnlyRootFilesystem, Resources_CpuCoresRequest, Resources_CpuCoresLimit, Resources_MemoryMbRequest, Resources_MemoryMbLimit) values($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) on conflict(parent_Id, idx) do update set parent_Id = EXCLUDED.parent_Id, idx = EXCLUDED.idx, Image_Id = EXCLUDED.Image_Id, Image_Name_Registry = EXCLUDED.Image_Name_Registry, Image_Name_Remote = EXCLUDED.Image_Name_Remote, Image_Name_Tag = EXCLUDED.Image_Name_Tag, Image_Name_FullName = EXCLUDED.Image_Name_FullName, SecurityContext_Privileged = EXCLUDED.SecurityContext_Privileged, SecurityContext_DropCapabilities = EXCLUDED.SecurityContext_DropCapabilities, SecurityContext_AddCapabilities = EXCLUDED.SecurityContext_AddCapabilities, SecurityContext_ReadOnlyRootFilesystem = EXCLUDED.SecurityContext_ReadOnlyRootFilesystem, Resources_CpuCoresRequest = EXCLUDED.Resources_CpuCoresRequest, Resources_CpuCoresLimit = EXCLUDED.Resources_CpuCoresLimit, Resources_MemoryMbRequest = EXCLUDED.Resources_MemoryMbRequest, Resources_MemoryMbLimit = EXCLUDED.Resources_MemoryMbLimit"
		_, err := tx.Exec(context.Background(), localQuery, obj0.GetId(), idx1, obj1.GetImage().GetId(), obj1.GetImage().GetName().GetRegistry(), obj1.GetImage().GetName().GetRemote(), obj1.GetImage().GetName().GetTag(), obj1.GetImage().GetName().GetFullName(), obj1.GetSecurityContext().GetPrivileged(), obj1.GetSecurityContext().GetDropCapabilities(), obj1.GetSecurityContext().GetAddCapabilities(), obj1.GetSecurityContext().GetReadOnlyRootFilesystem(), obj1.GetResources().GetCpuCoresRequest(), obj1.GetResources().GetCpuCoresLimit(), obj1.GetResources().GetMemoryMbRequest(), obj1.GetResources().GetMemoryMbLimit())
		if err != nil {
			return err
		}
		for idx2, obj2 := range obj1.GetVolumes() {
			localQuery := "insert into Deployment_Containers_Volumes(parent_parent_Id, parent_idx, idx, Name, Source, Destination, ReadOnly, Type) values($1, $2, $3, $4, $5, $6, $7, $8) on conflict(parent_parent_Id, parent_idx, idx) do update set parent_parent_Id = EXCLUDED.parent_parent_Id, parent_idx = EXCLUDED.parent_idx, idx = EXCLUDED.idx, Name = EXCLUDED.Name, Source = EXCLUDED.Source, Destination = EXCLUDED.Destination, ReadOnly = EXCLUDED.ReadOnly, Type = EXCLUDED.Type"
			_, err := tx.Exec(context.Background(), localQuery, obj0.GetId(), idx1, idx2, obj2.GetName(), obj2.GetSource(), obj2.GetDestination(), obj2.GetReadOnly(), obj2.GetType())
			if err != nil {
				return err
			}
		}
		_, err = tx.Exec(context.Background(), "delete from Deployment_Containers_Volumes where parent_parent_Id = $1 and parent_idx = $2 and idx >= $3", obj0.GetId(), idx1, len(obj1.GetVolumes()))
		if err != nil {
			return err
		}
		for idx2, obj2 := range obj1.GetSecrets() {
			localQuery := "insert into Deployment_Containers_Secrets(parent_parent_Id, parent_idx, idx, Name, Path) values($1, $2, $3, $4, $5) on conflict(parent_parent_Id, parent_idx, idx) do update set parent_parent_Id = EXCLUDED.parent_parent_Id, parent_idx = EXCLUDED.parent_idx, idx = EXCLUDED.idx, Name = EXCLUDED.Name, Path = EXCLUDED.Path"
			_, err := tx.Exec(context.Background(), localQuery, obj0.GetId(), idx1, idx2, obj2.GetName(), obj2.GetPath())
			if err != nil {
				return err
			}
		}
		_, err = tx.Exec(context.Background(), "delete from Deployment_Containers_Secrets where parent_parent_Id = $1 and parent_idx = $2 and idx >= $3", obj0.GetId(), idx1, len(obj1.GetSecrets()))
		if err != nil {
			return err
		}
		for idx2, obj2 := range obj1.GetConfig().GetEnv() {
			localQuery := "insert into Deployment_Containers_Env(parent_parent_Id, parent_idx, idx, Key, Value, EnvVarSource) values($1, $2, $3, $4, $5, $6) on conflict(parent_parent_Id, parent_idx, idx) do update set parent_parent_Id = EXCLUDED.parent_parent_Id, parent_idx = EXCLUDED.parent_idx, idx = EXCLUDED.idx, Key = EXCLUDED.Key, Value = EXCLUDED.Value, EnvVarSource = EXCLUDED.EnvVarSource"
			_, err := tx.Exec(context.Background(), localQuery, obj0.GetId(), idx1, idx2, obj2.GetKey(), obj2.GetValue(), obj2.GetEnvVarSource())
			if err != nil {
				return err
			}
		}
		_, err = tx.Exec(context.Background(), "delete from Deployment_Containers_Env where parent_parent_Id = $1 and parent_idx = $2 and idx >= $3", obj0.GetId(), idx1, len(obj1.GetConfig().GetEnv()))
		if err != nil {
			return err
		}
	}
	_, err = tx.Exec(context.Background(), "delete from Deployment_Containers where parent_Id = $1 and idx >= $2", obj0.GetId(), len(obj0.GetContainers()))
	if err != nil {
		return err
	}
	for idx1, obj1 := range obj0.GetPorts() {
		localQuery := "insert into Deployment_Ports(parent_Id, idx, ContainerPort, Protocol, Exposure) values($1, $2, $3, $4, $5) on conflict(parent_Id, idx) do update set parent_Id = EXCLUDED.parent_Id, idx = EXCLUDED.idx, ContainerPort = EXCLUDED.ContainerPort, Protocol = EXCLUDED.Protocol, Exposure = EXCLUDED.Exposure"
		_, err := tx.Exec(context.Background(), localQuery, obj0.GetId(), idx1, obj1.GetContainerPort(), obj1.GetProtocol(), obj1.GetExposure())
		if err != nil {
			return err
		}
		for idx2, obj2 := range obj1.GetExposureInfos() {
			localQuery := "insert into Deployment_Ports_ExposureInfos(parent_parent_Id, parent_idx, idx, Level, ServiceName, ServicePort, NodePort, ExternalIps, ExternalHostnames) values($1, $2, $3, $4, $5, $6, $7, $8, $9) on conflict(parent_parent_Id, parent_idx, idx) do update set parent_parent_Id = EXCLUDED.parent_parent_Id, parent_idx = EXCLUDED.parent_idx, idx = EXCLUDED.idx, Level = EXCLUDED.Level, ServiceName = EXCLUDED.ServiceName, ServicePort = EXCLUDED.ServicePort, NodePort = EXCLUDED.NodePort, ExternalIps = EXCLUDED.ExternalIps, ExternalHostnames = EXCLUDED.ExternalHostnames"
			_, err := tx.Exec(context.Background(), localQuery, obj0.GetId(), idx1, idx2, obj2.GetLevel(), obj2.GetServiceName(), obj2.GetServicePort(), obj2.GetNodePort(), obj2.GetExternalIps(), obj2.GetExternalHostnames())
			if err != nil {
				return err
			}
		}
		_, err = tx.Exec(context.Background(), "delete from Deployment_Ports_ExposureInfos where parent_parent_Id = $1 and parent_idx = $2 and idx >= $3", obj0.GetId(), idx1, len(obj1.GetExposureInfos()))
		if err != nil {
			return err
		}
	}
	_, err = tx.Exec(context.Background(), "delete from Deployment_Ports where parent_Id = $1 and idx >= $2", obj0.GetId(), len(obj0.GetPorts()))
	if err != nil {
		return err
	}

	doRollback = false
	return tx.Commit(context.Background())
}

func (s *storeImpl) acquireConn(op ops.Op, typ string) (*pgxpool.Conn, func()) {
	defer metrics.SetAcquireDuration(time.Now(), op, typ)
	conn, err := s.db.Acquire(context.Background())
	if err != nil {
		panic(err)
	}
	return conn, conn.Release
}

// UpsertMany batches objects into the DB
func (s *storeImpl) UpsertMany(objs []*storage.Deployment) error {
	if len(objs) == 0 {
		return nil
	}

	batch := &pgx.Batch{}
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.AddMany, "Deployment")
	for _, obj0 := range objs {
		t := time.Now()
		serialized, err := marshaler.MarshalToString(obj0)
		if err != nil {
			return err
		}
		metrics.SetJSONPBOperationDurationTime(t, "Marshal", "Deployment")
		localQuery := "insert into Deployment(serialized, Id, Name, Type, Namespace, NamespaceId, OrchestratorComponent, Labels, PodLabels, Created, ClusterId, ClusterName, Annotations, Priority, ImagePullSecrets, ServiceAccount, ServiceAccountPermissionLevel, RiskScore, ProcessTags) values($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19) on conflict(Id) do update set serialized = EXCLUDED.serialized, Id = EXCLUDED.Id, Name = EXCLUDED.Name, Type = EXCLUDED.Type, Namespace = EXCLUDED.Namespace, NamespaceId = EXCLUDED.NamespaceId, OrchestratorComponent = EXCLUDED.OrchestratorComponent, Labels = EXCLUDED.Labels, PodLabels = EXCLUDED.PodLabels, Created = EXCLUDED.Created, ClusterId = EXCLUDED.ClusterId, ClusterName = EXCLUDED.ClusterName, Annotations = EXCLUDED.Annotations, Priority = EXCLUDED.Priority, ImagePullSecrets = EXCLUDED.ImagePullSecrets, ServiceAccount = EXCLUDED.ServiceAccount, ServiceAccountPermissionLevel = EXCLUDED.ServiceAccountPermissionLevel, RiskScore = EXCLUDED.RiskScore, ProcessTags = EXCLUDED.ProcessTags"
		batch.Queue(localQuery, serialized, obj0.GetId(), obj0.GetName(), obj0.GetType(), obj0.GetNamespace(), obj0.GetNamespaceId(), obj0.GetOrchestratorComponent(), obj0.GetLabels(), obj0.GetPodLabels(), nilOrStringTimestamp(obj0.GetCreated()), obj0.GetClusterId(), obj0.GetClusterName(), obj0.GetAnnotations(), obj0.GetPriority(), obj0.GetImagePullSecrets(), obj0.GetServiceAccount(), obj0.GetServiceAccountPermissionLevel(), obj0.GetRiskScore(), obj0.GetProcessTags())
		for idx1, obj1 := range obj0.GetContainers() {
			localQuery := "insert into Deployment_Containers(parent_Id, idx, Image_Id, Image_Name_Registry, Image_Name_Remote, Image_Name_Tag, Image_Name_FullName, SecurityContext_Privileged, SecurityContext_DropCapabilities, SecurityContext_AddCapabilities, SecurityContext_ReadOnlyRootFilesystem, Resources_CpuCoresRequest, Resources_CpuCoresLimit, Resources_MemoryMbRequest, Resources_MemoryMbLimit) values($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) on conflict(parent_Id, idx) do update set parent_Id = EXCLUDED.parent_Id, idx = EXCLUDED.idx, Image_Id = EXCLUDED.Image_Id, Image_Name_Registry = EXCLUDED.Image_Name_Registry, Image_Name_Remote = EXCLUDED.Image_Name_Remote, Image_Name_Tag = EXCLUDED.Image_Name_Tag, Image_Name_FullName = EXCLUDED.Image_Name_FullName, SecurityContext_Privileged = EXCLUDED.SecurityContext_Privileged, SecurityContext_DropCapabilities = EXCLUDED.SecurityContext_DropCapabilities, SecurityContext_AddCapabilities = EXCLUDED.SecurityContext_AddCapabilities, SecurityContext_ReadOnlyRootFilesystem = EXCLUDED.SecurityContext_ReadOnlyRootFilesystem, Resources_CpuCoresRequest = EXCLUDED.Resources_CpuCoresRequest, Resources_CpuCoresLimit = EXCLUDED.Resources_CpuCoresLimit, Resources_MemoryMbRequest = EXCLUDED.Resources_MemoryMbRequest, Resources_MemoryMbLimit = EXCLUDED.Resources_MemoryMbLimit"
			batch.Queue(localQuery, obj0.GetId(), idx1, obj1.GetImage().GetId(), obj1.GetImage().GetName().GetRegistry(), obj1.GetImage().GetName().GetRemote(), obj1.GetImage().GetName().GetTag(), obj1.GetImage().GetName().GetFullName(), obj1.GetSecurityContext().GetPrivileged(), obj1.GetSecurityContext().GetDropCapabilities(), obj1.GetSecurityContext().GetAddCapabilities(), obj1.GetSecurityContext().GetReadOnlyRootFilesystem(), obj1.GetResources().GetCpuCoresRequest(), obj1.GetResources().GetCpuCoresLimit(), obj1.GetResources().GetMemoryMbRequest(), obj1.GetResources().GetMemoryMbLimit())
			for idx2, obj2 := range obj1.GetVolumes() {
				localQuery := "insert into Deployment_Containers_Volumes(parent_parent_Id, parent_idx, idx, Name, Source, Destination, ReadOnly, Type) values($1, $2, $3, $4, $5, $6, $7, $8) on conflict(parent_parent_Id, parent_idx, idx) do update set parent_parent_Id = EXCLUDED.parent_parent_Id, parent_idx = EXCLUDED.parent_idx, idx = EXCLUDED.idx, Name = EXCLUDED.Name, Source = EXCLUDED.Source, Destination = EXCLUDED.Destination, ReadOnly = EXCLUDED.ReadOnly, Type = EXCLUDED.Type"
				batch.Queue(localQuery, obj0.GetId(), idx1, idx2, obj2.GetName(), obj2.GetSource(), obj2.GetDestination(), obj2.GetReadOnly(), obj2.GetType())
			}
			batch.Queue("delete from Deployment_Containers_Volumes where parent_parent_Id = $1 and parent_idx = $2 and idx >= $3", obj0.GetId(), idx1, len(obj1.GetVolumes()))
			for idx2, obj2 := range obj1.GetSecrets() {
				localQuery := "insert into Deployment_Containers_Secrets(parent_parent_Id, parent_idx, idx, Name, Path) values($1, $2, $3, $4, $5) on conflict(parent_parent_Id, parent_idx, idx) do update set parent_parent_Id = EXCLUDED.parent_parent_Id, parent_idx = EXCLUDED.parent_idx, idx = EXCLUDED.idx, Name = EXCLUDED.Name, Path = EXCLUDED.Path"
				batch.Queue(localQuery, obj0.GetId(), idx1, idx2, obj2.GetName(), obj2.GetPath())
			}
			batch.Queue("delete from Deployment_Containers_Secrets where parent_parent_Id = $1 and parent_idx = $2 and idx >= $3", obj0.GetId(), idx1, len(obj1.GetSecrets()))
			for idx2, obj2 := range obj1.GetConfig().GetEnv() {
				localQuery := "insert into Deployment_Containers_Env(parent_parent_Id, parent_idx, idx, Key, Value, EnvVarSource) values($1, $2, $3, $4, $5, $6) on conflict(parent_parent_Id, parent_idx, idx) do update set parent_parent_Id = EXCLUDED.parent_parent_Id, parent_idx = EXCLUDED.parent_idx, idx = EXCLUDED.idx, Key = EXCLUDED.Key, Value = EXCLUDED.Value, EnvVarSource = EXCLUDED.EnvVarSource"
				batch.Queue(localQuery, obj0.GetId(), idx1, idx2, obj2.GetKey(), obj2.GetValue(), obj2.GetEnvVarSource())
			}
			batch.Queue("delete from Deployment_Containers_Env where parent_parent_Id = $1 and parent_idx = $2 and idx >= $3", obj0.GetId(), idx1, len(obj1.GetConfig().GetEnv()))
		}
		batch.Queue("delete from Deployment_Containers where parent_Id = $1 and idx >= $2", obj0.GetId(), len(obj0.GetContainers()))
		for idx1, obj1 := range obj0.GetPorts() {
			localQuery := "insert into Deployment_Ports(parent_Id, idx, ContainerPort, Protocol, Exposure) values($1, $2, $3, $4, $5) on conflict(parent_Id, idx) do update set parent_Id = EXCLUDED.parent_Id, idx = EXCLUDED.idx, ContainerPort = EXCLUDED.ContainerPort, Protocol = EXCLUDED.Protocol, Exposure = EXCLUDED.Exposure"
			batch.Queue(localQuery, obj0.GetId(), idx1, obj1.GetContainerPort(), obj1.GetProtocol(), obj1.GetExposure())
			for idx2, obj2 := range obj1.GetExposureInfos() {
				localQuery := "insert into Deployment_Ports_ExposureInfos(parent_parent_Id, parent_idx, idx, Level, ServiceName, ServicePort, NodePort, ExternalIps, ExternalHostnames) values($1, $2, $3, $4, $5, $6, $7, $8, $9) on conflict(parent_parent_Id, parent_idx, idx) do update set parent_parent_Id = EXCLUDED.parent_parent_Id, parent_idx = EXCLUDED.parent_idx, idx = EXCLUDED.idx, Level = EXCLUDED.Level, ServiceName = EXCLUDED.ServiceName, ServicePort = EXCLUDED.ServicePort, NodePort = EXCLUDED.NodePort, ExternalIps = EXCLUDED.ExternalIps, ExternalHostnames = EXCLUDED.ExternalHostnames"
				batch.Queue(localQuery, obj0.GetId(), idx1, idx2, obj2.GetLevel(), obj2.GetServiceName(), obj2.GetServicePort(), obj2.GetNodePort(), obj2.GetExternalIps(), obj2.GetExternalHostnames())
			}
			batch.Queue("delete from Deployment_Ports_ExposureInfos where parent_parent_Id = $1 and parent_idx = $2 and idx >= $3", obj0.GetId(), idx1, len(obj1.GetExposureInfos()))
		}
		batch.Queue("delete from Deployment_Ports where parent_Id = $1 and idx >= $2", obj0.GetId(), len(obj0.GetPorts()))

	}

	conn, release := s.acquireConn(ops.AddMany, "Deployment")
	defer release()

	results := conn.SendBatch(context.Background(), batch)
	if err := results.Close(); err != nil {
		return err
	}
	return nil
}

// Delete removes the specified ID from the store
func (s *storeImpl) Delete(id string) error {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.Remove, "Deployment")

	conn, release := s.acquireConn(ops.Remove, "Deployment")
	defer release()

	if _, err := conn.Exec(context.Background(), deleteStmt, id); err != nil {
		return err
	}
	return nil
}

// GetIDs returns all the IDs for the store
func (s *storeImpl) GetIDs() ([]string, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.GetAll, "DeploymentIDs")

	rows, err := s.db.Query(context.Background(), getIDsStmt)
	if err != nil {
		return nil, nilNoRows(err)
	}
	defer rows.Close()
	var ids []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	return ids, nil
}

// GetMany returns the objects specified by the IDs or the index in the missing indices slice
func (s *storeImpl) GetMany(ids []string) ([]*storage.Deployment, []int, error) {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.GetMany, "Deployment")

	conn, release := s.acquireConn(ops.GetMany, "Deployment")
	defer release()

	rows, err := conn.Query(context.Background(), getManyStmt, ids)
	if err != nil {
		if err == pgx.ErrNoRows {
			missingIndices := make([]int, 0, len(ids))
			for i := range ids {
				missingIndices = append(missingIndices, i)
			}
			return nil, missingIndices, nil
		}
		return nil, nil, err
	}
	defer rows.Close()
	elems := make([]*storage.Deployment, 0, len(ids))
	foundSet := make(map[string]struct{})
	for rows.Next() {
		var data []byte
		if err := rows.Scan(&data); err != nil {
			return nil, nil, err
		}
		var msg storage.Deployment
		buf := bytes.NewBuffer(data)
		t := time.Now()
		if err := jsonpb.Unmarshal(buf, &msg); err != nil {
			return nil, nil, err
		}
		metrics.SetJSONPBOperationDurationTime(t, "Unmarshal", "Deployment")
		foundSet[msg.GetId()] = struct{}{}
		elems = append(elems, &msg)
	}
	missingIndices := make([]int, 0, len(ids)-len(foundSet))
	for i, id := range ids {
		if _, ok := foundSet[id]; !ok {
			missingIndices = append(missingIndices, i)
		}
	}
	return elems, missingIndices, nil
}

// Delete removes the specified IDs from the store
func (s *storeImpl) DeleteMany(ids []string) error {
	defer metrics.SetPostgresOperationDurationTime(time.Now(), ops.RemoveMany, "Deployment")

	conn, release := s.acquireConn(ops.RemoveMany, "Deployment")
	defer release()
	if _, err := conn.Exec(context.Background(), deleteManyStmt, ids); err != nil {
		return err
	}
	return nil
}

// Walk iterates over all of the objects in the store and applies the closure
func (s *storeImpl) Walk(fn func(obj *storage.Deployment) error) error {
	rows, err := s.db.Query(context.Background(), walkStmt)
	if err != nil {
		return nilNoRows(err)
	}
	defer rows.Close()
	for rows.Next() {
		var data []byte
		if err := rows.Scan(&data); err != nil {
			return err
		}
		var msg storage.Deployment
		buf := bytes.NewReader(data)
		if err := jsonpb.Unmarshal(buf, &msg); err != nil {
			return err
		}
		return fn(&msg)
	}
	return nil
}

// AckKeysIndexed acknowledges the passed keys were indexed
func (s *storeImpl) AckKeysIndexed(keys ...string) error {
	return nil
}

// GetKeysToIndex returns the keys that need to be indexed
func (s *storeImpl) GetKeysToIndex() ([]string, error) {
	return nil, nil
}
