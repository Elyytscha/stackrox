syntax = "proto3";

option go_package = "storage";
option java_package = "io.stackrox.proto.storage";

import "google/protobuf/timestamp.proto";
import "storage/risk.proto";
// TODO: Remove when migration is in place
import "storage/cve.proto";
import "protobuf/gogoproto/gogo.proto";

package storage;

// Next Tag: 12
message Image {
    string    id                           = 4 [(gogoproto.moretags) = "search:\"Image Sha,store,hidden\""];
    ImageName name                         = 1;

    ImageMetadata  metadata                = 2;
    ImageScan      scan                    = 3;

    // TODO: Remove when migration is in place, we should get this from relationship instead
    oneof set_components {
        int32 components                   = 7 [(gogoproto.moretags) = "search:\"Component Count,store\""];
    }

    // TODO: Remove when migration is in place, we should get this from relationship instead
    oneof set_cves {
        int32 cves                         = 8 [(gogoproto.moretags) = "search:\"CVE Count,store\""];
    }
    // TODO: Remove when migration is in place, we should get this from relationship instead
    oneof set_fixable {
        int32 fixable_cves                 = 9 [(gogoproto.moretags) = "search:\"Fixable CVE Count,store\""];
    }

    google.protobuf.Timestamp last_updated = 5 [(gogoproto.moretags) = "search:\"Last Updated,hidden\""];

    bool not_pullable                      = 10;

    reserved 6;  // was map<string,string> clusterns_scopes
    int64 priority                         = 11;
}

message ImageScan {
    google.protobuf.Timestamp           scan_time  = 1 [(gogoproto.moretags) = "search:\"Image Scan Time,store\""];
    repeated EmbeddedImageScanComponent components = 2;
}

// TODO: Remove when migration is in place
message EmbeddedImageScanComponent {
    string                         name     = 1 [(gogoproto.moretags) = "search:\"Component,store\""];
    string                         version  = 2 [(gogoproto.moretags) = "search:\"Component Version,store\""];
    License                        license  = 3;
    repeated EmbeddedVulnerability vulns    = 4;
    oneof has_layer_index {
        int32 layer_index                   = 5;
    }
    int64                          priority = 6;
    enum SourceType {
        OS     = 0;
        PYTHON = 1;
        JAVA   = 2;
        RUBY   = 3;
        NODEJS = 4;
    }
    SourceType                      source   = 7;
    string                          location = 8;
}

message License {
    string name = 1;
    string type = 2;
    string url  = 3;
}

// TODO: Remove when migration is in place
message EmbeddedVulnerability {
    enum ScoreVersion {
        V2 = 0; // No unset for automatic backwards compatibility
        V3 = 1;
    }

    enum VulnerabilityType {
        UNKNOWN_VULNERABILITY = 0;
        IMAGE_VULNERABILITY = 1;
        K8S_VULNERABILITY = 2;
        ISTIO_VULNERABILITY = 3;
    }

    string cve                              = 1 [(gogoproto.moretags) = "search:\"CVE,store\""];
    float  cvss                             = 2 [(gogoproto.moretags) = "search:\"CVSS,store\""];
    string summary                          = 3;
    string link                             = 4;
    oneof set_fixed_by {
        string fixed_by                     = 5 [(gogoproto.moretags) = "search:\"Fixed By,store\""];
    }
    ScoreVersion score_version              = 8;
    CVSSV2 cvss_v2                          = 6;
    CVSSV3 cvss_v3                          = 7;
    google.protobuf.Timestamp published_on  = 9;
    google.protobuf.Timestamp last_modified = 10;
    VulnerabilityType vulnerability_type    = 11;
}

message ImageMetadata {
    // V1Metadata contains all of the V1 docker data. In the normal case we will get this because the image is a
    // V1 image OR because the v2 manifest has a link to it in it's config.
    // See https://docs.docker.com/registry/spec/manifest-v2-2/#image-manifest-field-descriptions
    // The only time we will not get it is in the rare caseof a strictly V2 image schema
    V1Metadata                v1         = 1;
    // We should always get V2 metadata unless the registry is old or the image is strictly V1
    V2Metadata                v2         = 2;
    // We never need both sets of layers so consolidate them. They will be ordered by oldest->newest
    repeated string           layer_shas = 3;
}

message V2Metadata {
    string                    digest = 1;
}

message V1Metadata {
    string                    digest     = 1;
    google.protobuf.Timestamp created    = 2 [(gogoproto.moretags) = "search:\"Image Created Time,store\""];
    string                    author     = 3;
    repeated ImageLayer       layers     = 4;
    string                    user       = 5 [(gogoproto.moretags) = "search:\"Image User\""];
    repeated string           command    = 6 [(gogoproto.moretags) = "search:\"Image Command\""];
    repeated string           entrypoint = 7 [(gogoproto.moretags) = "search:\"Image Entrypoint\""];
    repeated string           volumes    = 8 [(gogoproto.moretags) = "search:\"Image Volumes\""];
}

message ImageLayer {
    string instruction                     = 1 [(gogoproto.moretags) = "search:\"Dockerfile Instruction Keyword,store\""];
    string value                           = 2 [(gogoproto.moretags) = "search:\"Dockerfile Instruction Value,store\""];
    google.protobuf.Timestamp created      = 3;
    string author                          = 4;
    repeated EmbeddedImageScanComponent DEPRECATED_components = 5; // replaced by layer index reference in Scan
    bool empty                             = 6;
}

message ImageName {
    string registry                         = 1 [(gogoproto.moretags) = "search:\"Image Registry,store\""];
    string remote                           = 2 [(gogoproto.moretags) = "search:\"Image Remote,store\""];
    string tag                              = 3 [(gogoproto.moretags) = "search:\"Image Tag,store\""];
    string full_name                        = 4 [(gogoproto.moretags) = "search:\"Image,store,analyzer=standard\""];
}

message ListImage {
    string id                              = 7;
    string name                            = 2;
    oneof set_components {
        int32 components                   = 3;
    }
    oneof set_cves {
        int32 cves                         = 4;
    }
    oneof set_fixable {
        int32 fixable_cves                 = 5;
    }
    google.protobuf.Timestamp created      = 6;
    google.protobuf.Timestamp last_updated = 8;

    reserved 9;  // was map<string, string> clusterns_scopes
    int64 priority                         = 10;
}

message ImageComponentEdge {
    // base 64 encoded Image:Component ids.
    string id = 1;

    /// Layer that contains this component
    oneof has_layer_index {
        int32 layer_index = 2;
    }
}
