package main

import (
	"fmt"
	"os"
	"sort"

	"github.com/dave/jennifer/jen"
	"github.com/spf13/cobra"
	"github.com/stackrox/rox/pkg/set"
	"github.com/stackrox/rox/pkg/utils"
	"github.com/stackrox/rox/tools/generate-helpers/boltbindings/operations"
	"github.com/stackrox/rox/tools/generate-helpers/boltbindings/packagenames"
)

func generateFunctions(props *operations.GeneratorProperties, methods []string) (interfaceMethods []jen.Code, implementations []jen.Code) {
	// Generate code in a deterministic order so the style checker doesn't complain about stale generated code
	sort.Strings(methods)
	for _, method := range methods {
		interfaceMethod, implementation := operations.GenerateInterfaceAndImplementation(method, props)
		interfaceMethods = append(interfaceMethods, interfaceMethod)
		implementations = append(implementations, implementation)
	}
	return
}

const (
	bucketNameVariable = "bucketName"
)

func newFile() *jen.File {
	f := jen.NewFile("store")
	f.HeaderComment("Code generated by boltbindings generator. DO NOT EDIT.")
	return f
}

func generateInterfaceFile(interfaceMethods []jen.Code) error {
	f := newFile()
	f.Type().Id("Store").Interface(interfaceMethods...)

	f.Func().Id("New").Params(jen.Id("db").Op("*").Qual(packagenames.BBolt, "DB")).
		Parens(jen.List(jen.Id("Store"), jen.Error())).
		Block(jen.Return(jen.Id("newStore").Call(jen.Id("db"))))
	return f.Save("store.go")
}

func generateSingletonFile() error {
	f := newFile()

	f.Var().Defs(
		jen.Id("singleton").Id("Store"),
		jen.Id("singletonInit").Qual(packagenames.PrefixRoxPkg("sync"), "Once"),
	)

	f.Func().Id("Singleton").Params().Id("Store").Block(
		jen.Id("singletonInit").Dot("Do").Call(
			jen.Func().Params().Block(
				jen.List(jen.Id("store"), jen.Err()).
					Op(":=").
					Id("New").Call(jen.Qual(packagenames.PrefixRox("central/globaldb"), "GetGlobalDB").Call()),
				jen.Qual(packagenames.PrefixRoxPkg("utils"), "Must").Call(jen.Err()),
				jen.Id("singleton").Op("=").Id("store"),
			),
		),
		jen.Return(jen.Id("singleton")),
	)
	return f.Save("singleton.go")
}

func generateStoreImplFile(implementations []jen.Code, props *operations.GeneratorProperties) error {
	f := newFile()
	f.Var().Defs(jen.Id(bucketNameVariable).Op("=").Index().Byte().Parens(jen.Lit(props.BucketName)))

	f.Type().Id("store").Struct(
		jen.Id("crud").Qual(packagenames.BoltHelperProto, "MessageCrud"),
	)
	f.Func().Id("key").
		Params(jen.Id("msg").Qual(packagenames.GogoProto, "Message")).Index().Byte().
		Block(
			jen.Return(jen.Index().Byte().Parens(jen.Id("msg").Assert(jen.Op("*").Qual(props.Pkg, props.Object)).Dot(props.IDFunc).Call())),
		)
	f.Line()

	f.Func().Id("alloc").Params().Qual(packagenames.GogoProto, "Message").Block(
		jen.Return(jen.New(jen.Qual(props.Pkg, props.Object))),
	)
	f.Line()

	f.Func().Id("newStore").Params(jen.Id("db").Op("*").Qual(packagenames.BBolt, "DB")).
		Parens(jen.List(jen.Op("*").Id("store"), jen.Error())).Block(
		jen.If(jen.Err().Op(":=").Qual(packagenames.PrefixRoxPkg("bolthelper"), "RegisterBucket").
			Call(jen.Id("db"), jen.Id(bucketNameVariable)),
			jen.Err().Op("!=").Nil(),
		).Block(jen.Return(jen.Nil(), jen.Err())),
		jen.Return(jen.Op("&").Id("store").Values(jen.Dict{
			jen.Id("crud"): jen.Qual(packagenames.BoltHelperProto, "NewMessageCrud").Call(jen.Id("db"), jen.Id(bucketNameVariable),
				jen.Id("key"), jen.Id("alloc")),
		}), jen.Nil()),
	)
	f.Line()

	for _, implementation := range implementations {
		f.Add(implementation)
		f.Line()
	}

	f.Line()

	return f.Save("store_impl.go")
}

func generate(props *operations.GeneratorProperties, methods []string, interfaces []string) error {
	methodsSet := set.NewStringSet(methods...)
	interfaceSet := set.NewStringSet(interfaces...).Difference(methodsSet)
	interfaceMethods, implementations := generateFunctions(props, methodsSet.AsSlice())
	interfaceOnly, _ := generateFunctions(props, interfaceSet.AsSlice())

	if err := generateInterfaceFile(append(interfaceMethods, interfaceOnly...)); err != nil {
		return err
	}
	if err := generateSingletonFile(); err != nil {
		return err
	}
	if err := generateStoreImplFile(implementations, props); err != nil {
		return err
	}

	return nil
}

func checkSupported(methods []string) error {
	for _, method := range methods {
		if !operations.IsSupported(method) {
			return fmt.Errorf("method %q is unsupported", method)
		}
	}
	return nil
}

func main() {
	c := &cobra.Command{
		Use: "generate store implementations",
	}

	props := operations.GeneratorProperties{}
	c.Flags().StringVar(&props.Pkg, "package", "github.com/stackrox/rox/generated/storage", "the package of the object being stored")

	c.Flags().StringVar(&props.Object, "object", "", "the (Go) name of the object being stored")
	utils.Must(c.MarkFlagRequired("object"))

	c.Flags().StringVar(&props.Singular, "singular", "", "the singular name of the object")
	utils.Must(c.MarkFlagRequired("singular"))

	c.Flags().StringVar(&props.Plural, "plural", "", "the plural name of the object (optional; appends 's' to singular by default")

	c.Flags().StringVar(&props.IDFunc, "id-func", "GetId", "the method to invoke on the proto object to get an id out")

	c.Flags().StringVar(&props.IDField, "id-field", "", "if provided the generators will create a random, unique string ID and set this field to that value in the proto")

	interfaces := c.Flags().StringSlice("interfaces", nil, fmt.Sprintf("methods to generate without implementations (supported - %s)", operations.RenderSupportedMethods()))

	methods := c.Flags().StringSlice("methods", nil, fmt.Sprintf("the methods to generate (supported - %s)", operations.RenderSupportedMethods()))
	utils.Must(c.MarkFlagRequired("methods"))

	c.Flags().StringVar(&props.BucketName, "bucket", "", "the name of the bucket")
	utils.Must(c.MarkFlagRequired("bucket"))

	//props.GetExists determines whether get methods will return an "exists" boolean
	c.Flags().BoolVar(&props.GetExists, "get-return-exists", false, "return 'exists' boolean from get calls")

	//props.DeleteExists determines whether delete methods will return an "exists" boolean
	//commented out as this hasn't been implemented yet
	//c.Flags().BoolVar(&props.DeleteExists, "delete-return-exists", false, "return 'exists' boolean from delete calls")

	c.RunE = func(*cobra.Command, []string) error {
		if props.Plural == "" {
			props.Plural = fmt.Sprintf("%ss", props.Singular)
		}
		if err := checkSupported(*methods); err != nil {
			return err
		}
		if err := checkSupported(*interfaces); err != nil {
			return err
		}
		return generate(&props, *methods, *interfaces)
	}

	if err := c.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
