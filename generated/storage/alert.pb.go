// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/alert.proto

package storage

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ViolationState int32

const (
	ViolationState_ACTIVE    ViolationState = 0
	ViolationState_SNOOZED   ViolationState = 1
	ViolationState_RESOLVED  ViolationState = 2
	ViolationState_ATTEMPTED ViolationState = 3
)

var ViolationState_name = map[int32]string{
	0: "ACTIVE",
	1: "SNOOZED",
	2: "RESOLVED",
	3: "ATTEMPTED",
}

var ViolationState_value = map[string]int32{
	"ACTIVE":    0,
	"SNOOZED":   1,
	"RESOLVED":  2,
	"ATTEMPTED": 3,
}

func (x ViolationState) String() string {
	return proto.EnumName(ViolationState_name, int32(x))
}

func (ViolationState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0}
}

type Alert_Resource_ResourceType int32

const (
	Alert_Resource_UNKNOWN    Alert_Resource_ResourceType = 0
	Alert_Resource_SECRETS    Alert_Resource_ResourceType = 1
	Alert_Resource_CONFIGMAPS Alert_Resource_ResourceType = 2
)

var Alert_Resource_ResourceType_name = map[int32]string{
	0: "UNKNOWN",
	1: "SECRETS",
	2: "CONFIGMAPS",
}

var Alert_Resource_ResourceType_value = map[string]int32{
	"UNKNOWN":    0,
	"SECRETS":    1,
	"CONFIGMAPS": 2,
}

func (x Alert_Resource_ResourceType) String() string {
	return proto.EnumName(Alert_Resource_ResourceType_name, int32(x))
}

func (Alert_Resource_ResourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 1, 0}
}

type Alert_Violation_Type int32

const (
	Alert_Violation_GENERIC      Alert_Violation_Type = 0
	Alert_Violation_K8S_EVENT    Alert_Violation_Type = 1
	Alert_Violation_NETWORK_FLOW Alert_Violation_Type = 2
)

var Alert_Violation_Type_name = map[int32]string{
	0: "GENERIC",
	1: "K8S_EVENT",
	2: "NETWORK_FLOW",
}

var Alert_Violation_Type_value = map[string]int32{
	"GENERIC":      0,
	"K8S_EVENT":    1,
	"NETWORK_FLOW": 2,
}

func (x Alert_Violation_Type) String() string {
	return proto.EnumName(Alert_Violation_Type_name, int32(x))
}

func (Alert_Violation_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 2, 0}
}

type Alert struct {
	Id             string         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" sensorhash:"ignore"`
	Policy         *Policy        `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
	LifecycleStage LifecycleStage `protobuf:"varint,3,opt,name=lifecycle_stage,json=lifecycleStage,proto3,enum=storage.LifecycleStage" json:"lifecycle_stage,omitempty"`
	// Types that are valid to be assigned to Entity:
	//	*Alert_Deployment_
	//	*Alert_Image
	//	*Alert_Resource_
	Entity isAlert_Entity `protobuf_oneof:"Entity"`
	// For run-time phase alert, a maximum of 40 violations are retained.
	Violations       []*Alert_Violation      `protobuf:"bytes,5,rep,name=violations,proto3" json:"violations,omitempty"`
	ProcessViolation *Alert_ProcessViolation `protobuf:"bytes,13,opt,name=process_violation,json=processViolation,proto3" json:"process_violation,omitempty"`
	Enforcement      *Alert_Enforcement      `protobuf:"bytes,6,opt,name=enforcement,proto3" json:"enforcement,omitempty"`
	Time             *types.Timestamp        `protobuf:"bytes,7,opt,name=time,proto3" json:"time,omitempty" sensorhash:"ignore"`
	FirstOccurred    *types.Timestamp        `protobuf:"bytes,10,opt,name=first_occurred,json=firstOccurred,proto3" json:"first_occurred,omitempty" sensorhash:"ignore"`
	// The time at which the alert was resolved. Only set if ViolationState is RESOLVED.
	ResolvedAt           *types.Timestamp `protobuf:"bytes,17,opt,name=resolved_at,json=resolvedAt,proto3" json:"resolved_at,omitempty" sensorhash:"ignore"`
	State                ViolationState   `protobuf:"varint,11,opt,name=state,proto3,enum=storage.ViolationState" json:"state,omitempty"`
	SnoozeTill           *types.Timestamp `protobuf:"bytes,12,opt,name=snooze_till,json=snoozeTill,proto3" json:"snooze_till,omitempty"`
	Tags                 []string         `protobuf:"bytes,14,rep,name=tags,proto3" json:"tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Alert) Reset()         { *m = Alert{} }
func (m *Alert) String() string { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()    {}
func (*Alert) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0}
}
func (m *Alert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert.Merge(m, src)
}
func (m *Alert) XXX_Size() int {
	return m.Size()
}
func (m *Alert) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert.DiscardUnknown(m)
}

var xxx_messageInfo_Alert proto.InternalMessageInfo

type isAlert_Entity interface {
	isAlert_Entity()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isAlert_Entity
}

type Alert_Deployment_ struct {
	Deployment *Alert_Deployment `protobuf:"bytes,4,opt,name=deployment,proto3,oneof" json:"deployment,omitempty" sensorhash:"ignore"`
}
type Alert_Image struct {
	Image *ContainerImage `protobuf:"bytes,15,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type Alert_Resource_ struct {
	Resource *Alert_Resource `protobuf:"bytes,16,opt,name=resource,proto3,oneof" json:"resource,omitempty"`
}

func (*Alert_Deployment_) isAlert_Entity() {}
func (m *Alert_Deployment_) Clone() isAlert_Entity {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Deployment_)
	*cloned = *m

	cloned.Deployment = m.Deployment.Clone()
	return cloned
}
func (*Alert_Image) isAlert_Entity() {}
func (m *Alert_Image) Clone() isAlert_Entity {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Image)
	*cloned = *m

	cloned.Image = m.Image.Clone()
	return cloned
}
func (*Alert_Resource_) isAlert_Entity() {}
func (m *Alert_Resource_) Clone() isAlert_Entity {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Resource_)
	*cloned = *m

	cloned.Resource = m.Resource.Clone()
	return cloned
}

func (m *Alert) GetEntity() isAlert_Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *Alert) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Alert) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *Alert) GetLifecycleStage() LifecycleStage {
	if m != nil {
		return m.LifecycleStage
	}
	return LifecycleStage_DEPLOY
}

func (m *Alert) GetDeployment() *Alert_Deployment {
	if x, ok := m.GetEntity().(*Alert_Deployment_); ok {
		return x.Deployment
	}
	return nil
}

func (m *Alert) GetImage() *ContainerImage {
	if x, ok := m.GetEntity().(*Alert_Image); ok {
		return x.Image
	}
	return nil
}

func (m *Alert) GetResource() *Alert_Resource {
	if x, ok := m.GetEntity().(*Alert_Resource_); ok {
		return x.Resource
	}
	return nil
}

func (m *Alert) GetViolations() []*Alert_Violation {
	if m != nil {
		return m.Violations
	}
	return nil
}

func (m *Alert) GetProcessViolation() *Alert_ProcessViolation {
	if m != nil {
		return m.ProcessViolation
	}
	return nil
}

func (m *Alert) GetEnforcement() *Alert_Enforcement {
	if m != nil {
		return m.Enforcement
	}
	return nil
}

func (m *Alert) GetTime() *types.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *Alert) GetFirstOccurred() *types.Timestamp {
	if m != nil {
		return m.FirstOccurred
	}
	return nil
}

func (m *Alert) GetResolvedAt() *types.Timestamp {
	if m != nil {
		return m.ResolvedAt
	}
	return nil
}

func (m *Alert) GetState() ViolationState {
	if m != nil {
		return m.State
	}
	return ViolationState_ACTIVE
}

func (m *Alert) GetSnoozeTill() *types.Timestamp {
	if m != nil {
		return m.SnoozeTill
	}
	return nil
}

func (m *Alert) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Alert) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Alert_Deployment_)(nil),
		(*Alert_Image)(nil),
		(*Alert_Resource_)(nil),
	}
}

func (m *Alert) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Alert) Clone() *Alert {
	if m == nil {
		return nil
	}
	cloned := new(Alert)
	*cloned = *m

	cloned.Policy = m.Policy.Clone()
	if m.Entity != nil {
		cloned.Entity = m.Entity.Clone()
	}
	if m.Violations != nil {
		cloned.Violations = make([]*Alert_Violation, len(m.Violations))
		for idx, v := range m.Violations {
			cloned.Violations[idx] = v.Clone()
		}
	}
	cloned.ProcessViolation = m.ProcessViolation.Clone()
	cloned.Enforcement = m.Enforcement.Clone()
	cloned.Time = m.Time.Clone()
	cloned.FirstOccurred = m.FirstOccurred.Clone()
	cloned.ResolvedAt = m.ResolvedAt.Clone()
	cloned.SnoozeTill = m.SnoozeTill.Clone()
	if m.Tags != nil {
		cloned.Tags = make([]string, len(m.Tags))
		copy(cloned.Tags, m.Tags)
	}
	return cloned
}

type Alert_Deployment struct {
	Id                   string                        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string                        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type                 string                        `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Namespace            string                        `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
	NamespaceId          string                        `protobuf:"bytes,16,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	Labels               map[string]string             `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ClusterId            string                        `protobuf:"bytes,9,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	ClusterName          string                        `protobuf:"bytes,10,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
	Containers           []*Alert_Deployment_Container `protobuf:"bytes,11,rep,name=containers,proto3" json:"containers,omitempty"`
	Annotations          map[string]string             `protobuf:"bytes,14,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Inactive             bool                          `protobuf:"varint,15,opt,name=inactive,proto3" json:"inactive,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Alert_Deployment) Reset()         { *m = Alert_Deployment{} }
func (m *Alert_Deployment) String() string { return proto.CompactTextString(m) }
func (*Alert_Deployment) ProtoMessage()    {}
func (*Alert_Deployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 0}
}
func (m *Alert_Deployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert_Deployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert_Deployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert_Deployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert_Deployment.Merge(m, src)
}
func (m *Alert_Deployment) XXX_Size() int {
	return m.Size()
}
func (m *Alert_Deployment) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert_Deployment.DiscardUnknown(m)
}

var xxx_messageInfo_Alert_Deployment proto.InternalMessageInfo

func (m *Alert_Deployment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Alert_Deployment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Alert_Deployment) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Alert_Deployment) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Alert_Deployment) GetNamespaceId() string {
	if m != nil {
		return m.NamespaceId
	}
	return ""
}

func (m *Alert_Deployment) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Alert_Deployment) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *Alert_Deployment) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *Alert_Deployment) GetContainers() []*Alert_Deployment_Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *Alert_Deployment) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Alert_Deployment) GetInactive() bool {
	if m != nil {
		return m.Inactive
	}
	return false
}

func (m *Alert_Deployment) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Alert_Deployment) Clone() *Alert_Deployment {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Deployment)
	*cloned = *m

	if m.Labels != nil {
		cloned.Labels = make(map[string]string, len(m.Labels))
		for k, v := range m.Labels {
			cloned.Labels[k] = v
		}
	}
	if m.Containers != nil {
		cloned.Containers = make([]*Alert_Deployment_Container, len(m.Containers))
		for idx, v := range m.Containers {
			cloned.Containers[idx] = v.Clone()
		}
	}
	if m.Annotations != nil {
		cloned.Annotations = make(map[string]string, len(m.Annotations))
		for k, v := range m.Annotations {
			cloned.Annotations[k] = v
		}
	}
	return cloned
}

type Alert_Deployment_Container struct {
	Image                *ContainerImage `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	Name                 string          `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Alert_Deployment_Container) Reset()         { *m = Alert_Deployment_Container{} }
func (m *Alert_Deployment_Container) String() string { return proto.CompactTextString(m) }
func (*Alert_Deployment_Container) ProtoMessage()    {}
func (*Alert_Deployment_Container) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 0, 1}
}
func (m *Alert_Deployment_Container) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert_Deployment_Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert_Deployment_Container.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert_Deployment_Container) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert_Deployment_Container.Merge(m, src)
}
func (m *Alert_Deployment_Container) XXX_Size() int {
	return m.Size()
}
func (m *Alert_Deployment_Container) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert_Deployment_Container.DiscardUnknown(m)
}

var xxx_messageInfo_Alert_Deployment_Container proto.InternalMessageInfo

func (m *Alert_Deployment_Container) GetImage() *ContainerImage {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Alert_Deployment_Container) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Alert_Deployment_Container) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Alert_Deployment_Container) Clone() *Alert_Deployment_Container {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Deployment_Container)
	*cloned = *m

	cloned.Image = m.Image.Clone()
	return cloned
}

// Represents an alert on a kubernetes resource (configmaps, secrets, etc.)
type Alert_Resource struct {
	ResourceType         Alert_Resource_ResourceType `protobuf:"varint,1,opt,name=resource_type,json=resourceType,proto3,enum=storage.Alert_Resource_ResourceType" json:"resource_type,omitempty"`
	Name                 string                      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	ClusterId            string                      `protobuf:"bytes,3,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	ClusterName          string                      `protobuf:"bytes,4,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
	Namespace            string                      `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty"`
	NamespaceId          string                      `protobuf:"bytes,6,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Alert_Resource) Reset()         { *m = Alert_Resource{} }
func (m *Alert_Resource) String() string { return proto.CompactTextString(m) }
func (*Alert_Resource) ProtoMessage()    {}
func (*Alert_Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 1}
}
func (m *Alert_Resource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert_Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert_Resource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert_Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert_Resource.Merge(m, src)
}
func (m *Alert_Resource) XXX_Size() int {
	return m.Size()
}
func (m *Alert_Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Alert_Resource proto.InternalMessageInfo

func (m *Alert_Resource) GetResourceType() Alert_Resource_ResourceType {
	if m != nil {
		return m.ResourceType
	}
	return Alert_Resource_UNKNOWN
}

func (m *Alert_Resource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Alert_Resource) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *Alert_Resource) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *Alert_Resource) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Alert_Resource) GetNamespaceId() string {
	if m != nil {
		return m.NamespaceId
	}
	return ""
}

func (m *Alert_Resource) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Alert_Resource) Clone() *Alert_Resource {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Resource)
	*cloned = *m

	return cloned
}

type Alert_Violation struct {
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// Types that are valid to be assigned to MessageAttributes:
	//	*Alert_Violation_KeyValueAttrs_
	//	*Alert_Violation_NetworkFlowInfo_
	MessageAttributes isAlert_Violation_MessageAttributes `protobuf_oneof:"MessageAttributes"`
	// 'type' is for internal use only.
	Type Alert_Violation_Type `protobuf:"varint,5,opt,name=type,proto3,enum=storage.Alert_Violation_Type" json:"type,omitempty"`
	// Indicates violation time. This field differs from top-level field 'time' which represents last time the alert
	// occurred in case of multiple occurrences of the policy alert. As of 55.0, this field is set only for kubernetes
	// event violations, but may not be limited to it in future.
	Time                 *types.Timestamp `protobuf:"bytes,6,opt,name=time,proto3" json:"time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Alert_Violation) Reset()         { *m = Alert_Violation{} }
func (m *Alert_Violation) String() string { return proto.CompactTextString(m) }
func (*Alert_Violation) ProtoMessage()    {}
func (*Alert_Violation) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 2}
}
func (m *Alert_Violation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert_Violation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert_Violation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert_Violation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert_Violation.Merge(m, src)
}
func (m *Alert_Violation) XXX_Size() int {
	return m.Size()
}
func (m *Alert_Violation) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert_Violation.DiscardUnknown(m)
}

var xxx_messageInfo_Alert_Violation proto.InternalMessageInfo

type isAlert_Violation_MessageAttributes interface {
	isAlert_Violation_MessageAttributes()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isAlert_Violation_MessageAttributes
}

type Alert_Violation_KeyValueAttrs_ struct {
	KeyValueAttrs *Alert_Violation_KeyValueAttrs `protobuf:"bytes,4,opt,name=key_value_attrs,json=keyValueAttrs,proto3,oneof" json:"key_value_attrs,omitempty"`
}
type Alert_Violation_NetworkFlowInfo_ struct {
	NetworkFlowInfo *Alert_Violation_NetworkFlowInfo `protobuf:"bytes,7,opt,name=network_flow_info,json=networkFlowInfo,proto3,oneof" json:"network_flow_info,omitempty"`
}

func (*Alert_Violation_KeyValueAttrs_) isAlert_Violation_MessageAttributes() {}
func (m *Alert_Violation_KeyValueAttrs_) Clone() isAlert_Violation_MessageAttributes {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Violation_KeyValueAttrs_)
	*cloned = *m

	cloned.KeyValueAttrs = m.KeyValueAttrs.Clone()
	return cloned
}
func (*Alert_Violation_NetworkFlowInfo_) isAlert_Violation_MessageAttributes() {}
func (m *Alert_Violation_NetworkFlowInfo_) Clone() isAlert_Violation_MessageAttributes {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Violation_NetworkFlowInfo_)
	*cloned = *m

	cloned.NetworkFlowInfo = m.NetworkFlowInfo.Clone()
	return cloned
}

func (m *Alert_Violation) GetMessageAttributes() isAlert_Violation_MessageAttributes {
	if m != nil {
		return m.MessageAttributes
	}
	return nil
}

func (m *Alert_Violation) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Alert_Violation) GetKeyValueAttrs() *Alert_Violation_KeyValueAttrs {
	if x, ok := m.GetMessageAttributes().(*Alert_Violation_KeyValueAttrs_); ok {
		return x.KeyValueAttrs
	}
	return nil
}

func (m *Alert_Violation) GetNetworkFlowInfo() *Alert_Violation_NetworkFlowInfo {
	if x, ok := m.GetMessageAttributes().(*Alert_Violation_NetworkFlowInfo_); ok {
		return x.NetworkFlowInfo
	}
	return nil
}

func (m *Alert_Violation) GetType() Alert_Violation_Type {
	if m != nil {
		return m.Type
	}
	return Alert_Violation_GENERIC
}

func (m *Alert_Violation) GetTime() *types.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Alert_Violation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Alert_Violation_KeyValueAttrs_)(nil),
		(*Alert_Violation_NetworkFlowInfo_)(nil),
	}
}

func (m *Alert_Violation) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Alert_Violation) Clone() *Alert_Violation {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Violation)
	*cloned = *m

	if m.MessageAttributes != nil {
		cloned.MessageAttributes = m.MessageAttributes.Clone()
	}
	cloned.Time = m.Time.Clone()
	return cloned
}

type Alert_Violation_KeyValueAttrs struct {
	Attrs                []*Alert_Violation_KeyValueAttrs_KeyValueAttr `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *Alert_Violation_KeyValueAttrs) Reset()         { *m = Alert_Violation_KeyValueAttrs{} }
func (m *Alert_Violation_KeyValueAttrs) String() string { return proto.CompactTextString(m) }
func (*Alert_Violation_KeyValueAttrs) ProtoMessage()    {}
func (*Alert_Violation_KeyValueAttrs) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 2, 0}
}
func (m *Alert_Violation_KeyValueAttrs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert_Violation_KeyValueAttrs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert_Violation_KeyValueAttrs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert_Violation_KeyValueAttrs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert_Violation_KeyValueAttrs.Merge(m, src)
}
func (m *Alert_Violation_KeyValueAttrs) XXX_Size() int {
	return m.Size()
}
func (m *Alert_Violation_KeyValueAttrs) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert_Violation_KeyValueAttrs.DiscardUnknown(m)
}

var xxx_messageInfo_Alert_Violation_KeyValueAttrs proto.InternalMessageInfo

func (m *Alert_Violation_KeyValueAttrs) GetAttrs() []*Alert_Violation_KeyValueAttrs_KeyValueAttr {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *Alert_Violation_KeyValueAttrs) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Alert_Violation_KeyValueAttrs) Clone() *Alert_Violation_KeyValueAttrs {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Violation_KeyValueAttrs)
	*cloned = *m

	if m.Attrs != nil {
		cloned.Attrs = make([]*Alert_Violation_KeyValueAttrs_KeyValueAttr, len(m.Attrs))
		for idx, v := range m.Attrs {
			cloned.Attrs[idx] = v.Clone()
		}
	}
	return cloned
}

type Alert_Violation_KeyValueAttrs_KeyValueAttr struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) Reset() {
	*m = Alert_Violation_KeyValueAttrs_KeyValueAttr{}
}
func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) String() string {
	return proto.CompactTextString(m)
}
func (*Alert_Violation_KeyValueAttrs_KeyValueAttr) ProtoMessage() {}
func (*Alert_Violation_KeyValueAttrs_KeyValueAttr) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 2, 0, 0}
}
func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert_Violation_KeyValueAttrs_KeyValueAttr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert_Violation_KeyValueAttrs_KeyValueAttr.Merge(m, src)
}
func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) XXX_Size() int {
	return m.Size()
}
func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert_Violation_KeyValueAttrs_KeyValueAttr.DiscardUnknown(m)
}

var xxx_messageInfo_Alert_Violation_KeyValueAttrs_KeyValueAttr proto.InternalMessageInfo

func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) Clone() *Alert_Violation_KeyValueAttrs_KeyValueAttr {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Violation_KeyValueAttrs_KeyValueAttr)
	*cloned = *m

	return cloned
}

type Alert_Violation_NetworkFlowInfo struct {
	Protocol             L4Protocol                              `protobuf:"varint,1,opt,name=protocol,proto3,enum=storage.L4Protocol" json:"protocol,omitempty"`
	Source               *Alert_Violation_NetworkFlowInfo_Entity `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Destination          *Alert_Violation_NetworkFlowInfo_Entity `protobuf:"bytes,3,opt,name=destination,proto3" json:"destination,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *Alert_Violation_NetworkFlowInfo) Reset()         { *m = Alert_Violation_NetworkFlowInfo{} }
func (m *Alert_Violation_NetworkFlowInfo) String() string { return proto.CompactTextString(m) }
func (*Alert_Violation_NetworkFlowInfo) ProtoMessage()    {}
func (*Alert_Violation_NetworkFlowInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 2, 1}
}
func (m *Alert_Violation_NetworkFlowInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert_Violation_NetworkFlowInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert_Violation_NetworkFlowInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert_Violation_NetworkFlowInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert_Violation_NetworkFlowInfo.Merge(m, src)
}
func (m *Alert_Violation_NetworkFlowInfo) XXX_Size() int {
	return m.Size()
}
func (m *Alert_Violation_NetworkFlowInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert_Violation_NetworkFlowInfo.DiscardUnknown(m)
}

var xxx_messageInfo_Alert_Violation_NetworkFlowInfo proto.InternalMessageInfo

func (m *Alert_Violation_NetworkFlowInfo) GetProtocol() L4Protocol {
	if m != nil {
		return m.Protocol
	}
	return L4Protocol_L4_PROTOCOL_UNKNOWN
}

func (m *Alert_Violation_NetworkFlowInfo) GetSource() *Alert_Violation_NetworkFlowInfo_Entity {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Alert_Violation_NetworkFlowInfo) GetDestination() *Alert_Violation_NetworkFlowInfo_Entity {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *Alert_Violation_NetworkFlowInfo) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Alert_Violation_NetworkFlowInfo) Clone() *Alert_Violation_NetworkFlowInfo {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Violation_NetworkFlowInfo)
	*cloned = *m

	cloned.Source = m.Source.Clone()
	cloned.Destination = m.Destination.Clone()
	return cloned
}

type Alert_Violation_NetworkFlowInfo_Entity struct {
	Name                 string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	EntityType           NetworkEntityInfo_Type `protobuf:"varint,2,opt,name=entity_type,json=entityType,proto3,enum=storage.NetworkEntityInfo_Type" json:"entity_type,omitempty"`
	DeploymentNamespace  string                 `protobuf:"bytes,3,opt,name=deployment_namespace,json=deploymentNamespace,proto3" json:"deployment_namespace,omitempty"`
	DeploymentType       string                 `protobuf:"bytes,5,opt,name=deployment_type,json=deploymentType,proto3" json:"deployment_type,omitempty"`
	Port                 int32                  `protobuf:"varint,6,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *Alert_Violation_NetworkFlowInfo_Entity) Reset() {
	*m = Alert_Violation_NetworkFlowInfo_Entity{}
}
func (m *Alert_Violation_NetworkFlowInfo_Entity) String() string { return proto.CompactTextString(m) }
func (*Alert_Violation_NetworkFlowInfo_Entity) ProtoMessage()    {}
func (*Alert_Violation_NetworkFlowInfo_Entity) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 2, 1, 0}
}
func (m *Alert_Violation_NetworkFlowInfo_Entity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert_Violation_NetworkFlowInfo_Entity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert_Violation_NetworkFlowInfo_Entity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert_Violation_NetworkFlowInfo_Entity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert_Violation_NetworkFlowInfo_Entity.Merge(m, src)
}
func (m *Alert_Violation_NetworkFlowInfo_Entity) XXX_Size() int {
	return m.Size()
}
func (m *Alert_Violation_NetworkFlowInfo_Entity) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert_Violation_NetworkFlowInfo_Entity.DiscardUnknown(m)
}

var xxx_messageInfo_Alert_Violation_NetworkFlowInfo_Entity proto.InternalMessageInfo

func (m *Alert_Violation_NetworkFlowInfo_Entity) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Alert_Violation_NetworkFlowInfo_Entity) GetEntityType() NetworkEntityInfo_Type {
	if m != nil {
		return m.EntityType
	}
	return NetworkEntityInfo_UNKNOWN_TYPE
}

func (m *Alert_Violation_NetworkFlowInfo_Entity) GetDeploymentNamespace() string {
	if m != nil {
		return m.DeploymentNamespace
	}
	return ""
}

func (m *Alert_Violation_NetworkFlowInfo_Entity) GetDeploymentType() string {
	if m != nil {
		return m.DeploymentType
	}
	return ""
}

func (m *Alert_Violation_NetworkFlowInfo_Entity) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Alert_Violation_NetworkFlowInfo_Entity) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Alert_Violation_NetworkFlowInfo_Entity) Clone() *Alert_Violation_NetworkFlowInfo_Entity {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Violation_NetworkFlowInfo_Entity)
	*cloned = *m

	return cloned
}

type Alert_ProcessViolation struct {
	Message              string              `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Processes            []*ProcessIndicator `protobuf:"bytes,2,rep,name=processes,proto3" json:"processes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Alert_ProcessViolation) Reset()         { *m = Alert_ProcessViolation{} }
func (m *Alert_ProcessViolation) String() string { return proto.CompactTextString(m) }
func (*Alert_ProcessViolation) ProtoMessage()    {}
func (*Alert_ProcessViolation) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 3}
}
func (m *Alert_ProcessViolation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert_ProcessViolation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert_ProcessViolation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert_ProcessViolation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert_ProcessViolation.Merge(m, src)
}
func (m *Alert_ProcessViolation) XXX_Size() int {
	return m.Size()
}
func (m *Alert_ProcessViolation) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert_ProcessViolation.DiscardUnknown(m)
}

var xxx_messageInfo_Alert_ProcessViolation proto.InternalMessageInfo

func (m *Alert_ProcessViolation) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Alert_ProcessViolation) GetProcesses() []*ProcessIndicator {
	if m != nil {
		return m.Processes
	}
	return nil
}

func (m *Alert_ProcessViolation) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Alert_ProcessViolation) Clone() *Alert_ProcessViolation {
	if m == nil {
		return nil
	}
	cloned := new(Alert_ProcessViolation)
	*cloned = *m

	if m.Processes != nil {
		cloned.Processes = make([]*ProcessIndicator, len(m.Processes))
		for idx, v := range m.Processes {
			cloned.Processes[idx] = v.Clone()
		}
	}
	return cloned
}

type Alert_Enforcement struct {
	Action               EnforcementAction `protobuf:"varint,1,opt,name=action,proto3,enum=storage.EnforcementAction" json:"action,omitempty"`
	Message              string            `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Alert_Enforcement) Reset()         { *m = Alert_Enforcement{} }
func (m *Alert_Enforcement) String() string { return proto.CompactTextString(m) }
func (*Alert_Enforcement) ProtoMessage()    {}
func (*Alert_Enforcement) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{0, 4}
}
func (m *Alert_Enforcement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert_Enforcement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert_Enforcement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert_Enforcement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert_Enforcement.Merge(m, src)
}
func (m *Alert_Enforcement) XXX_Size() int {
	return m.Size()
}
func (m *Alert_Enforcement) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert_Enforcement.DiscardUnknown(m)
}

var xxx_messageInfo_Alert_Enforcement proto.InternalMessageInfo

func (m *Alert_Enforcement) GetAction() EnforcementAction {
	if m != nil {
		return m.Action
	}
	return EnforcementAction_UNSET_ENFORCEMENT
}

func (m *Alert_Enforcement) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Alert_Enforcement) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Alert_Enforcement) Clone() *Alert_Enforcement {
	if m == nil {
		return nil
	}
	cloned := new(Alert_Enforcement)
	*cloned = *m

	return cloned
}

type ListAlert struct {
	Id                   string               `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	LifecycleStage       LifecycleStage       `protobuf:"varint,2,opt,name=lifecycle_stage,json=lifecycleStage,proto3,enum=storage.LifecycleStage" json:"lifecycle_stage,omitempty" search:"Lifecycle Stage,store"`
	Time                 *types.Timestamp     `protobuf:"bytes,3,opt,name=time,proto3" json:"time,omitempty" search:"Violation Time"`
	Policy               *ListAlertPolicy     `protobuf:"bytes,4,opt,name=policy,proto3" json:"policy,omitempty"`
	Deployment           *ListAlertDeployment `protobuf:"bytes,5,opt,name=deployment,proto3" json:"deployment,omitempty"`
	State                ViolationState       `protobuf:"varint,6,opt,name=state,proto3,enum=storage.ViolationState" json:"state,omitempty" search:"Violation State,store"`
	EnforcementCount     int32                `protobuf:"varint,7,opt,name=enforcement_count,json=enforcementCount,proto3" json:"enforcement_count,omitempty"`
	Tags                 []string             `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty" search:"Tag,store"`
	EnforcementAction    EnforcementAction    `protobuf:"varint,9,opt,name=enforcement_action,json=enforcementAction,proto3,enum=storage.EnforcementAction" json:"enforcement_action,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ListAlert) Reset()         { *m = ListAlert{} }
func (m *ListAlert) String() string { return proto.CompactTextString(m) }
func (*ListAlert) ProtoMessage()    {}
func (*ListAlert) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{1}
}
func (m *ListAlert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAlert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAlert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAlert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAlert.Merge(m, src)
}
func (m *ListAlert) XXX_Size() int {
	return m.Size()
}
func (m *ListAlert) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAlert.DiscardUnknown(m)
}

var xxx_messageInfo_ListAlert proto.InternalMessageInfo

func (m *ListAlert) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ListAlert) GetLifecycleStage() LifecycleStage {
	if m != nil {
		return m.LifecycleStage
	}
	return LifecycleStage_DEPLOY
}

func (m *ListAlert) GetTime() *types.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *ListAlert) GetPolicy() *ListAlertPolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *ListAlert) GetDeployment() *ListAlertDeployment {
	if m != nil {
		return m.Deployment
	}
	return nil
}

func (m *ListAlert) GetState() ViolationState {
	if m != nil {
		return m.State
	}
	return ViolationState_ACTIVE
}

func (m *ListAlert) GetEnforcementCount() int32 {
	if m != nil {
		return m.EnforcementCount
	}
	return 0
}

func (m *ListAlert) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *ListAlert) GetEnforcementAction() EnforcementAction {
	if m != nil {
		return m.EnforcementAction
	}
	return EnforcementAction_UNSET_ENFORCEMENT
}

func (m *ListAlert) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ListAlert) Clone() *ListAlert {
	if m == nil {
		return nil
	}
	cloned := new(ListAlert)
	*cloned = *m

	cloned.Time = m.Time.Clone()
	cloned.Policy = m.Policy.Clone()
	cloned.Deployment = m.Deployment.Clone()
	if m.Tags != nil {
		cloned.Tags = make([]string, len(m.Tags))
		copy(cloned.Tags, m.Tags)
	}
	return cloned
}

type ListAlertPolicy struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Policy ID,store,hidden"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" search:"Policy,store"`
	Severity             Severity `protobuf:"varint,3,opt,name=severity,proto3,enum=storage.Severity" json:"severity,omitempty" search:"Severity,store"`
	Description          string   `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Categories           []string `protobuf:"bytes,5,rep,name=categories,proto3" json:"categories,omitempty" search:"Category,store"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAlertPolicy) Reset()         { *m = ListAlertPolicy{} }
func (m *ListAlertPolicy) String() string { return proto.CompactTextString(m) }
func (*ListAlertPolicy) ProtoMessage()    {}
func (*ListAlertPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{2}
}
func (m *ListAlertPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAlertPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAlertPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAlertPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAlertPolicy.Merge(m, src)
}
func (m *ListAlertPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ListAlertPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAlertPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ListAlertPolicy proto.InternalMessageInfo

func (m *ListAlertPolicy) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ListAlertPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListAlertPolicy) GetSeverity() Severity {
	if m != nil {
		return m.Severity
	}
	return Severity_UNSET_SEVERITY
}

func (m *ListAlertPolicy) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ListAlertPolicy) GetCategories() []string {
	if m != nil {
		return m.Categories
	}
	return nil
}

func (m *ListAlertPolicy) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ListAlertPolicy) Clone() *ListAlertPolicy {
	if m == nil {
		return nil
	}
	cloned := new(ListAlertPolicy)
	*cloned = *m

	if m.Categories != nil {
		cloned.Categories = make([]string, len(m.Categories))
		copy(cloned.Categories, m.Categories)
	}
	return cloned
}

type ListAlertDeployment struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" search:"Deployment ID,store,hidden"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" search:"Deployment,store"`
	ClusterName          string   `protobuf:"bytes,4,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty" search:"Cluster,store"`
	Namespace            string   `protobuf:"bytes,5,opt,name=namespace,proto3" json:"namespace,omitempty" search:"Namespace,store"`
	ClusterId            string   `protobuf:"bytes,6,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty" search:"Cluster ID,store"`
	Inactive             bool     `protobuf:"varint,7,opt,name=inactive,proto3" json:"inactive,omitempty" search:"Inactive Deployment"`
	NamespaceId          string   `protobuf:"bytes,8,opt,name=namespace_id,json=namespaceId,proto3" json:"namespace_id,omitempty" search:"Namespace ID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAlertDeployment) Reset()         { *m = ListAlertDeployment{} }
func (m *ListAlertDeployment) String() string { return proto.CompactTextString(m) }
func (*ListAlertDeployment) ProtoMessage()    {}
func (*ListAlertDeployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_bfba8812535cd55e, []int{3}
}
func (m *ListAlertDeployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAlertDeployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAlertDeployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAlertDeployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAlertDeployment.Merge(m, src)
}
func (m *ListAlertDeployment) XXX_Size() int {
	return m.Size()
}
func (m *ListAlertDeployment) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAlertDeployment.DiscardUnknown(m)
}

var xxx_messageInfo_ListAlertDeployment proto.InternalMessageInfo

func (m *ListAlertDeployment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ListAlertDeployment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListAlertDeployment) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *ListAlertDeployment) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListAlertDeployment) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *ListAlertDeployment) GetInactive() bool {
	if m != nil {
		return m.Inactive
	}
	return false
}

func (m *ListAlertDeployment) GetNamespaceId() string {
	if m != nil {
		return m.NamespaceId
	}
	return ""
}

func (m *ListAlertDeployment) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ListAlertDeployment) Clone() *ListAlertDeployment {
	if m == nil {
		return nil
	}
	cloned := new(ListAlertDeployment)
	*cloned = *m

	return cloned
}

func init() {
	proto.RegisterEnum("storage.ViolationState", ViolationState_name, ViolationState_value)
	proto.RegisterEnum("storage.Alert_Resource_ResourceType", Alert_Resource_ResourceType_name, Alert_Resource_ResourceType_value)
	proto.RegisterEnum("storage.Alert_Violation_Type", Alert_Violation_Type_name, Alert_Violation_Type_value)
	proto.RegisterType((*Alert)(nil), "storage.Alert")
	proto.RegisterType((*Alert_Deployment)(nil), "storage.Alert.Deployment")
	proto.RegisterMapType((map[string]string)(nil), "storage.Alert.Deployment.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "storage.Alert.Deployment.LabelsEntry")
	proto.RegisterType((*Alert_Deployment_Container)(nil), "storage.Alert.Deployment.Container")
	proto.RegisterType((*Alert_Resource)(nil), "storage.Alert.Resource")
	proto.RegisterType((*Alert_Violation)(nil), "storage.Alert.Violation")
	proto.RegisterType((*Alert_Violation_KeyValueAttrs)(nil), "storage.Alert.Violation.KeyValueAttrs")
	proto.RegisterType((*Alert_Violation_KeyValueAttrs_KeyValueAttr)(nil), "storage.Alert.Violation.KeyValueAttrs.KeyValueAttr")
	proto.RegisterType((*Alert_Violation_NetworkFlowInfo)(nil), "storage.Alert.Violation.NetworkFlowInfo")
	proto.RegisterType((*Alert_Violation_NetworkFlowInfo_Entity)(nil), "storage.Alert.Violation.NetworkFlowInfo.Entity")
	proto.RegisterType((*Alert_ProcessViolation)(nil), "storage.Alert.ProcessViolation")
	proto.RegisterType((*Alert_Enforcement)(nil), "storage.Alert.Enforcement")
	proto.RegisterType((*ListAlert)(nil), "storage.ListAlert")
	proto.RegisterType((*ListAlertPolicy)(nil), "storage.ListAlertPolicy")
	proto.RegisterType((*ListAlertDeployment)(nil), "storage.ListAlertDeployment")
}

func init() { proto.RegisterFile("storage/alert.proto", fileDescriptor_bfba8812535cd55e) }

var fileDescriptor_bfba8812535cd55e = []byte{
	// 1762 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0xcb, 0x72, 0xdb, 0xc8,
	0x15, 0x15, 0x9f, 0x22, 0x2f, 0x25, 0x0a, 0x6a, 0x39, 0x63, 0x18, 0xb1, 0x45, 0x86, 0x4e, 0x62,
	0x95, 0x33, 0x43, 0xc5, 0x8f, 0x64, 0x1c, 0x8f, 0x26, 0x35, 0xa2, 0x04, 0x5b, 0xb4, 0x64, 0x4a,
	0xd3, 0x62, 0xe4, 0x2a, 0x67, 0xc1, 0x82, 0xc1, 0x16, 0x8d, 0x12, 0x84, 0x66, 0x01, 0x2d, 0x39,
	0xcc, 0x2a, 0xdf, 0x90, 0x55, 0x96, 0x59, 0x65, 0x9b, 0x55, 0x76, 0xf9, 0x80, 0xac, 0x52, 0xf3,
	0x05, 0xac, 0x94, 0xb3, 0xc8, 0x9e, 0x5f, 0x90, 0x42, 0x3f, 0xf0, 0x20, 0x4d, 0xc9, 0xf6, 0x0e,
	0xb8, 0x8f, 0x83, 0xdb, 0x17, 0xe7, 0x5e, 0x1e, 0x10, 0xd6, 0x02, 0x46, 0x7d, 0x6b, 0x40, 0x36,
	0x2d, 0x97, 0xf8, 0xac, 0x39, 0xf4, 0x29, 0xa3, 0x68, 0x51, 0x1a, 0x8d, 0xda, 0x80, 0xd2, 0x81,
	0x4b, 0x36, 0xb9, 0xf9, 0xcd, 0xc5, 0xe9, 0x26, 0x73, 0xce, 0x49, 0xc0, 0xac, 0xf3, 0xa1, 0x88,
	0x34, 0x74, 0x95, 0xde, 0x27, 0x43, 0x97, 0x8e, 0xce, 0x89, 0x27, 0x31, 0x0c, 0x43, 0x79, 0x3c,
	0xc2, 0xde, 0x51, 0xff, 0xac, 0x77, 0xea, 0xd2, 0x77, 0xd2, 0x77, 0x43, 0xf9, 0x86, 0xd4, 0x75,
	0xec, 0x91, 0xb4, 0xd6, 0x22, 0xab, 0x4f, 0x6d, 0x12, 0x04, 0x3d, 0xc7, 0xeb, 0x3b, 0xb6, 0xc5,
	0xa8, 0xaf, 0xd2, 0x06, 0x74, 0x40, 0xf9, 0xe5, 0x66, 0x78, 0x25, 0xac, 0x8d, 0xff, 0xdd, 0x84,
	0xc2, 0x76, 0x58, 0x3c, 0xba, 0x07, 0x59, 0xa7, 0xaf, 0x67, 0xea, 0x99, 0x8d, 0x72, 0xeb, 0xe6,
	0x64, 0x5c, 0x5b, 0x0b, 0x88, 0x17, 0x50, 0xff, 0xad, 0x15, 0xbc, 0x7d, 0xda, 0x70, 0x06, 0x1e,
	0xf5, 0x49, 0x03, 0x67, 0x9d, 0x3e, 0xba, 0x07, 0x45, 0xf1, 0x64, 0x3d, 0x5b, 0xcf, 0x6c, 0x54,
	0x1e, 0xae, 0x34, 0xe5, 0xa3, 0x9b, 0x47, 0xdc, 0x8c, 0xa5, 0x1b, 0x7d, 0x07, 0x2b, 0xae, 0x73,
	0x4a, 0xec, 0x91, 0xed, 0x92, 0x5e, 0xc0, 0xac, 0x01, 0xd1, 0x73, 0xf5, 0xcc, 0x46, 0xf5, 0xe1,
	0xcd, 0x28, 0xe3, 0x40, 0xf9, 0x8f, 0x43, 0x37, 0xae, 0xba, 0xa9, 0x7b, 0xd4, 0x05, 0x88, 0x5b,
	0xa3, 0xe7, 0xf9, 0xe3, 0x6e, 0x45, 0xc9, 0xbc, 0xee, 0xe6, 0x6e, 0x14, 0x30, 0xb7, 0xec, 0xbd,
	0x05, 0x9c, 0xc0, 0x41, 0x9b, 0x50, 0x70, 0xce, 0xc3, 0x6a, 0x56, 0x38, 0x60, 0x5c, 0xcd, 0x0e,
	0xf5, 0x98, 0xe5, 0x78, 0xc4, 0x6f, 0x87, 0xee, 0xbd, 0x05, 0x2c, 0xe2, 0xd0, 0xaf, 0xa0, 0xe4,
	0x93, 0x80, 0x5e, 0xf8, 0x36, 0xd1, 0xb5, 0xa9, 0x1c, 0x51, 0x04, 0x96, 0xee, 0xbd, 0x05, 0x1c,
	0x85, 0xa2, 0x27, 0x00, 0x97, 0x0e, 0x75, 0x2d, 0xe6, 0x50, 0x2f, 0xd0, 0x0b, 0xf5, 0xdc, 0x46,
	0xe5, 0xa1, 0x3e, 0x95, 0x78, 0xa2, 0x02, 0x70, 0x22, 0x16, 0x1d, 0xc0, 0xaa, 0x7a, 0x8d, 0x91,
	0x55, 0x5f, 0xe6, 0x4f, 0xae, 0x4d, 0x01, 0x1c, 0x89, 0xb8, 0x18, 0x47, 0x1b, 0x4e, 0x59, 0xd0,
	0x16, 0x54, 0x88, 0x77, 0x4a, 0x7d, 0x9b, 0xf0, 0x36, 0x16, 0x39, 0x8e, 0x31, 0x85, 0x63, 0xc6,
	0x11, 0x38, 0x19, 0x8e, 0x9e, 0x43, 0x3e, 0xe4, 0xad, 0xbe, 0x28, 0xd3, 0x04, 0xa9, 0x9b, 0x8a,
	0xd4, 0xcd, 0xae, 0x22, 0xf5, 0x7c, 0xd6, 0x70, 0x00, 0xf4, 0x1a, 0xaa, 0xa7, 0x8e, 0x1f, 0xb0,
	0x1e, 0xb5, 0xed, 0x0b, 0xdf, 0x27, 0x7d, 0x1d, 0x3e, 0x1f, 0x72, 0x99, 0x43, 0x1d, 0x4a, 0x24,
	0xd4, 0x85, 0x4a, 0xd8, 0x76, 0xf7, 0x92, 0xf4, 0x7b, 0x16, 0xd3, 0x57, 0x3f, 0x1f, 0x18, 0x14,
	0xce, 0x36, 0x43, 0x5f, 0x41, 0x21, 0x60, 0x16, 0x23, 0x7a, 0x65, 0x8a, 0xb6, 0x51, 0x6f, 0x8f,
	0x43, 0x37, 0x16, 0x51, 0xe8, 0x1b, 0xa8, 0x04, 0x1e, 0xa5, 0x7f, 0x24, 0x3d, 0xe6, 0xb8, 0xae,
	0xbe, 0x74, 0x5d, 0x11, 0x18, 0x44, 0x78, 0xd7, 0x71, 0x5d, 0x84, 0x20, 0xcf, 0xac, 0x41, 0xa0,
	0x57, 0xeb, 0xb9, 0x8d, 0x32, 0xe6, 0xd7, 0xc6, 0x9f, 0x0a, 0x00, 0x31, 0xbd, 0x51, 0x35, 0x9e,
	0x50, 0x3e, 0x88, 0x08, 0xf2, 0x9e, 0x75, 0x4e, 0xf8, 0x18, 0x96, 0x31, 0xbf, 0xe6, 0x30, 0xa3,
	0x21, 0xe1, 0xb3, 0x12, 0xc2, 0x8c, 0x86, 0x04, 0xdd, 0x86, 0x72, 0xe8, 0x0b, 0x86, 0x96, 0x4d,
	0xf4, 0x02, 0x77, 0xc4, 0x06, 0xf4, 0x13, 0x58, 0x8a, 0x6e, 0x7a, 0x4e, 0x9f, 0x13, 0xbc, 0x8c,
	0x2b, 0x91, 0xad, 0xdd, 0x47, 0xdf, 0x42, 0xd1, 0xb5, 0xde, 0x10, 0x37, 0xd0, 0x17, 0x39, 0x89,
	0x7f, 0x36, 0x77, 0x04, 0x9b, 0x07, 0x3c, 0xce, 0xf4, 0x98, 0x3f, 0xc2, 0x32, 0x09, 0xdd, 0x01,
	0xb0, 0xdd, 0x8b, 0x80, 0x11, 0x3f, 0xc4, 0x2f, 0x8b, 0x02, 0xa4, 0xa5, 0xdd, 0x0f, 0x0b, 0x50,
	0x6e, 0x7e, 0x1c, 0x10, 0x05, 0x48, 0x5b, 0x27, 0x3c, 0xd5, 0x0e, 0x80, 0xad, 0x66, 0x33, 0xd0,
	0x2b, 0xbc, 0x88, 0xbb, 0xf3, 0x8b, 0x88, 0xe6, 0x18, 0x27, 0xd2, 0xd0, 0x01, 0x54, 0x2c, 0xcf,
	0xa3, 0x4c, 0xce, 0x63, 0x95, 0xa3, 0xdc, 0x9f, 0x8f, 0xb2, 0x1d, 0x07, 0x8b, 0xf3, 0x24, 0xd3,
	0x91, 0x01, 0x25, 0xc7, 0xb3, 0x6c, 0xe6, 0x5c, 0x8a, 0x3d, 0x52, 0xc2, 0xd1, 0xbd, 0xf1, 0x1b,
	0xa8, 0x24, 0xfa, 0x80, 0x34, 0xc8, 0x9d, 0x91, 0x91, 0x7c, 0x71, 0xe1, 0x25, 0xba, 0x01, 0x85,
	0x4b, 0xcb, 0xbd, 0x50, 0xaf, 0x4e, 0xdc, 0x3c, 0xcd, 0x3e, 0xc9, 0x18, 0x1d, 0x28, 0x47, 0xd5,
	0x87, 0xfc, 0x13, 0x8b, 0x2a, 0x77, 0xe5, 0xa2, 0x52, 0x6b, 0x4a, 0xf1, 0x01, 0x62, 0x3e, 0x18,
	0xbf, 0x05, 0x6d, 0xfa, 0x1c, 0x9f, 0x54, 0xcf, 0xdf, 0xb2, 0x50, 0x52, 0xcb, 0x0d, 0xb5, 0x61,
	0x59, 0x2d, 0xb7, 0x1e, 0x67, 0x59, 0x86, 0xcf, 0xc5, 0x4f, 0xe7, 0x2c, 0xc3, 0xe8, 0xa2, 0x3b,
	0x1a, 0x12, 0xbc, 0xe4, 0x27, 0xee, 0x3e, 0xc8, 0xdd, 0x34, 0x4f, 0x72, 0xd7, 0xf1, 0x24, 0x3f,
	0xcb, 0x93, 0x4f, 0x63, 0x7a, 0x71, 0x86, 0xe9, 0x8d, 0x27, 0xb0, 0x94, 0x2c, 0x1a, 0x55, 0x60,
	0xf1, 0x77, 0x9d, 0xfd, 0xce, 0xe1, 0xab, 0x8e, 0xb6, 0x10, 0xde, 0x1c, 0x9b, 0x3b, 0xd8, 0xec,
	0x1e, 0x6b, 0x19, 0x54, 0x05, 0xd8, 0x39, 0xec, 0x3c, 0x6b, 0x3f, 0x7f, 0xb9, 0x7d, 0x74, 0xac,
	0x65, 0x8d, 0x1f, 0x16, 0xa1, 0x1c, 0xaf, 0x5c, 0x1d, 0x16, 0xcf, 0x49, 0x10, 0x84, 0xef, 0x4e,
	0xb4, 0x59, 0xdd, 0xa2, 0x23, 0x58, 0x39, 0x23, 0xa3, 0x1e, 0xef, 0x70, 0xcf, 0x62, 0xcc, 0x0f,
	0xe4, 0xef, 0xda, 0xcf, 0xe7, 0xfd, 0x32, 0x34, 0xf7, 0xc9, 0xe8, 0x24, 0x0c, 0xdf, 0x0e, 0xa3,
	0xf7, 0x16, 0xf0, 0xf2, 0x59, 0xd2, 0x80, 0x4e, 0x60, 0x35, 0xa9, 0x12, 0x7a, 0x8e, 0x77, 0x4a,
	0xe5, 0xb6, 0xde, 0x98, 0x8b, 0xd9, 0x11, 0x19, 0xcf, 0x5c, 0xfa, 0xae, 0xed, 0x9d, 0xd2, 0xbd,
	0x05, 0xbc, 0xe2, 0xa5, 0x4d, 0xe8, 0x81, 0x5c, 0x25, 0x05, 0xfe, 0x92, 0xef, 0xcc, 0x85, 0xe2,
	0x6f, 0x57, 0x6c, 0x9a, 0xa6, 0xfc, 0xad, 0x28, 0x5e, 0xbb, 0xfa, 0x78, 0x9c, 0xf1, 0xe7, 0x0c,
	0x2c, 0xa7, 0x4e, 0x87, 0xda, 0x50, 0x10, 0x4d, 0xc9, 0xf0, 0xf1, 0x7c, 0xf4, 0x71, 0x4d, 0x49,
	0xdd, 0x61, 0x81, 0x60, 0xfc, 0x1a, 0x96, 0x92, 0xe6, 0x8f, 0xa5, 0xbd, 0xf1, 0xf7, 0x1c, 0xac,
	0x4c, 0xb5, 0x07, 0x6d, 0x42, 0x89, 0x1f, 0xc2, 0xa6, 0xae, 0x24, 0xfd, 0x5a, 0xac, 0x61, 0x1e,
	0x1f, 0x49, 0x17, 0x8e, 0x82, 0xd0, 0x73, 0x28, 0x4a, 0xc1, 0x20, 0x44, 0xd2, 0xe6, 0xc7, 0xbe,
	0x89, 0xa6, 0xe9, 0x31, 0x87, 0x8d, 0xb0, 0x4c, 0x47, 0xdf, 0x43, 0xa5, 0x4f, 0x02, 0xe6, 0x78,
	0x42, 0x04, 0xe4, 0x3e, 0x0f, 0x2d, 0x89, 0x61, 0xfc, 0x3b, 0x03, 0x45, 0x61, 0x8f, 0xc6, 0x30,
	0x93, 0x18, 0xc3, 0xef, 0x42, 0xb9, 0x10, 0x7a, 0xc5, 0x8c, 0x67, 0xf9, 0x71, 0x63, 0xd9, 0x21,
	0x9f, 0x20, 0x00, 0xf8, 0x33, 0x38, 0x01, 0x40, 0xe4, 0xf0, 0xa9, 0x79, 0x00, 0x37, 0x62, 0xb9,
	0xd5, 0x8b, 0x27, 0x52, 0x8c, 0xf4, 0x5a, 0xec, 0xeb, 0x44, 0xb3, 0x79, 0x0f, 0x56, 0x12, 0x29,
	0x11, 0xef, 0xca, 0xb8, 0x1a, 0x9b, 0xd5, 0xe2, 0x18, 0x52, 0x5f, 0xa8, 0x98, 0x02, 0xe6, 0xd7,
	0x8d, 0xc7, 0x90, 0x57, 0xd3, 0xfa, 0xdc, 0xec, 0x98, 0xb8, 0xbd, 0xa3, 0x2d, 0xa0, 0x65, 0x28,
	0xef, 0x3f, 0x39, 0xee, 0x99, 0x27, 0x66, 0xa7, 0xab, 0x65, 0x90, 0x06, 0x4b, 0x1d, 0xb3, 0xfb,
	0xea, 0x10, 0xef, 0xf7, 0x9e, 0x1d, 0x1c, 0xbe, 0xd2, 0xb2, 0xad, 0x35, 0x58, 0x7d, 0x29, 0x86,
	0x32, 0xa4, 0x87, 0xf3, 0xe6, 0x82, 0x91, 0xe0, 0x45, 0xbe, 0x94, 0xd5, 0x72, 0x2f, 0xf2, 0xa5,
	0x9c, 0x96, 0x37, 0x08, 0x68, 0xd3, 0xea, 0xea, 0x8a, 0xc1, 0xfe, 0x1a, 0xca, 0x52, 0x79, 0x91,
	0x40, 0xcf, 0x72, 0xf6, 0xc6, 0x52, 0x55, 0xe2, 0xb4, 0x95, 0x26, 0xc7, 0x71, 0xac, 0xf1, 0x7b,
	0xa8, 0x24, 0xc4, 0x17, 0x7a, 0x08, 0xc5, 0xf0, 0x67, 0x84, 0x7a, 0x92, 0x68, 0xb1, 0x50, 0x4b,
	0x44, 0x6d, 0xf3, 0x08, 0x2c, 0x23, 0x93, 0x55, 0x65, 0x53, 0x55, 0xb5, 0x4a, 0xea, 0x55, 0x37,
	0xfe, 0x91, 0x87, 0xf2, 0x81, 0x13, 0x30, 0xa1, 0xf6, 0xa7, 0xb5, 0x44, 0x7f, 0x56, 0xab, 0x67,
	0xaf, 0xd4, 0xea, 0xad, 0xc6, 0x64, 0x5c, 0x5b, 0x0f, 0x88, 0xe5, 0xdb, 0x6f, 0x9f, 0x36, 0x22,
	0x5f, 0x9d, 0x3b, 0xbf, 0x0c, 0x73, 0x48, 0x63, 0x46, 0xcf, 0xef, 0xcb, 0xfd, 0x90, 0xbb, 0x56,
	0x9f, 0xfd, 0x78, 0x32, 0xae, 0xdd, 0x54, 0xe8, 0x51, 0xfb, 0xeb, 0x61, 0x80, 0xd2, 0x93, 0xbf,
	0x8c, 0xbe, 0x43, 0xc4, 0x02, 0xd5, 0x13, 0x95, 0xca, 0x63, 0x4e, 0x7d, 0x90, 0x6c, 0xa5, 0x3e,
	0x27, 0x0a, 0x3c, 0xeb, 0xf6, 0x6c, 0x56, 0xac, 0x01, 0x52, 0x9f, 0x0d, 0xdf, 0x2b, 0x35, 0x58,
	0xbc, 0x52, 0x0d, 0xa6, 0x1b, 0x13, 0x97, 0xce, 0x9d, 0xaa, 0x31, 0x52, 0x31, 0xfe, 0x02, 0x56,
	0x13, 0x52, 0xbb, 0x67, 0xd3, 0x0b, 0x8f, 0xf1, 0xd5, 0x5d, 0xc0, 0x5a, 0xc2, 0xb1, 0x13, 0xda,
	0xd1, 0x7d, 0xa9, 0x10, 0x4b, 0xa1, 0x42, 0x6c, 0x7d, 0x31, 0x19, 0xd7, 0x90, 0x7a, 0x4a, 0xd7,
	0x1a, 0x28, 0x64, 0x1e, 0x83, 0xda, 0x80, 0x92, 0xc0, 0x92, 0x50, 0xe5, 0x6b, 0x09, 0x95, 0x2c,
	0x47, 0x98, 0x1a, 0x7f, 0xcd, 0xc2, 0xca, 0x54, 0x43, 0xd1, 0xa3, 0xc4, 0xb7, 0xe2, 0xdd, 0xc9,
	0xb8, 0x56, 0x53, 0x85, 0x08, 0x7f, 0xbd, 0xbd, 0x2b, 0xca, 0xf9, 0xf2, 0xad, 0xd3, 0xef, 0x13,
	0x4f, 0x7c, 0x37, 0x7e, 0x95, 0xfc, 0xc9, 0x6f, 0xdd, 0x9a, 0x8c, 0x6b, 0x3f, 0x4a, 0xa7, 0x45,
	0x47, 0xe0, 0x6b, 0xe8, 0x05, 0x94, 0x02, 0x72, 0x49, 0x7c, 0x87, 0x8d, 0xe4, 0x67, 0xe3, 0x6a,
	0x54, 0xf8, 0xb1, 0x74, 0xa4, 0x69, 0xa2, 0xac, 0x0a, 0x27, 0xca, 0x47, 0x75, 0xbe, 0x44, 0x6d,
	0xdf, 0x19, 0xf2, 0x3e, 0x48, 0xe5, 0x90, 0x30, 0xa1, 0x6f, 0x00, 0x6c, 0x8b, 0x91, 0x01, 0xf5,
	0x1d, 0x22, 0xbe, 0xd5, 0xca, 0x69, 0xf0, 0x1d, 0xe1, 0x8d, 0xc0, 0x13, 0xe1, 0x8d, 0x7f, 0xe6,
	0x60, 0xed, 0x03, 0xec, 0x41, 0x5f, 0x27, 0xda, 0x74, 0x6f, 0x32, 0xae, 0xdd, 0x55, 0x60, 0x71,
	0xcc, 0x87, 0x5b, 0xf5, 0x20, 0xd5, 0xaa, 0x3b, 0x93, 0x71, 0xed, 0xd6, 0x6c, 0x6a, 0xba, 0x5d,
	0xdf, 0x7e, 0x48, 0x1d, 0xb5, 0x8c, 0xc9, 0xb8, 0xf6, 0x45, 0x74, 0x04, 0xe1, 0x57, 0x79, 0x29,
	0xe5, 0xf4, 0x74, 0x46, 0x39, 0xb5, 0x6e, 0x4f, 0xc6, 0x35, 0x5d, 0xe5, 0x46, 0x9b, 0x5a, 0x65,
	0x27, 0x74, 0xd5, 0x56, 0x4a, 0xb7, 0x15, 0x67, 0x6b, 0x96, 0x0f, 0x8e, 0xce, 0xda, 0x48, 0xca,
	0xba, 0xad, 0x84, 0x90, 0x0e, 0xa9, 0x5f, 0x6a, 0xd5, 0x27, 0xe3, 0xda, 0x6d, 0x95, 0xdb, 0x96,
	0xbe, 0x7a, 0x7c, 0xf0, 0x46, 0x2c, 0xb5, 0xd1, 0xd6, 0x94, 0xa6, 0x2b, 0xcd, 0x92, 0x2b, 0x2a,
	0xbd, 0xde, 0xde, 0x6d, 0xa4, 0xe4, 0x9e, 0xd8, 0xf3, 0xf7, 0x9f, 0x41, 0x35, 0x3d, 0xc2, 0x08,
	0xa0, 0xb8, 0xbd, 0xd3, 0x6d, 0x9f, 0x98, 0x52, 0xf5, 0x75, 0x0e, 0x0f, 0x5f, 0x9b, 0xbb, 0x5a,
	0x06, 0x2d, 0x41, 0x09, 0x9b, 0xc7, 0x87, 0x07, 0x27, 0xe6, 0xae, 0x96, 0x0d, 0x7f, 0x62, 0xb6,
	0xbb, 0x5d, 0xf3, 0xe5, 0x51, 0xd7, 0xdc, 0xd5, 0x72, 0xad, 0xc7, 0xff, 0x7a, 0xbf, 0x9e, 0xf9,
	0xe1, 0xfd, 0x7a, 0xe6, 0x3f, 0xef, 0xd7, 0x33, 0x7f, 0xf9, 0xef, 0xfa, 0x02, 0xdc, 0x72, 0x68,
	0x33, 0x60, 0x96, 0x7d, 0xe6, 0xd3, 0x3f, 0x88, 0x2d, 0xa7, 0x28, 0xfc, 0x5a, 0xfd, 0x4b, 0xf4,
	0xa6, 0xc8, 0xed, 0x8f, 0xfe, 0x1f, 0x00, 0x00, 0xff, 0xff, 0xa9, 0x32, 0x87, 0x78, 0x4c, 0x12,
	0x00, 0x00,
}

func (m *Alert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ResolvedAt != nil {
		{
			size, err := m.ResolvedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Entity != nil {
		{
			size := m.Entity.Size()
			i -= size
			if _, err := m.Entity.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintAlert(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if m.ProcessViolation != nil {
		{
			size, err := m.ProcessViolation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.SnoozeTill != nil {
		{
			size, err := m.SnoozeTill.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.State != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x58
	}
	if m.FirstOccurred != nil {
		{
			size, err := m.FirstOccurred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Time != nil {
		{
			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Enforcement != nil {
		{
			size, err := m.Enforcement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Violations) > 0 {
		for iNdEx := len(m.Violations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Violations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlert(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.LifecycleStage != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.LifecycleStage))
		i--
		dAtA[i] = 0x18
	}
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Alert_Deployment_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Deployment_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Deployment != nil {
		{
			size, err := m.Deployment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Alert_Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *Alert_Resource_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Resource_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Resource != nil {
		{
			size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Alert_Deployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert_Deployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Deployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NamespaceId) > 0 {
		i -= len(m.NamespaceId)
		copy(dAtA[i:], m.NamespaceId)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.NamespaceId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Inactive {
		i--
		if m.Inactive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAlert(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAlert(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAlert(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Containers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlert(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAlert(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAlert(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAlert(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Alert_Deployment_Container) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert_Deployment_Container) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Deployment_Container) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x52
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *Alert_Resource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert_Resource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Resource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NamespaceId) > 0 {
		i -= len(m.NamespaceId)
		copy(dAtA[i:], m.NamespaceId)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.NamespaceId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ResourceType != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.ResourceType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Alert_Violation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert_Violation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Violation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MessageAttributes != nil {
		{
			size := m.MessageAttributes.Size()
			i -= size
			if _, err := m.MessageAttributes.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Time != nil {
		{
			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Type != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Alert_Violation_KeyValueAttrs_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Violation_KeyValueAttrs_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeyValueAttrs != nil {
		{
			size, err := m.KeyValueAttrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Alert_Violation_NetworkFlowInfo_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Violation_NetworkFlowInfo_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NetworkFlowInfo != nil {
		{
			size, err := m.NetworkFlowInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Alert_Violation_KeyValueAttrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert_Violation_KeyValueAttrs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Violation_KeyValueAttrs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlert(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Alert_Violation_NetworkFlowInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert_Violation_NetworkFlowInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Violation_NetworkFlowInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Destination != nil {
		{
			size, err := m.Destination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Protocol != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Alert_Violation_NetworkFlowInfo_Entity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert_Violation_NetworkFlowInfo_Entity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Violation_NetworkFlowInfo_Entity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DeploymentType) > 0 {
		i -= len(m.DeploymentType)
		copy(dAtA[i:], m.DeploymentType)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.DeploymentType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DeploymentNamespace) > 0 {
		i -= len(m.DeploymentNamespace)
		copy(dAtA[i:], m.DeploymentNamespace)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.DeploymentNamespace)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EntityType != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.EntityType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Alert_ProcessViolation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert_ProcessViolation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_ProcessViolation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Processes) > 0 {
		for iNdEx := len(m.Processes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Processes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAlert(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Alert_Enforcement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert_Enforcement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert_Enforcement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Action != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListAlert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAlert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAlert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EnforcementAction != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.EnforcementAction))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintAlert(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.EnforcementCount != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.EnforcementCount))
		i--
		dAtA[i] = 0x38
	}
	if m.State != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if m.Deployment != nil {
		{
			size, err := m.Deployment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Time != nil {
		{
			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAlert(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.LifecycleStage != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.LifecycleStage))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAlertPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAlertPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAlertPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Categories) > 0 {
		for iNdEx := len(m.Categories) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Categories[iNdEx])
			copy(dAtA[i:], m.Categories[iNdEx])
			i = encodeVarintAlert(dAtA, i, uint64(len(m.Categories[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if m.Severity != 0 {
		i = encodeVarintAlert(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAlertDeployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAlertDeployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAlertDeployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NamespaceId) > 0 {
		i -= len(m.NamespaceId)
		copy(dAtA[i:], m.NamespaceId)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.NamespaceId)))
		i--
		dAtA[i] = 0x42
	}
	if m.Inactive {
		i--
		if m.Inactive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAlert(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAlert(dAtA []byte, offset int, v uint64) int {
	offset -= sovAlert(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Alert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.LifecycleStage != 0 {
		n += 1 + sovAlert(uint64(m.LifecycleStage))
	}
	if m.Entity != nil {
		n += m.Entity.Size()
	}
	if len(m.Violations) > 0 {
		for _, e := range m.Violations {
			l = e.Size()
			n += 1 + l + sovAlert(uint64(l))
		}
	}
	if m.Enforcement != nil {
		l = m.Enforcement.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.FirstOccurred != nil {
		l = m.FirstOccurred.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovAlert(uint64(m.State))
	}
	if m.SnoozeTill != nil {
		l = m.SnoozeTill.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.ProcessViolation != nil {
		l = m.ProcessViolation.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAlert(uint64(l))
		}
	}
	if m.ResolvedAt != nil {
		l = m.ResolvedAt.Size()
		n += 2 + l + sovAlert(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alert_Deployment_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deployment != nil {
		l = m.Deployment.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	return n
}
func (m *Alert_Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	return n
}
func (m *Alert_Resource_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 2 + l + sovAlert(uint64(l))
	}
	return n
}
func (m *Alert_Deployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAlert(uint64(len(k))) + 1 + len(v) + sovAlert(uint64(len(v)))
			n += mapEntrySize + 1 + sovAlert(uint64(mapEntrySize))
		}
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovAlert(uint64(l))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAlert(uint64(len(k))) + 1 + len(v) + sovAlert(uint64(len(v)))
			n += mapEntrySize + 1 + sovAlert(uint64(mapEntrySize))
		}
	}
	if m.Inactive {
		n += 2
	}
	l = len(m.NamespaceId)
	if l > 0 {
		n += 2 + l + sovAlert(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alert_Deployment_Container) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alert_Resource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceType != 0 {
		n += 1 + sovAlert(uint64(m.ResourceType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.NamespaceId)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alert_Violation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.MessageAttributes != nil {
		n += m.MessageAttributes.Size()
	}
	if m.Type != 0 {
		n += 1 + sovAlert(uint64(m.Type))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alert_Violation_KeyValueAttrs_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyValueAttrs != nil {
		l = m.KeyValueAttrs.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	return n
}
func (m *Alert_Violation_NetworkFlowInfo_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkFlowInfo != nil {
		l = m.NetworkFlowInfo.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	return n
}
func (m *Alert_Violation_KeyValueAttrs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, e := range m.Attrs {
			l = e.Size()
			n += 1 + l + sovAlert(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alert_Violation_NetworkFlowInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Protocol != 0 {
		n += 1 + sovAlert(uint64(m.Protocol))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.Destination != nil {
		l = m.Destination.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alert_Violation_NetworkFlowInfo_Entity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.EntityType != 0 {
		n += 1 + sovAlert(uint64(m.EntityType))
	}
	l = len(m.DeploymentNamespace)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.DeploymentType)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovAlert(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alert_ProcessViolation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if len(m.Processes) > 0 {
		for _, e := range m.Processes {
			l = e.Size()
			n += 1 + l + sovAlert(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Alert_Enforcement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovAlert(uint64(m.Action))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAlert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.LifecycleStage != 0 {
		n += 1 + sovAlert(uint64(m.LifecycleStage))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.Deployment != nil {
		l = m.Deployment.Size()
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovAlert(uint64(m.State))
	}
	if m.EnforcementCount != 0 {
		n += 1 + sovAlert(uint64(m.EnforcementCount))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAlert(uint64(l))
		}
	}
	if m.EnforcementAction != 0 {
		n += 1 + sovAlert(uint64(m.EnforcementAction))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAlertPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.Severity != 0 {
		n += 1 + sovAlert(uint64(m.Severity))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if len(m.Categories) > 0 {
		for _, s := range m.Categories {
			l = len(s)
			n += 1 + l + sovAlert(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAlertDeployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.Inactive {
		n += 2
	}
	l = len(m.NamespaceId)
	if l > 0 {
		n += 1 + l + sovAlert(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAlert(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAlert(x uint64) (n int) {
	return sovAlert(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Alert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifecycleStage", wireType)
			}
			m.LifecycleStage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LifecycleStage |= LifecycleStage(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Alert_Deployment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &Alert_Deployment_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Violations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Violations = append(m.Violations, &Alert_Violation{})
			if err := m.Violations[len(m.Violations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enforcement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enforcement == nil {
				m.Enforcement = &Alert_Enforcement{}
			}
			if err := m.Enforcement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &types.Timestamp{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstOccurred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstOccurred == nil {
				m.FirstOccurred = &types.Timestamp{}
			}
			if err := m.FirstOccurred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ViolationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnoozeTill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnoozeTill == nil {
				m.SnoozeTill = &types.Timestamp{}
			}
			if err := m.SnoozeTill.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessViolation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessViolation == nil {
				m.ProcessViolation = &Alert_ProcessViolation{}
			}
			if err := m.ProcessViolation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContainerImage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &Alert_Image{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Alert_Resource{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &Alert_Resource_{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResolvedAt == nil {
				m.ResolvedAt = &types.Timestamp{}
			}
			if err := m.ResolvedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert_Deployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAlert
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAlert
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAlert
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAlert
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAlert
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAlert
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAlert
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAlert(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAlert
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &Alert_Deployment_Container{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAlert
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAlert
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAlert
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAlert
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAlert
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAlert
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAlert
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAlert(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAlert
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inactive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inactive = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert_Deployment_Container) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &ContainerImage{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert_Resource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			m.ResourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceType |= Alert_Resource_ResourceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert_Violation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Violation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Violation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyValueAttrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Alert_Violation_KeyValueAttrs{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MessageAttributes = &Alert_Violation_KeyValueAttrs_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Alert_Violation_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &types.Timestamp{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFlowInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Alert_Violation_NetworkFlowInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MessageAttributes = &Alert_Violation_NetworkFlowInfo_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert_Violation_KeyValueAttrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValueAttrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValueAttrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, &Alert_Violation_KeyValueAttrs_KeyValueAttr{})
			if err := m.Attrs[len(m.Attrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert_Violation_KeyValueAttrs_KeyValueAttr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValueAttr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValueAttr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert_Violation_NetworkFlowInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkFlowInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkFlowInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= L4Protocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &Alert_Violation_NetworkFlowInfo_Entity{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Destination == nil {
				m.Destination = &Alert_Violation_NetworkFlowInfo_Entity{}
			}
			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert_Violation_NetworkFlowInfo_Entity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityType", wireType)
			}
			m.EntityType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityType |= NetworkEntityInfo_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert_ProcessViolation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessViolation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessViolation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processes = append(m.Processes, &ProcessIndicator{})
			if err := m.Processes[len(m.Processes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert_Enforcement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Enforcement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Enforcement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= EnforcementAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAlert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAlert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAlert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifecycleStage", wireType)
			}
			m.LifecycleStage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LifecycleStage |= LifecycleStage(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &types.Timestamp{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &ListAlertPolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deployment == nil {
				m.Deployment = &ListAlertDeployment{}
			}
			if err := m.Deployment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ViolationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnforcementCount", wireType)
			}
			m.EnforcementCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnforcementCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnforcementAction", wireType)
			}
			m.EnforcementAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnforcementAction |= EnforcementAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAlertPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAlertPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAlertPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= Severity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Categories = append(m.Categories, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAlertDeployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAlertDeployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAlertDeployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inactive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inactive = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlert
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAlert
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlert(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAlert
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAlert(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAlert
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlert
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAlert
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAlert
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAlert
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAlert        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAlert          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAlert = fmt.Errorf("proto: unexpected end of group")
)
