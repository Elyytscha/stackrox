// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/v1/search_service.proto

package v1

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Next available tag: 47
type SearchCategory int32

const (
	SearchCategory_SEARCH_UNSET             SearchCategory = 0
	SearchCategory_ALERTS                   SearchCategory = 1
	SearchCategory_IMAGES                   SearchCategory = 2
	SearchCategory_IMAGE_COMPONENTS         SearchCategory = 20
	SearchCategory_IMAGE_VULN_EDGE          SearchCategory = 27
	SearchCategory_IMAGE_COMPONENT_EDGE     SearchCategory = 23
	SearchCategory_POLICIES                 SearchCategory = 3
	SearchCategory_DEPLOYMENTS              SearchCategory = 4
	SearchCategory_ACTIVE_COMPONENT         SearchCategory = 30
	SearchCategory_PODS                     SearchCategory = 25
	SearchCategory_SECRETS                  SearchCategory = 5
	SearchCategory_PROCESS_INDICATORS       SearchCategory = 6
	SearchCategory_COMPLIANCE               SearchCategory = 7
	SearchCategory_CLUSTERS                 SearchCategory = 8
	SearchCategory_NAMESPACES               SearchCategory = 9
	SearchCategory_NODES                    SearchCategory = 10
	SearchCategory_NODE_COMPONENTS          SearchCategory = 38
	SearchCategory_NODE_VULN_EDGE           SearchCategory = 28
	SearchCategory_NODE_COMPONENT_EDGE      SearchCategory = 29
	SearchCategory_NODE_COMPONENT_CVE_EDGE  SearchCategory = 33
	SearchCategory_COMPLIANCE_STANDARD      SearchCategory = 11
	SearchCategory_COMPLIANCE_CONTROL_GROUP SearchCategory = 12
	SearchCategory_COMPLIANCE_CONTROL       SearchCategory = 13
	SearchCategory_SERVICE_ACCOUNTS         SearchCategory = 14
	SearchCategory_ROLES                    SearchCategory = 15
	SearchCategory_ROLEBINDINGS             SearchCategory = 16
	SearchCategory_REPORT_CONFIGURATIONS    SearchCategory = 37
	SearchCategory_PROCESS_BASELINES        SearchCategory = 17
	SearchCategory_SUBJECTS                 SearchCategory = 18
	SearchCategory_RISKS                    SearchCategory = 19
	SearchCategory_VULNERABILITIES          SearchCategory = 21
	SearchCategory_CLUSTER_VULNERABILITIES  SearchCategory = 34
	SearchCategory_IMAGE_VULNERABILITIES    SearchCategory = 35
	SearchCategory_NODE_VULNERABILITIES     SearchCategory = 36
	SearchCategory_COMPONENT_VULN_EDGE      SearchCategory = 22
	SearchCategory_CLUSTER_VULN_EDGE        SearchCategory = 24
	SearchCategory_NETWORK_ENTITY           SearchCategory = 26
	SearchCategory_VULN_REQUEST             SearchCategory = 32
	SearchCategory_NETWORK_BASELINE         SearchCategory = 39
	SearchCategory_NETWORK_POLICIES         SearchCategory = 40
	SearchCategory_PROCESS_BASELINE_RESULTS SearchCategory = 41
	SearchCategory_COMPLIANCE_METADATA      SearchCategory = 42
	SearchCategory_COMPLIANCE_RESULTS       SearchCategory = 43
	SearchCategory_COMPLIANCE_DOMAIN        SearchCategory = 44
	SearchCategory_CLUSTER_HEALTH           SearchCategory = 45
	SearchCategory_POLICY_CATEGORIES        SearchCategory = 46
)

var SearchCategory_name = map[int32]string{
	0:  "SEARCH_UNSET",
	1:  "ALERTS",
	2:  "IMAGES",
	20: "IMAGE_COMPONENTS",
	27: "IMAGE_VULN_EDGE",
	23: "IMAGE_COMPONENT_EDGE",
	3:  "POLICIES",
	4:  "DEPLOYMENTS",
	30: "ACTIVE_COMPONENT",
	25: "PODS",
	5:  "SECRETS",
	6:  "PROCESS_INDICATORS",
	7:  "COMPLIANCE",
	8:  "CLUSTERS",
	9:  "NAMESPACES",
	10: "NODES",
	38: "NODE_COMPONENTS",
	28: "NODE_VULN_EDGE",
	29: "NODE_COMPONENT_EDGE",
	33: "NODE_COMPONENT_CVE_EDGE",
	11: "COMPLIANCE_STANDARD",
	12: "COMPLIANCE_CONTROL_GROUP",
	13: "COMPLIANCE_CONTROL",
	14: "SERVICE_ACCOUNTS",
	15: "ROLES",
	16: "ROLEBINDINGS",
	37: "REPORT_CONFIGURATIONS",
	17: "PROCESS_BASELINES",
	18: "SUBJECTS",
	19: "RISKS",
	21: "VULNERABILITIES",
	34: "CLUSTER_VULNERABILITIES",
	35: "IMAGE_VULNERABILITIES",
	36: "NODE_VULNERABILITIES",
	22: "COMPONENT_VULN_EDGE",
	24: "CLUSTER_VULN_EDGE",
	26: "NETWORK_ENTITY",
	32: "VULN_REQUEST",
	39: "NETWORK_BASELINE",
	40: "NETWORK_POLICIES",
	41: "PROCESS_BASELINE_RESULTS",
	42: "COMPLIANCE_METADATA",
	43: "COMPLIANCE_RESULTS",
	44: "COMPLIANCE_DOMAIN",
	45: "CLUSTER_HEALTH",
	46: "POLICY_CATEGORIES",
}

var SearchCategory_value = map[string]int32{
	"SEARCH_UNSET":             0,
	"ALERTS":                   1,
	"IMAGES":                   2,
	"IMAGE_COMPONENTS":         20,
	"IMAGE_VULN_EDGE":          27,
	"IMAGE_COMPONENT_EDGE":     23,
	"POLICIES":                 3,
	"DEPLOYMENTS":              4,
	"ACTIVE_COMPONENT":         30,
	"PODS":                     25,
	"SECRETS":                  5,
	"PROCESS_INDICATORS":       6,
	"COMPLIANCE":               7,
	"CLUSTERS":                 8,
	"NAMESPACES":               9,
	"NODES":                    10,
	"NODE_COMPONENTS":          38,
	"NODE_VULN_EDGE":           28,
	"NODE_COMPONENT_EDGE":      29,
	"NODE_COMPONENT_CVE_EDGE":  33,
	"COMPLIANCE_STANDARD":      11,
	"COMPLIANCE_CONTROL_GROUP": 12,
	"COMPLIANCE_CONTROL":       13,
	"SERVICE_ACCOUNTS":         14,
	"ROLES":                    15,
	"ROLEBINDINGS":             16,
	"REPORT_CONFIGURATIONS":    37,
	"PROCESS_BASELINES":        17,
	"SUBJECTS":                 18,
	"RISKS":                    19,
	"VULNERABILITIES":          21,
	"CLUSTER_VULNERABILITIES":  34,
	"IMAGE_VULNERABILITIES":    35,
	"NODE_VULNERABILITIES":     36,
	"COMPONENT_VULN_EDGE":      22,
	"CLUSTER_VULN_EDGE":        24,
	"NETWORK_ENTITY":           26,
	"VULN_REQUEST":             32,
	"NETWORK_BASELINE":         39,
	"NETWORK_POLICIES":         40,
	"PROCESS_BASELINE_RESULTS": 41,
	"COMPLIANCE_METADATA":      42,
	"COMPLIANCE_RESULTS":       43,
	"COMPLIANCE_DOMAIN":        44,
	"CLUSTER_HEALTH":           45,
	"POLICY_CATEGORIES":        46,
}

func (x SearchCategory) String() string {
	return proto.EnumName(SearchCategory_name, int32(x))
}

func (SearchCategory) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c4215e5dded92b40, []int{0}
}

type SearchDataType int32

const (
	SearchDataType_SEARCH_BOOL     SearchDataType = 0
	SearchDataType_SEARCH_NUMERIC  SearchDataType = 1
	SearchDataType_SEARCH_STRING   SearchDataType = 2
	SearchDataType_SEARCH_DATETIME SearchDataType = 3
	SearchDataType_SEARCH_MAP      SearchDataType = 4
	SearchDataType_SEARCH_ENUM     SearchDataType = 5
)

var SearchDataType_name = map[int32]string{
	0: "SEARCH_BOOL",
	1: "SEARCH_NUMERIC",
	2: "SEARCH_STRING",
	3: "SEARCH_DATETIME",
	4: "SEARCH_MAP",
	5: "SEARCH_ENUM",
}

var SearchDataType_value = map[string]int32{
	"SEARCH_BOOL":     0,
	"SEARCH_NUMERIC":  1,
	"SEARCH_STRING":   2,
	"SEARCH_DATETIME": 3,
	"SEARCH_MAP":      4,
	"SEARCH_ENUM":     5,
}

func (x SearchDataType) String() string {
	return proto.EnumName(SearchDataType_name, int32(x))
}

func (SearchDataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c4215e5dded92b40, []int{1}
}

// RawQuery represents the search query string.
// The format of the query string is "<field name>:<value,value,...>+<field name>:<value, value,...>+..."
// For example:
// To search for deployments named "central" and "sensor" in the namespace "stackrox", the query string would be
// "Deployment:central,sensor+Namespace:stackrox"
// RawQuery is used in ListAPIs to search for a particular object.
type RawQuery struct {
	Query                string      `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Pagination           *Pagination `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RawQuery) Reset()         { *m = RawQuery{} }
func (m *RawQuery) String() string { return proto.CompactTextString(m) }
func (*RawQuery) ProtoMessage()    {}
func (*RawQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4215e5dded92b40, []int{0}
}
func (m *RawQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawQuery.Merge(m, src)
}
func (m *RawQuery) XXX_Size() int {
	return m.Size()
}
func (m *RawQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_RawQuery.DiscardUnknown(m)
}

var xxx_messageInfo_RawQuery proto.InternalMessageInfo

func (m *RawQuery) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *RawQuery) GetPagination() *Pagination {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func (m *RawQuery) MessageClone() proto.Message {
	return m.Clone()
}
func (m *RawQuery) Clone() *RawQuery {
	if m == nil {
		return nil
	}
	cloned := new(RawQuery)
	*cloned = *m

	cloned.Pagination = m.Pagination.Clone()
	return cloned
}

// RawSearchRequest is used to scope a given search in a specific category.
// The search categories could be deployments, policies, images etc.
type RawSearchRequest struct {
	Query                string           `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Categories           []SearchCategory `protobuf:"varint,2,rep,packed,name=categories,proto3,enum=v1.SearchCategory" json:"categories,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RawSearchRequest) Reset()         { *m = RawSearchRequest{} }
func (m *RawSearchRequest) String() string { return proto.CompactTextString(m) }
func (*RawSearchRequest) ProtoMessage()    {}
func (*RawSearchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4215e5dded92b40, []int{1}
}
func (m *RawSearchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawSearchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawSearchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawSearchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawSearchRequest.Merge(m, src)
}
func (m *RawSearchRequest) XXX_Size() int {
	return m.Size()
}
func (m *RawSearchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RawSearchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RawSearchRequest proto.InternalMessageInfo

func (m *RawSearchRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *RawSearchRequest) GetCategories() []SearchCategory {
	if m != nil {
		return m.Categories
	}
	return nil
}

func (m *RawSearchRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *RawSearchRequest) Clone() *RawSearchRequest {
	if m == nil {
		return nil
	}
	cloned := new(RawSearchRequest)
	*cloned = *m

	if m.Categories != nil {
		cloned.Categories = make([]SearchCategory, len(m.Categories))
		copy(cloned.Categories, m.Categories)
	}
	return cloned
}

type SearchResult struct {
	Id             string                           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name           string                           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Category       SearchCategory                   `protobuf:"varint,3,opt,name=category,proto3,enum=v1.SearchCategory" json:"category,omitempty"`
	FieldToMatches map[string]*SearchResult_Matches `protobuf:"bytes,4,rep,name=field_to_matches,json=fieldToMatches,proto3" json:"field_to_matches,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Score          float64                          `protobuf:"fixed64,5,opt,name=score,proto3" json:"score,omitempty"`
	// Location is intended to be a unique, yet human readable,
	// identifier for the result. For example, for a deployment,
	// the location will be "$cluster_name/$namespace/$deployment_name.
	// It is displayed in the UI in the global search results, underneath
	// the name for each result.
	Location             string   `protobuf:"bytes,6,opt,name=location,proto3" json:"location,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchResult) Reset()         { *m = SearchResult{} }
func (m *SearchResult) String() string { return proto.CompactTextString(m) }
func (*SearchResult) ProtoMessage()    {}
func (*SearchResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4215e5dded92b40, []int{2}
}
func (m *SearchResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResult.Merge(m, src)
}
func (m *SearchResult) XXX_Size() int {
	return m.Size()
}
func (m *SearchResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResult.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResult proto.InternalMessageInfo

func (m *SearchResult) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SearchResult) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SearchResult) GetCategory() SearchCategory {
	if m != nil {
		return m.Category
	}
	return SearchCategory_SEARCH_UNSET
}

func (m *SearchResult) GetFieldToMatches() map[string]*SearchResult_Matches {
	if m != nil {
		return m.FieldToMatches
	}
	return nil
}

func (m *SearchResult) GetScore() float64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *SearchResult) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *SearchResult) MessageClone() proto.Message {
	return m.Clone()
}
func (m *SearchResult) Clone() *SearchResult {
	if m == nil {
		return nil
	}
	cloned := new(SearchResult)
	*cloned = *m

	if m.FieldToMatches != nil {
		cloned.FieldToMatches = make(map[string]*SearchResult_Matches, len(m.FieldToMatches))
		for k, v := range m.FieldToMatches {
			cloned.FieldToMatches[k] = v.Clone()
		}
	}
	return cloned
}

type SearchResult_Matches struct {
	Values               []string `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchResult_Matches) Reset()         { *m = SearchResult_Matches{} }
func (m *SearchResult_Matches) String() string { return proto.CompactTextString(m) }
func (*SearchResult_Matches) ProtoMessage()    {}
func (*SearchResult_Matches) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4215e5dded92b40, []int{2, 0}
}
func (m *SearchResult_Matches) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchResult_Matches) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchResult_Matches.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchResult_Matches) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResult_Matches.Merge(m, src)
}
func (m *SearchResult_Matches) XXX_Size() int {
	return m.Size()
}
func (m *SearchResult_Matches) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResult_Matches.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResult_Matches proto.InternalMessageInfo

func (m *SearchResult_Matches) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *SearchResult_Matches) MessageClone() proto.Message {
	return m.Clone()
}
func (m *SearchResult_Matches) Clone() *SearchResult_Matches {
	if m == nil {
		return nil
	}
	cloned := new(SearchResult_Matches)
	*cloned = *m

	if m.Values != nil {
		cloned.Values = make([]string, len(m.Values))
		copy(cloned.Values, m.Values)
	}
	return cloned
}

type SearchResponse struct {
	Results              []*SearchResult         `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	Counts               []*SearchResponse_Count `protobuf:"bytes,2,rep,name=counts,proto3" json:"counts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *SearchResponse) Reset()         { *m = SearchResponse{} }
func (m *SearchResponse) String() string { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()    {}
func (*SearchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4215e5dded92b40, []int{3}
}
func (m *SearchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResponse.Merge(m, src)
}
func (m *SearchResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResponse proto.InternalMessageInfo

func (m *SearchResponse) GetResults() []*SearchResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *SearchResponse) GetCounts() []*SearchResponse_Count {
	if m != nil {
		return m.Counts
	}
	return nil
}

func (m *SearchResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *SearchResponse) Clone() *SearchResponse {
	if m == nil {
		return nil
	}
	cloned := new(SearchResponse)
	*cloned = *m

	if m.Results != nil {
		cloned.Results = make([]*SearchResult, len(m.Results))
		for idx, v := range m.Results {
			cloned.Results[idx] = v.Clone()
		}
	}
	if m.Counts != nil {
		cloned.Counts = make([]*SearchResponse_Count, len(m.Counts))
		for idx, v := range m.Counts {
			cloned.Counts[idx] = v.Clone()
		}
	}
	return cloned
}

type SearchResponse_Count struct {
	Category             SearchCategory `protobuf:"varint,1,opt,name=category,proto3,enum=v1.SearchCategory" json:"category,omitempty"`
	Count                int64          `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SearchResponse_Count) Reset()         { *m = SearchResponse_Count{} }
func (m *SearchResponse_Count) String() string { return proto.CompactTextString(m) }
func (*SearchResponse_Count) ProtoMessage()    {}
func (*SearchResponse_Count) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4215e5dded92b40, []int{3, 0}
}
func (m *SearchResponse_Count) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchResponse_Count) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchResponse_Count.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchResponse_Count) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchResponse_Count.Merge(m, src)
}
func (m *SearchResponse_Count) XXX_Size() int {
	return m.Size()
}
func (m *SearchResponse_Count) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchResponse_Count.DiscardUnknown(m)
}

var xxx_messageInfo_SearchResponse_Count proto.InternalMessageInfo

func (m *SearchResponse_Count) GetCategory() SearchCategory {
	if m != nil {
		return m.Category
	}
	return SearchCategory_SEARCH_UNSET
}

func (m *SearchResponse_Count) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SearchResponse_Count) MessageClone() proto.Message {
	return m.Clone()
}
func (m *SearchResponse_Count) Clone() *SearchResponse_Count {
	if m == nil {
		return nil
	}
	cloned := new(SearchResponse_Count)
	*cloned = *m

	return cloned
}

type SearchOptionsRequest struct {
	Categories           []SearchCategory `protobuf:"varint,1,rep,packed,name=categories,proto3,enum=v1.SearchCategory" json:"categories,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SearchOptionsRequest) Reset()         { *m = SearchOptionsRequest{} }
func (m *SearchOptionsRequest) String() string { return proto.CompactTextString(m) }
func (*SearchOptionsRequest) ProtoMessage()    {}
func (*SearchOptionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4215e5dded92b40, []int{4}
}
func (m *SearchOptionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchOptionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchOptionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchOptionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchOptionsRequest.Merge(m, src)
}
func (m *SearchOptionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchOptionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchOptionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchOptionsRequest proto.InternalMessageInfo

func (m *SearchOptionsRequest) GetCategories() []SearchCategory {
	if m != nil {
		return m.Categories
	}
	return nil
}

func (m *SearchOptionsRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *SearchOptionsRequest) Clone() *SearchOptionsRequest {
	if m == nil {
		return nil
	}
	cloned := new(SearchOptionsRequest)
	*cloned = *m

	if m.Categories != nil {
		cloned.Categories = make([]SearchCategory, len(m.Categories))
		copy(cloned.Categories, m.Categories)
	}
	return cloned
}

type SearchOptionsResponse struct {
	Options              []string `protobuf:"bytes,1,rep,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchOptionsResponse) Reset()         { *m = SearchOptionsResponse{} }
func (m *SearchOptionsResponse) String() string { return proto.CompactTextString(m) }
func (*SearchOptionsResponse) ProtoMessage()    {}
func (*SearchOptionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4215e5dded92b40, []int{5}
}
func (m *SearchOptionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchOptionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchOptionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchOptionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchOptionsResponse.Merge(m, src)
}
func (m *SearchOptionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchOptionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchOptionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchOptionsResponse proto.InternalMessageInfo

func (m *SearchOptionsResponse) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *SearchOptionsResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *SearchOptionsResponse) Clone() *SearchOptionsResponse {
	if m == nil {
		return nil
	}
	cloned := new(SearchOptionsResponse)
	*cloned = *m

	if m.Options != nil {
		cloned.Options = make([]string, len(m.Options))
		copy(cloned.Options, m.Options)
	}
	return cloned
}

type AutocompleteResponse struct {
	Values               []string `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AutocompleteResponse) Reset()         { *m = AutocompleteResponse{} }
func (m *AutocompleteResponse) String() string { return proto.CompactTextString(m) }
func (*AutocompleteResponse) ProtoMessage()    {}
func (*AutocompleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4215e5dded92b40, []int{6}
}
func (m *AutocompleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutocompleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutocompleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutocompleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutocompleteResponse.Merge(m, src)
}
func (m *AutocompleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *AutocompleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AutocompleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AutocompleteResponse proto.InternalMessageInfo

func (m *AutocompleteResponse) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *AutocompleteResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *AutocompleteResponse) Clone() *AutocompleteResponse {
	if m == nil {
		return nil
	}
	cloned := new(AutocompleteResponse)
	*cloned = *m

	if m.Values != nil {
		cloned.Values = make([]string, len(m.Values))
		copy(cloned.Values, m.Values)
	}
	return cloned
}

func init() {
	proto.RegisterEnum("v1.SearchCategory", SearchCategory_name, SearchCategory_value)
	proto.RegisterEnum("v1.SearchDataType", SearchDataType_name, SearchDataType_value)
	proto.RegisterType((*RawQuery)(nil), "v1.RawQuery")
	proto.RegisterType((*RawSearchRequest)(nil), "v1.RawSearchRequest")
	proto.RegisterType((*SearchResult)(nil), "v1.SearchResult")
	proto.RegisterMapType((map[string]*SearchResult_Matches)(nil), "v1.SearchResult.FieldToMatchesEntry")
	proto.RegisterType((*SearchResult_Matches)(nil), "v1.SearchResult.Matches")
	proto.RegisterType((*SearchResponse)(nil), "v1.SearchResponse")
	proto.RegisterType((*SearchResponse_Count)(nil), "v1.SearchResponse.Count")
	proto.RegisterType((*SearchOptionsRequest)(nil), "v1.SearchOptionsRequest")
	proto.RegisterType((*SearchOptionsResponse)(nil), "v1.SearchOptionsResponse")
	proto.RegisterType((*AutocompleteResponse)(nil), "v1.AutocompleteResponse")
}

func init() { proto.RegisterFile("api/v1/search_service.proto", fileDescriptor_c4215e5dded92b40) }

var fileDescriptor_c4215e5dded92b40 = []byte{
	// 1206 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x41, 0x73, 0xdb, 0x44,
	0x14, 0x8e, 0xec, 0xd8, 0x4e, 0x5e, 0x52, 0x77, 0xbb, 0x71, 0x1a, 0xc5, 0x69, 0x83, 0xeb, 0x16,
	0x30, 0x01, 0x14, 0x12, 0x2e, 0x0c, 0x37, 0x45, 0xde, 0xba, 0x6a, 0x65, 0xc9, 0xdd, 0x5d, 0x07,
	0x0a, 0xcc, 0x68, 0x84, 0xa3, 0xa6, 0x9e, 0x26, 0x96, 0x6b, 0xcb, 0x2e, 0xb9, 0x70, 0xe0, 0x2f,
	0x70, 0xe1, 0xc2, 0x4f, 0xe1, 0xc2, 0x89, 0x23, 0x33, 0xfc, 0x01, 0xa6, 0xf4, 0x87, 0x30, 0xbb,
	0x2b, 0xd9, 0x8a, 0x9b, 0xcc, 0xf4, 0xb6, 0xfb, 0xde, 0xf7, 0xbe, 0xf7, 0xde, 0xf7, 0x76, 0x57,
	0x82, 0x9d, 0x60, 0xd8, 0xdf, 0x9f, 0x1e, 0xec, 0x8f, 0xc3, 0x60, 0xd4, 0x7b, 0xe1, 0x8f, 0xc3,
	0xd1, 0xb4, 0xdf, 0x0b, 0x8d, 0xe1, 0x28, 0x8a, 0x23, 0x9c, 0x9b, 0x1e, 0x54, 0xef, 0x9c, 0x46,
	0xd1, 0xe9, 0x59, 0xb8, 0x2f, 0x70, 0xc1, 0x60, 0x10, 0xc5, 0x41, 0xdc, 0x8f, 0x06, 0x63, 0x85,
	0xa8, 0x6e, 0x25, 0xe1, 0xc3, 0xe0, 0xb4, 0x3f, 0x90, 0x1e, 0xe5, 0xa8, 0x77, 0x60, 0x85, 0x06,
	0xaf, 0x9f, 0x4e, 0xc2, 0xd1, 0x05, 0xae, 0x40, 0xe1, 0x95, 0x58, 0xe8, 0x5a, 0x4d, 0x6b, 0xac,
	0x52, 0xb5, 0xc1, 0x06, 0xc0, 0x3c, 0x4a, 0xcf, 0xd5, 0xb4, 0xc6, 0xda, 0x61, 0xd9, 0x98, 0x1e,
	0x18, 0x9d, 0x99, 0x95, 0x66, 0x10, 0xf5, 0x1f, 0x00, 0xd1, 0xe0, 0x35, 0x93, 0x75, 0xd2, 0xf0,
	0xd5, 0x24, 0x1c, 0xc7, 0xd7, 0x30, 0x1f, 0x02, 0xf4, 0x82, 0x38, 0x3c, 0x8d, 0x46, 0xfd, 0x70,
	0xac, 0xe7, 0x6a, 0xf9, 0x46, 0xf9, 0x10, 0x0b, 0x66, 0x15, 0x6c, 0x29, 0xdf, 0x05, 0xcd, 0xa0,
	0xea, 0x6f, 0x73, 0xb0, 0x9e, 0x72, 0x8f, 0x27, 0x67, 0x31, 0x2e, 0x43, 0xae, 0x7f, 0x92, 0xf0,
	0xe6, 0xfa, 0x27, 0x18, 0xc3, 0xf2, 0x20, 0x38, 0x0f, 0x65, 0xa1, 0xab, 0x54, 0xae, 0xb1, 0x01,
	0x2b, 0x09, 0xc5, 0x85, 0x9e, 0xaf, 0x69, 0xd7, 0xa4, 0x99, 0x61, 0xb0, 0x0b, 0xe8, 0x79, 0x3f,
	0x3c, 0x3b, 0xf1, 0xe3, 0xc8, 0x3f, 0x0f, 0xe2, 0xde, 0x8b, 0x70, 0xac, 0x2f, 0xd7, 0xf2, 0x8d,
	0xb5, 0xc3, 0x07, 0xf3, 0x38, 0x95, 0xdf, 0x78, 0x28, 0x80, 0x3c, 0x6a, 0x2b, 0x18, 0x19, 0xc4,
	0xa3, 0x0b, 0x5a, 0x7e, 0x7e, 0xc9, 0x28, 0xda, 0x1f, 0xf7, 0xa2, 0x51, 0xa8, 0x17, 0x6a, 0x5a,
	0x43, 0xa3, 0x6a, 0x83, 0xab, 0xb0, 0x72, 0x16, 0xf5, 0x94, 0xac, 0x45, 0x59, 0xed, 0x6c, 0x5f,
	0xbd, 0x07, 0xa5, 0x34, 0xf8, 0x36, 0x14, 0xa7, 0xc1, 0xd9, 0x24, 0x1c, 0xeb, 0x5a, 0x2d, 0xdf,
	0x58, 0xa5, 0xc9, 0xae, 0xfa, 0x3d, 0x6c, 0x5c, 0x91, 0x1b, 0x23, 0xc8, 0xbf, 0x0c, 0x53, 0xa1,
	0xc5, 0x12, 0x1b, 0x50, 0x90, 0x21, 0xc9, 0xec, 0xf4, 0x77, 0x5a, 0x48, 0xe2, 0xa9, 0x82, 0x7d,
	0x9d, 0xfb, 0x4a, 0xab, 0xff, 0xa1, 0x41, 0x79, 0x86, 0x19, 0x46, 0x83, 0x71, 0x88, 0xf7, 0xa0,
	0x34, 0x92, 0x78, 0x55, 0xc8, 0xda, 0x21, 0x5a, 0x24, 0xa2, 0x29, 0x00, 0x7f, 0x01, 0xc5, 0x5e,
	0x34, 0x19, 0xc4, 0x6a, 0xaa, 0x8b, 0x39, 0x25, 0x9f, 0x61, 0x09, 0x00, 0x4d, 0x70, 0xd5, 0x36,
	0x14, 0xa4, 0xe1, 0xd2, 0xac, 0xb4, 0xf7, 0x98, 0x55, 0x05, 0x0a, 0x92, 0x42, 0x76, 0x97, 0xa7,
	0x6a, 0x53, 0x7f, 0x0c, 0x15, 0x15, 0xe1, 0x0d, 0xe5, 0x35, 0x48, 0x0f, 0xe2, 0xe5, 0x23, 0xa7,
	0xbd, 0xd7, 0x91, 0x3b, 0x80, 0xcd, 0x05, 0xae, 0x44, 0x11, 0x1d, 0x4a, 0x91, 0x32, 0x25, 0xa3,
	0x49, 0xb7, 0x75, 0x03, 0x2a, 0xe6, 0x24, 0x8e, 0x7a, 0xd1, 0xf9, 0xf0, 0x2c, 0x8c, 0xc3, 0x59,
	0xc4, 0x35, 0xb3, 0xdc, 0xfb, 0xb3, 0x94, 0xca, 0x9d, 0x56, 0x80, 0x11, 0xac, 0x33, 0x62, 0x52,
	0xeb, 0x91, 0xdf, 0x75, 0x19, 0xe1, 0x68, 0x09, 0x03, 0x14, 0x4d, 0x87, 0x50, 0xce, 0x90, 0x26,
	0xd6, 0x76, 0xdb, 0x6c, 0x11, 0x86, 0x72, 0xb8, 0x02, 0x48, 0xae, 0x7d, 0xcb, 0x6b, 0x77, 0x3c,
	0x97, 0xb8, 0x9c, 0xa1, 0x0a, 0xde, 0x80, 0x9b, 0xca, 0x7a, 0xdc, 0x75, 0x5c, 0x9f, 0x34, 0x5b,
	0x04, 0xed, 0x60, 0x1d, 0x2a, 0x0b, 0x50, 0xe5, 0xd9, 0xc2, 0xeb, 0xb0, 0xd2, 0xf1, 0x1c, 0xdb,
	0xb2, 0x09, 0x43, 0x79, 0x7c, 0x13, 0xd6, 0x9a, 0xa4, 0xe3, 0x78, 0xcf, 0xda, 0x92, 0x6d, 0x59,
	0xe4, 0x30, 0x2d, 0x6e, 0x1f, 0x67, 0x22, 0xd1, 0x2e, 0x5e, 0x81, 0xe5, 0x8e, 0xd7, 0x64, 0x68,
	0x1b, 0xaf, 0x41, 0x89, 0x11, 0x8b, 0x12, 0xce, 0x50, 0x01, 0xdf, 0x06, 0xdc, 0xa1, 0x9e, 0x45,
	0x18, 0xf3, 0x6d, 0xb7, 0x69, 0x5b, 0x26, 0xf7, 0x28, 0x43, 0x45, 0x5c, 0x06, 0x10, 0xd1, 0x8e,
	0x6d, 0xba, 0x16, 0x41, 0x25, 0x91, 0xd3, 0x72, 0xba, 0x8c, 0x13, 0xca, 0xd0, 0x8a, 0xf0, 0xba,
	0x66, 0x9b, 0xb0, 0x8e, 0x69, 0x11, 0x86, 0x56, 0xf1, 0x2a, 0x14, 0x5c, 0xaf, 0x49, 0x18, 0x02,
	0xd1, 0x8b, 0x58, 0x66, 0x1b, 0xfc, 0x08, 0x63, 0x28, 0x4b, 0xe3, 0xbc, 0xbf, 0x3b, 0x78, 0x0b,
	0x36, 0x2e, 0x03, 0x95, 0xe3, 0x2e, 0xde, 0x81, 0xad, 0x05, 0x87, 0x75, 0x4c, 0x94, 0xf3, 0x9e,
	0x88, 0x9a, 0xd7, 0xe5, 0x33, 0x6e, 0xba, 0x4d, 0x93, 0x36, 0xd1, 0x1a, 0xbe, 0x03, 0x7a, 0xc6,
	0x61, 0x79, 0x2e, 0xa7, 0x9e, 0xe3, 0xb7, 0xa8, 0xd7, 0xed, 0xa0, 0x75, 0xd1, 0xe6, 0xbb, 0x5e,
	0x74, 0x43, 0x68, 0xc5, 0x08, 0x3d, 0xb6, 0x2d, 0xe2, 0x9b, 0x96, 0xe5, 0x75, 0x45, 0xb9, 0x65,
	0xd1, 0x0e, 0xf5, 0x1c, 0xc2, 0xd0, 0x4d, 0x31, 0x5a, 0xb1, 0x3c, 0x12, 0xe2, 0xb8, 0x2d, 0x86,
	0x10, 0xde, 0x86, 0x4d, 0x4a, 0x3a, 0x1e, 0xe5, 0x82, 0xe6, 0xa1, 0xdd, 0xea, 0x52, 0x93, 0xdb,
	0x9e, 0xcb, 0xd0, 0x87, 0x78, 0x13, 0x6e, 0xa5, 0x62, 0x1e, 0x99, 0x8c, 0x38, 0xb6, 0x4b, 0x18,
	0xba, 0x25, 0xb4, 0x63, 0xdd, 0xa3, 0xc7, 0xc4, 0xe2, 0x0c, 0x61, 0x49, 0x6e, 0xb3, 0x27, 0x0c,
	0x6d, 0x08, 0xad, 0x84, 0x22, 0x84, 0x9a, 0x47, 0xb6, 0x63, 0x73, 0x31, 0xcf, 0x4d, 0xd1, 0x7e,
	0xa2, 0xb4, 0xbf, 0xe8, 0xac, 0x8b, 0xe4, 0xf3, 0x93, 0x92, 0x75, 0xdd, 0x17, 0xe7, 0x65, 0xa6,
	0x71, 0xd6, 0xf3, 0x20, 0xd5, 0x4c, 0x69, 0x39, 0x1f, 0xc1, 0x6d, 0x51, 0x6f, 0x36, 0x95, 0x32,
	0xeb, 0x72, 0x5a, 0x84, 0x7f, 0xe3, 0xd1, 0x27, 0x3e, 0x71, 0xb9, 0xcd, 0x9f, 0xa1, 0xaa, 0xd0,
	0x41, 0x42, 0x28, 0x79, 0xda, 0x25, 0x8c, 0xa3, 0x9a, 0x90, 0x2e, 0x45, 0xa5, 0xcd, 0xa2, 0x8f,
	0xb3, 0xd6, 0xd9, 0x19, 0x6d, 0x88, 0xe1, 0x2c, 0x0a, 0xe3, 0x53, 0xc2, 0xba, 0x0e, 0x67, 0xe8,
	0x93, 0x85, 0x99, 0xb6, 0x09, 0x37, 0x9b, 0x26, 0x37, 0xd1, 0xde, 0xc2, 0xd4, 0xd2, 0x80, 0x4f,
	0x65, 0xdd, 0x73, 0x7b, 0xd3, 0x6b, 0x9b, 0xb6, 0x8b, 0x3e, 0x13, 0x75, 0xa7, 0xed, 0x3c, 0x22,
	0xa6, 0xc3, 0x1f, 0xa1, 0xcf, 0xe5, 0x48, 0x44, 0x1d, 0xcf, 0x7c, 0xcb, 0xe4, 0xa4, 0xe5, 0x51,
	0x51, 0x90, 0xb1, 0xf7, 0x73, 0x7a, 0x87, 0x9b, 0x41, 0x1c, 0xf0, 0x8b, 0x61, 0x28, 0xae, 0x51,
	0x72, 0x87, 0x8f, 0x3c, 0xcf, 0x41, 0x4b, 0x82, 0x2d, 0x31, 0xb8, 0xdd, 0x36, 0xa1, 0xb6, 0x85,
	0x34, 0x7c, 0x0b, 0x6e, 0x24, 0x36, 0xc6, 0xa9, 0xed, 0xb6, 0x50, 0x4e, 0xcc, 0x30, 0x31, 0x35,
	0x4d, 0x4e, 0xb8, 0xdd, 0x26, 0x28, 0x2f, 0xee, 0x47, 0x62, 0x6c, 0x9b, 0x1d, 0xb4, 0x9c, 0x21,
	0x27, 0x6e, 0xb7, 0x8d, 0x0a, 0x87, 0xbf, 0xe7, 0xe0, 0x86, 0x2a, 0x80, 0xa9, 0xbf, 0x03, 0xfc,
	0x10, 0x8a, 0xca, 0x80, 0x2b, 0xe2, 0x8d, 0x5b, 0xfc, 0x2c, 0x57, 0xf1, 0xbb, 0xcf, 0x72, 0x1d,
	0xff, 0xf2, 0xcf, 0xdb, 0x5f, 0x73, 0xeb, 0x18, 0xe6, 0x7f, 0x1b, 0xb8, 0x07, 0xa5, 0xe4, 0xed,
	0xc3, 0x99, 0x97, 0xfc, 0xf2, 0xd3, 0x5a, 0xdd, 0xbe, 0xc2, 0x93, 0x70, 0xde, 0x97, 0x9c, 0x77,
	0xf1, 0xce, 0x9c, 0x73, 0xff, 0x3c, 0x8c, 0x83, 0x93, 0x20, 0x0e, 0xf6, 0x93, 0x37, 0x13, 0xfb,
	0xb0, 0x9e, 0x7d, 0x33, 0xaf, 0x29, 0x59, 0xe6, 0xbf, 0xea, 0x6d, 0xad, 0x7f, 0x20, 0x93, 0x6c,
	0xe3, 0xad, 0x4c, 0x92, 0x20, 0x03, 0x3c, 0x32, 0xfe, 0x7a, 0xb3, 0xab, 0xfd, 0xfd, 0x66, 0x57,
	0xfb, 0xf7, 0xcd, 0xae, 0xf6, 0xdb, 0x7f, 0xbb, 0x4b, 0xa0, 0xf7, 0x23, 0x63, 0x1c, 0x07, 0xbd,
	0x97, 0xa3, 0xe8, 0x27, 0xf5, 0x3f, 0x64, 0x04, 0xc3, 0xbe, 0x31, 0x3d, 0xf8, 0x2e, 0x37, 0x3d,
	0xf8, 0x76, 0xe9, 0xc7, 0xa2, 0xb4, 0x7d, 0xf9, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4f, 0x0b,
	0x72, 0x34, 0x7d, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// SearchServiceClient is the client API for SearchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConnInterface.NewStream.
type SearchServiceClient interface {
	Search(ctx context.Context, in *RawSearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	Options(ctx context.Context, in *SearchOptionsRequest, opts ...grpc.CallOption) (*SearchOptionsResponse, error)
	Autocomplete(ctx context.Context, in *RawSearchRequest, opts ...grpc.CallOption) (*AutocompleteResponse, error)
}

type searchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSearchServiceClient(cc grpc.ClientConnInterface) SearchServiceClient {
	return &searchServiceClient{cc}
}

func (c *searchServiceClient) Search(ctx context.Context, in *RawSearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/v1.SearchService/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) Options(ctx context.Context, in *SearchOptionsRequest, opts ...grpc.CallOption) (*SearchOptionsResponse, error) {
	out := new(SearchOptionsResponse)
	err := c.cc.Invoke(ctx, "/v1.SearchService/Options", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) Autocomplete(ctx context.Context, in *RawSearchRequest, opts ...grpc.CallOption) (*AutocompleteResponse, error) {
	out := new(AutocompleteResponse)
	err := c.cc.Invoke(ctx, "/v1.SearchService/Autocomplete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearchServiceServer is the server API for SearchService service.
type SearchServiceServer interface {
	Search(context.Context, *RawSearchRequest) (*SearchResponse, error)
	Options(context.Context, *SearchOptionsRequest) (*SearchOptionsResponse, error)
	Autocomplete(context.Context, *RawSearchRequest) (*AutocompleteResponse, error)
}

// UnimplementedSearchServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSearchServiceServer struct {
}

func (*UnimplementedSearchServiceServer) Search(ctx context.Context, req *RawSearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (*UnimplementedSearchServiceServer) Options(ctx context.Context, req *SearchOptionsRequest) (*SearchOptionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Options not implemented")
}
func (*UnimplementedSearchServiceServer) Autocomplete(ctx context.Context, req *RawSearchRequest) (*AutocompleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Autocomplete not implemented")
}

func RegisterSearchServiceServer(s *grpc.Server, srv SearchServiceServer) {
	s.RegisterService(&_SearchService_serviceDesc, srv)
}

func _SearchService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.SearchService/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).Search(ctx, req.(*RawSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_Options_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchOptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).Options(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.SearchService/Options",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).Options(ctx, req.(*SearchOptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_Autocomplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).Autocomplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.SearchService/Autocomplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).Autocomplete(ctx, req.(*RawSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SearchService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1.SearchService",
	HandlerType: (*SearchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _SearchService_Search_Handler,
		},
		{
			MethodName: "Options",
			Handler:    _SearchService_Options_Handler,
		},
		{
			MethodName: "Autocomplete",
			Handler:    _SearchService_Autocomplete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/search_service.proto",
}

func (m *RawQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSearchService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintSearchService(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawSearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawSearchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawSearchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Categories) > 0 {
		dAtA3 := make([]byte, len(m.Categories)*10)
		var j2 int
		for _, num := range m.Categories {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintSearchService(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintSearchService(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintSearchService(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x32
	}
	if m.Score != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Score))))
		i--
		dAtA[i] = 0x29
	}
	if len(m.FieldToMatches) > 0 {
		for k := range m.FieldToMatches {
			v := m.FieldToMatches[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSearchService(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSearchService(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSearchService(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Category != 0 {
		i = encodeVarintSearchService(dAtA, i, uint64(m.Category))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSearchService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSearchService(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchResult_Matches) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResult_Matches) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchResult_Matches) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintSearchService(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Counts) > 0 {
		for iNdEx := len(m.Counts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Counts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSearchService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSearchService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SearchResponse_Count) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse_Count) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchResponse_Count) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintSearchService(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Category != 0 {
		i = encodeVarintSearchService(dAtA, i, uint64(m.Category))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchOptionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchOptionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchOptionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Categories) > 0 {
		dAtA6 := make([]byte, len(m.Categories)*10)
		var j5 int
		for _, num := range m.Categories {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintSearchService(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchOptionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchOptionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchOptionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Options[iNdEx])
			copy(dAtA[i:], m.Options[iNdEx])
			i = encodeVarintSearchService(dAtA, i, uint64(len(m.Options[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AutocompleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutocompleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutocompleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintSearchService(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintSearchService(dAtA []byte, offset int, v uint64) int {
	offset -= sovSearchService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RawQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSearchService(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovSearchService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawSearchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSearchService(uint64(l))
	}
	if len(m.Categories) > 0 {
		l = 0
		for _, e := range m.Categories {
			l += sovSearchService(uint64(e))
		}
		n += 1 + sovSearchService(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSearchService(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSearchService(uint64(l))
	}
	if m.Category != 0 {
		n += 1 + sovSearchService(uint64(m.Category))
	}
	if len(m.FieldToMatches) > 0 {
		for k, v := range m.FieldToMatches {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearchService(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearchService(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearchService(uint64(mapEntrySize))
		}
	}
	if m.Score != 0 {
		n += 9
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovSearchService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchResult_Matches) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovSearchService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovSearchService(uint64(l))
		}
	}
	if len(m.Counts) > 0 {
		for _, e := range m.Counts {
			l = e.Size()
			n += 1 + l + sovSearchService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchResponse_Count) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Category != 0 {
		n += 1 + sovSearchService(uint64(m.Category))
	}
	if m.Count != 0 {
		n += 1 + sovSearchService(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchOptionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Categories) > 0 {
		l = 0
		for _, e := range m.Categories {
			l += sovSearchService(uint64(e))
		}
		n += 1 + sovSearchService(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchOptionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			l = len(s)
			n += 1 + l + sovSearchService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutocompleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovSearchService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSearchService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSearchService(x uint64) (n int) {
	return sovSearchService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RawQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearchService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &Pagination{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearchService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSearchService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawSearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearchService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawSearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawSearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v SearchCategory
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearchService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= SearchCategory(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Categories = append(m.Categories, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearchService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSearchService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSearchService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Categories) == 0 {
					m.Categories = make([]SearchCategory, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v SearchCategory
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearchService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= SearchCategory(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Categories = append(m.Categories, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSearchService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSearchService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearchService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= SearchCategory(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldToMatches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldToMatches == nil {
				m.FieldToMatches = make(map[string]*SearchResult_Matches)
			}
			var mapkey string
			var mapvalue *SearchResult_Matches
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearchService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearchService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearchService
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSearchService
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearchService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearchService
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSearchService
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SearchResult_Matches{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearchService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSearchService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FieldToMatches[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Score = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearchService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSearchService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResult_Matches) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearchService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Matches: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Matches: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearchService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSearchService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearchService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &SearchResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Counts = append(m.Counts, &SearchResponse_Count{})
			if err := m.Counts[len(m.Counts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearchService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSearchService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse_Count) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearchService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Count: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Count: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= SearchCategory(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSearchService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSearchService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchOptionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearchService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchOptionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchOptionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v SearchCategory
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearchService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= SearchCategory(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Categories = append(m.Categories, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearchService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSearchService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSearchService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Categories) == 0 {
					m.Categories = make([]SearchCategory, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v SearchCategory
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearchService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= SearchCategory(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Categories = append(m.Categories, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSearchService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSearchService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchOptionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearchService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchOptionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchOptionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearchService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSearchService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutocompleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearchService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutocompleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutocompleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearchService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSearchService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearchService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSearchService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSearchService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSearchService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSearchService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSearchService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSearchService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSearchService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSearchService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSearchService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSearchService = fmt.Errorf("proto: unexpected end of group")
)
