// Code generated by protoc-gen-go-vtproto. DO NOT EDIT.
// protoc-gen-go-vtproto version: v0.3.1-0.20220817155510-0ae748fd2007
// source: api/v1/network_policy_service.proto

package v1

import (
	context "context"
	fmt "fmt"
	storage "github.com/stackrox/rox/generated/storage"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	proto "google.golang.org/protobuf/proto"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

func (m *GetNetworkPoliciesRequest) CloneVT() *GetNetworkPoliciesRequest {
	if m == nil {
		return (*GetNetworkPoliciesRequest)(nil)
	}
	r := &GetNetworkPoliciesRequest{
		ClusterId:       m.ClusterId,
		DeploymentQuery: m.DeploymentQuery,
		Namespace:       m.Namespace,
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetNetworkPoliciesRequest) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *NetworkPoliciesResponse) CloneVT() *NetworkPoliciesResponse {
	if m == nil {
		return (*NetworkPoliciesResponse)(nil)
	}
	r := &NetworkPoliciesResponse{}
	if rhs := m.NetworkPolicies; rhs != nil {
		tmpContainer := make([]*storage.NetworkPolicy, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface{ CloneVT() *storage.NetworkPolicy }); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*storage.NetworkPolicy)
			}
		}
		r.NetworkPolicies = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *NetworkPoliciesResponse) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *SendNetworkPolicyYamlRequest) CloneVT() *SendNetworkPolicyYamlRequest {
	if m == nil {
		return (*SendNetworkPolicyYamlRequest)(nil)
	}
	r := &SendNetworkPolicyYamlRequest{
		ClusterId: m.ClusterId,
	}
	if rhs := m.NotifierIds; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.NotifierIds = tmpContainer
	}
	if rhs := m.Modification; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *storage.NetworkPolicyModification
		}); ok {
			r.Modification = vtpb.CloneVT()
		} else {
			r.Modification = proto.Clone(rhs).(*storage.NetworkPolicyModification)
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SendNetworkPolicyYamlRequest) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GetNetworkGraphRequest) CloneVT() *GetNetworkGraphRequest {
	if m == nil {
		return (*GetNetworkGraphRequest)(nil)
	}
	r := &GetNetworkGraphRequest{
		ClusterId:    m.ClusterId,
		Query:        m.Query,
		IncludePorts: m.IncludePorts,
		Scope:        m.Scope.CloneVT(),
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetNetworkGraphRequest) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *SimulateNetworkGraphRequest) CloneVT() *SimulateNetworkGraphRequest {
	if m == nil {
		return (*SimulateNetworkGraphRequest)(nil)
	}
	r := &SimulateNetworkGraphRequest{
		ClusterId:       m.ClusterId,
		Query:           m.Query,
		IncludePorts:    m.IncludePorts,
		IncludeNodeDiff: m.IncludeNodeDiff,
		Scope:           m.Scope.CloneVT(),
	}
	if rhs := m.Modification; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *storage.NetworkPolicyModification
		}); ok {
			r.Modification = vtpb.CloneVT()
		} else {
			r.Modification = proto.Clone(rhs).(*storage.NetworkPolicyModification)
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SimulateNetworkGraphRequest) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *ApplyNetworkPolicyYamlRequest) CloneVT() *ApplyNetworkPolicyYamlRequest {
	if m == nil {
		return (*ApplyNetworkPolicyYamlRequest)(nil)
	}
	r := &ApplyNetworkPolicyYamlRequest{
		ClusterId: m.ClusterId,
	}
	if rhs := m.Modification; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *storage.NetworkPolicyModification
		}); ok {
			r.Modification = vtpb.CloneVT()
		} else {
			r.Modification = proto.Clone(rhs).(*storage.NetworkPolicyModification)
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ApplyNetworkPolicyYamlRequest) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GetUndoModificationRequest) CloneVT() *GetUndoModificationRequest {
	if m == nil {
		return (*GetUndoModificationRequest)(nil)
	}
	r := &GetUndoModificationRequest{
		ClusterId: m.ClusterId,
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetUndoModificationRequest) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GetUndoModificationResponse) CloneVT() *GetUndoModificationResponse {
	if m == nil {
		return (*GetUndoModificationResponse)(nil)
	}
	r := &GetUndoModificationResponse{}
	if rhs := m.UndoRecord; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *storage.NetworkPolicyApplicationUndoRecord
		}); ok {
			r.UndoRecord = vtpb.CloneVT()
		} else {
			r.UndoRecord = proto.Clone(rhs).(*storage.NetworkPolicyApplicationUndoRecord)
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetUndoModificationResponse) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *NetworkPolicyInSimulation) CloneVT() *NetworkPolicyInSimulation {
	if m == nil {
		return (*NetworkPolicyInSimulation)(nil)
	}
	r := &NetworkPolicyInSimulation{
		Status: m.Status,
	}
	if rhs := m.Policy; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *storage.NetworkPolicy }); ok {
			r.Policy = vtpb.CloneVT()
		} else {
			r.Policy = proto.Clone(rhs).(*storage.NetworkPolicy)
		}
	}
	if rhs := m.OldPolicy; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *storage.NetworkPolicy }); ok {
			r.OldPolicy = vtpb.CloneVT()
		} else {
			r.OldPolicy = proto.Clone(rhs).(*storage.NetworkPolicy)
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *NetworkPolicyInSimulation) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *NetworkNodeDiff) CloneVT() *NetworkNodeDiff {
	if m == nil {
		return (*NetworkNodeDiff)(nil)
	}
	r := &NetworkNodeDiff{
		NonIsolatedIngress: m.NonIsolatedIngress,
		NonIsolatedEgress:  m.NonIsolatedEgress,
	}
	if rhs := m.PolicyIds; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.PolicyIds = tmpContainer
	}
	if rhs := m.DEPRECATEDOutEdges; rhs != nil {
		tmpContainer := make(map[int32]*NetworkEdgePropertiesBundle, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.DEPRECATEDOutEdges = tmpContainer
	}
	if rhs := m.OutEdges; rhs != nil {
		tmpContainer := make(map[string]*NetworkEdgePropertiesBundle, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.OutEdges = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *NetworkNodeDiff) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *NetworkGraphDiff) CloneVT() *NetworkGraphDiff {
	if m == nil {
		return (*NetworkGraphDiff)(nil)
	}
	r := &NetworkGraphDiff{}
	if rhs := m.DEPRECATEDNodeDiffs; rhs != nil {
		tmpContainer := make(map[int32]*NetworkNodeDiff, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.DEPRECATEDNodeDiffs = tmpContainer
	}
	if rhs := m.NodeDiffs; rhs != nil {
		tmpContainer := make(map[string]*NetworkNodeDiff, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.NodeDiffs = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *NetworkGraphDiff) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *SimulateNetworkGraphResponse) CloneVT() *SimulateNetworkGraphResponse {
	if m == nil {
		return (*SimulateNetworkGraphResponse)(nil)
	}
	r := &SimulateNetworkGraphResponse{
		SimulatedGraph: m.SimulatedGraph.CloneVT(),
		Added:          m.Added.CloneVT(),
		Removed:        m.Removed.CloneVT(),
	}
	if rhs := m.Policies; rhs != nil {
		tmpContainer := make([]*NetworkPolicyInSimulation, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Policies = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SimulateNetworkGraphResponse) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GetNetworkGraphEpochRequest) CloneVT() *GetNetworkGraphEpochRequest {
	if m == nil {
		return (*GetNetworkGraphEpochRequest)(nil)
	}
	r := &GetNetworkGraphEpochRequest{
		ClusterId: m.ClusterId,
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetNetworkGraphEpochRequest) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *NetworkGraphEpoch) CloneVT() *NetworkGraphEpoch {
	if m == nil {
		return (*NetworkGraphEpoch)(nil)
	}
	r := &NetworkGraphEpoch{
		Epoch: m.Epoch,
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *NetworkGraphEpoch) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GenerateNetworkPoliciesRequest) CloneVT() *GenerateNetworkPoliciesRequest {
	if m == nil {
		return (*GenerateNetworkPoliciesRequest)(nil)
	}
	r := &GenerateNetworkPoliciesRequest{
		ClusterId:      m.ClusterId,
		Query:          m.Query,
		DeleteExisting: m.DeleteExisting,
		IncludePorts:   m.IncludePorts,
	}
	if rhs := m.NetworkDataSince; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface{ CloneVT() *timestamppb.Timestamp }); ok {
			r.NetworkDataSince = vtpb.CloneVT()
		} else {
			r.NetworkDataSince = proto.Clone(rhs).(*timestamppb.Timestamp)
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GenerateNetworkPoliciesRequest) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GenerateNetworkPoliciesResponse) CloneVT() *GenerateNetworkPoliciesResponse {
	if m == nil {
		return (*GenerateNetworkPoliciesResponse)(nil)
	}
	r := &GenerateNetworkPoliciesResponse{}
	if rhs := m.Modification; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *storage.NetworkPolicyModification
		}); ok {
			r.Modification = vtpb.CloneVT()
		} else {
			r.Modification = proto.Clone(rhs).(*storage.NetworkPolicyModification)
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GenerateNetworkPoliciesResponse) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GetBaselineGeneratedPolicyForDeploymentRequest) CloneVT() *GetBaselineGeneratedPolicyForDeploymentRequest {
	if m == nil {
		return (*GetBaselineGeneratedPolicyForDeploymentRequest)(nil)
	}
	r := &GetBaselineGeneratedPolicyForDeploymentRequest{
		DeploymentId:   m.DeploymentId,
		DeleteExisting: m.DeleteExisting,
		IncludePorts:   m.IncludePorts,
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetBaselineGeneratedPolicyForDeploymentRequest) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GetBaselineGeneratedPolicyForDeploymentResponse) CloneVT() *GetBaselineGeneratedPolicyForDeploymentResponse {
	if m == nil {
		return (*GetBaselineGeneratedPolicyForDeploymentResponse)(nil)
	}
	r := &GetBaselineGeneratedPolicyForDeploymentResponse{}
	if rhs := m.Modification; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *storage.NetworkPolicyModification
		}); ok {
			r.Modification = vtpb.CloneVT()
		} else {
			r.Modification = proto.Clone(rhs).(*storage.NetworkPolicyModification)
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetBaselineGeneratedPolicyForDeploymentResponse) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GetAllowedPeersFromCurrentPolicyForDeploymentResponse) CloneVT() *GetAllowedPeersFromCurrentPolicyForDeploymentResponse {
	if m == nil {
		return (*GetAllowedPeersFromCurrentPolicyForDeploymentResponse)(nil)
	}
	r := &GetAllowedPeersFromCurrentPolicyForDeploymentResponse{}
	if rhs := m.AllowedPeers; rhs != nil {
		tmpContainer := make([]*NetworkBaselineStatusPeer, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.AllowedPeers = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetAllowedPeersFromCurrentPolicyForDeploymentResponse) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *ApplyNetworkPolicyYamlForDeploymentRequest) CloneVT() *ApplyNetworkPolicyYamlForDeploymentRequest {
	if m == nil {
		return (*ApplyNetworkPolicyYamlForDeploymentRequest)(nil)
	}
	r := &ApplyNetworkPolicyYamlForDeploymentRequest{
		DeploymentId: m.DeploymentId,
	}
	if rhs := m.Modification; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *storage.NetworkPolicyModification
		}); ok {
			r.Modification = vtpb.CloneVT()
		} else {
			r.Modification = proto.Clone(rhs).(*storage.NetworkPolicyModification)
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ApplyNetworkPolicyYamlForDeploymentRequest) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GetUndoModificationForDeploymentResponse) CloneVT() *GetUndoModificationForDeploymentResponse {
	if m == nil {
		return (*GetUndoModificationForDeploymentResponse)(nil)
	}
	r := &GetUndoModificationForDeploymentResponse{}
	if rhs := m.UndoRecord; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *storage.NetworkPolicyApplicationUndoRecord
		}); ok {
			r.UndoRecord = vtpb.CloneVT()
		} else {
			r.UndoRecord = proto.Clone(rhs).(*storage.NetworkPolicyApplicationUndoRecord)
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetUndoModificationForDeploymentResponse) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GetDiffFlowsReconciledFlow) CloneVT() *GetDiffFlowsReconciledFlow {
	if m == nil {
		return (*GetDiffFlowsReconciledFlow)(nil)
	}
	r := &GetDiffFlowsReconciledFlow{}
	if rhs := m.Entity; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *storage.NetworkEntityInfo
		}); ok {
			r.Entity = vtpb.CloneVT()
		} else {
			r.Entity = proto.Clone(rhs).(*storage.NetworkEntityInfo)
		}
	}
	if rhs := m.Added; rhs != nil {
		tmpContainer := make([]*storage.NetworkBaselineConnectionProperties, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface {
				CloneVT() *storage.NetworkBaselineConnectionProperties
			}); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*storage.NetworkBaselineConnectionProperties)
			}
		}
		r.Added = tmpContainer
	}
	if rhs := m.Removed; rhs != nil {
		tmpContainer := make([]*storage.NetworkBaselineConnectionProperties, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface {
				CloneVT() *storage.NetworkBaselineConnectionProperties
			}); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*storage.NetworkBaselineConnectionProperties)
			}
		}
		r.Removed = tmpContainer
	}
	if rhs := m.Unchanged; rhs != nil {
		tmpContainer := make([]*storage.NetworkBaselineConnectionProperties, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface {
				CloneVT() *storage.NetworkBaselineConnectionProperties
			}); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*storage.NetworkBaselineConnectionProperties)
			}
		}
		r.Unchanged = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetDiffFlowsReconciledFlow) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GetDiffFlowsGroupedFlow) CloneVT() *GetDiffFlowsGroupedFlow {
	if m == nil {
		return (*GetDiffFlowsGroupedFlow)(nil)
	}
	r := &GetDiffFlowsGroupedFlow{}
	if rhs := m.Entity; rhs != nil {
		if vtpb, ok := interface{}(rhs).(interface {
			CloneVT() *storage.NetworkEntityInfo
		}); ok {
			r.Entity = vtpb.CloneVT()
		} else {
			r.Entity = proto.Clone(rhs).(*storage.NetworkEntityInfo)
		}
	}
	if rhs := m.Properties; rhs != nil {
		tmpContainer := make([]*storage.NetworkBaselineConnectionProperties, len(rhs))
		for k, v := range rhs {
			if vtpb, ok := interface{}(v).(interface {
				CloneVT() *storage.NetworkBaselineConnectionProperties
			}); ok {
				tmpContainer[k] = vtpb.CloneVT()
			} else {
				tmpContainer[k] = proto.Clone(v).(*storage.NetworkBaselineConnectionProperties)
			}
		}
		r.Properties = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetDiffFlowsGroupedFlow) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (m *GetDiffFlowsResponse) CloneVT() *GetDiffFlowsResponse {
	if m == nil {
		return (*GetDiffFlowsResponse)(nil)
	}
	r := &GetDiffFlowsResponse{}
	if rhs := m.Added; rhs != nil {
		tmpContainer := make([]*GetDiffFlowsGroupedFlow, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Added = tmpContainer
	}
	if rhs := m.Removed; rhs != nil {
		tmpContainer := make([]*GetDiffFlowsGroupedFlow, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Removed = tmpContainer
	}
	if rhs := m.Reconciled; rhs != nil {
		tmpContainer := make([]*GetDiffFlowsReconciledFlow, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Reconciled = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GetDiffFlowsResponse) CloneGenericVT() proto.Message {
	return m.CloneVT()
}

func (this *GetNetworkPoliciesRequest) EqualVT(that *GetNetworkPoliciesRequest) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.ClusterId != that.ClusterId {
		return false
	}
	if this.DeploymentQuery != that.DeploymentQuery {
		return false
	}
	if this.Namespace != that.Namespace {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *NetworkPoliciesResponse) EqualVT(that *NetworkPoliciesResponse) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.NetworkPolicies) != len(that.NetworkPolicies) {
		return false
	}
	for i, vx := range this.NetworkPolicies {
		vy := that.NetworkPolicies[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &storage.NetworkPolicy{}
			}
			if q == nil {
				q = &storage.NetworkPolicy{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*storage.NetworkPolicy) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SendNetworkPolicyYamlRequest) EqualVT(that *SendNetworkPolicyYamlRequest) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.ClusterId != that.ClusterId {
		return false
	}
	if len(this.NotifierIds) != len(that.NotifierIds) {
		return false
	}
	for i, vx := range this.NotifierIds {
		vy := that.NotifierIds[i]
		if vx != vy {
			return false
		}
	}
	if equal, ok := interface{}(this.Modification).(interface {
		EqualVT(*storage.NetworkPolicyModification) bool
	}); ok {
		if !equal.EqualVT(that.Modification) {
			return false
		}
	} else if !proto.Equal(this.Modification, that.Modification) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetNetworkGraphRequest) EqualVT(that *GetNetworkGraphRequest) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.ClusterId != that.ClusterId {
		return false
	}
	if this.Query != that.Query {
		return false
	}
	if this.IncludePorts != that.IncludePorts {
		return false
	}
	if !this.Scope.EqualVT(that.Scope) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SimulateNetworkGraphRequest) EqualVT(that *SimulateNetworkGraphRequest) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.ClusterId != that.ClusterId {
		return false
	}
	if this.Query != that.Query {
		return false
	}
	if equal, ok := interface{}(this.Modification).(interface {
		EqualVT(*storage.NetworkPolicyModification) bool
	}); ok {
		if !equal.EqualVT(that.Modification) {
			return false
		}
	} else if !proto.Equal(this.Modification, that.Modification) {
		return false
	}
	if this.IncludePorts != that.IncludePorts {
		return false
	}
	if this.IncludeNodeDiff != that.IncludeNodeDiff {
		return false
	}
	if !this.Scope.EqualVT(that.Scope) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ApplyNetworkPolicyYamlRequest) EqualVT(that *ApplyNetworkPolicyYamlRequest) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.ClusterId != that.ClusterId {
		return false
	}
	if equal, ok := interface{}(this.Modification).(interface {
		EqualVT(*storage.NetworkPolicyModification) bool
	}); ok {
		if !equal.EqualVT(that.Modification) {
			return false
		}
	} else if !proto.Equal(this.Modification, that.Modification) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetUndoModificationRequest) EqualVT(that *GetUndoModificationRequest) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.ClusterId != that.ClusterId {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetUndoModificationResponse) EqualVT(that *GetUndoModificationResponse) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if equal, ok := interface{}(this.UndoRecord).(interface {
		EqualVT(*storage.NetworkPolicyApplicationUndoRecord) bool
	}); ok {
		if !equal.EqualVT(that.UndoRecord) {
			return false
		}
	} else if !proto.Equal(this.UndoRecord, that.UndoRecord) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *NetworkPolicyInSimulation) EqualVT(that *NetworkPolicyInSimulation) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if equal, ok := interface{}(this.Policy).(interface {
		EqualVT(*storage.NetworkPolicy) bool
	}); ok {
		if !equal.EqualVT(that.Policy) {
			return false
		}
	} else if !proto.Equal(this.Policy, that.Policy) {
		return false
	}
	if this.Status != that.Status {
		return false
	}
	if equal, ok := interface{}(this.OldPolicy).(interface {
		EqualVT(*storage.NetworkPolicy) bool
	}); ok {
		if !equal.EqualVT(that.OldPolicy) {
			return false
		}
	} else if !proto.Equal(this.OldPolicy, that.OldPolicy) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *NetworkNodeDiff) EqualVT(that *NetworkNodeDiff) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.PolicyIds) != len(that.PolicyIds) {
		return false
	}
	for i, vx := range this.PolicyIds {
		vy := that.PolicyIds[i]
		if vx != vy {
			return false
		}
	}
	if len(this.DEPRECATEDOutEdges) != len(that.DEPRECATEDOutEdges) {
		return false
	}
	for i, vx := range this.DEPRECATEDOutEdges {
		vy, ok := that.DEPRECATEDOutEdges[i]
		if !ok {
			return false
		}
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &NetworkEdgePropertiesBundle{}
			}
			if q == nil {
				q = &NetworkEdgePropertiesBundle{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.NonIsolatedIngress != that.NonIsolatedIngress {
		return false
	}
	if this.NonIsolatedEgress != that.NonIsolatedEgress {
		return false
	}
	if len(this.OutEdges) != len(that.OutEdges) {
		return false
	}
	for i, vx := range this.OutEdges {
		vy, ok := that.OutEdges[i]
		if !ok {
			return false
		}
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &NetworkEdgePropertiesBundle{}
			}
			if q == nil {
				q = &NetworkEdgePropertiesBundle{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *NetworkGraphDiff) EqualVT(that *NetworkGraphDiff) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.DEPRECATEDNodeDiffs) != len(that.DEPRECATEDNodeDiffs) {
		return false
	}
	for i, vx := range this.DEPRECATEDNodeDiffs {
		vy, ok := that.DEPRECATEDNodeDiffs[i]
		if !ok {
			return false
		}
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &NetworkNodeDiff{}
			}
			if q == nil {
				q = &NetworkNodeDiff{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.NodeDiffs) != len(that.NodeDiffs) {
		return false
	}
	for i, vx := range this.NodeDiffs {
		vy, ok := that.NodeDiffs[i]
		if !ok {
			return false
		}
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &NetworkNodeDiff{}
			}
			if q == nil {
				q = &NetworkNodeDiff{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SimulateNetworkGraphResponse) EqualVT(that *SimulateNetworkGraphResponse) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if !this.SimulatedGraph.EqualVT(that.SimulatedGraph) {
		return false
	}
	if len(this.Policies) != len(that.Policies) {
		return false
	}
	for i, vx := range this.Policies {
		vy := that.Policies[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &NetworkPolicyInSimulation{}
			}
			if q == nil {
				q = &NetworkPolicyInSimulation{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if !this.Added.EqualVT(that.Added) {
		return false
	}
	if !this.Removed.EqualVT(that.Removed) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetNetworkGraphEpochRequest) EqualVT(that *GetNetworkGraphEpochRequest) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.ClusterId != that.ClusterId {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *NetworkGraphEpoch) EqualVT(that *NetworkGraphEpoch) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.Epoch != that.Epoch {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GenerateNetworkPoliciesRequest) EqualVT(that *GenerateNetworkPoliciesRequest) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.ClusterId != that.ClusterId {
		return false
	}
	if this.Query != that.Query {
		return false
	}
	if this.DeleteExisting != that.DeleteExisting {
		return false
	}
	if equal, ok := interface{}(this.NetworkDataSince).(interface {
		EqualVT(*timestamppb.Timestamp) bool
	}); ok {
		if !equal.EqualVT(that.NetworkDataSince) {
			return false
		}
	} else if !proto.Equal(this.NetworkDataSince, that.NetworkDataSince) {
		return false
	}
	if this.IncludePorts != that.IncludePorts {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GenerateNetworkPoliciesResponse) EqualVT(that *GenerateNetworkPoliciesResponse) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if equal, ok := interface{}(this.Modification).(interface {
		EqualVT(*storage.NetworkPolicyModification) bool
	}); ok {
		if !equal.EqualVT(that.Modification) {
			return false
		}
	} else if !proto.Equal(this.Modification, that.Modification) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetBaselineGeneratedPolicyForDeploymentRequest) EqualVT(that *GetBaselineGeneratedPolicyForDeploymentRequest) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.DeploymentId != that.DeploymentId {
		return false
	}
	if this.DeleteExisting != that.DeleteExisting {
		return false
	}
	if this.IncludePorts != that.IncludePorts {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetBaselineGeneratedPolicyForDeploymentResponse) EqualVT(that *GetBaselineGeneratedPolicyForDeploymentResponse) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if equal, ok := interface{}(this.Modification).(interface {
		EqualVT(*storage.NetworkPolicyModification) bool
	}); ok {
		if !equal.EqualVT(that.Modification) {
			return false
		}
	} else if !proto.Equal(this.Modification, that.Modification) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetAllowedPeersFromCurrentPolicyForDeploymentResponse) EqualVT(that *GetAllowedPeersFromCurrentPolicyForDeploymentResponse) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.AllowedPeers) != len(that.AllowedPeers) {
		return false
	}
	for i, vx := range this.AllowedPeers {
		vy := that.AllowedPeers[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &NetworkBaselineStatusPeer{}
			}
			if q == nil {
				q = &NetworkBaselineStatusPeer{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ApplyNetworkPolicyYamlForDeploymentRequest) EqualVT(that *ApplyNetworkPolicyYamlForDeploymentRequest) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.DeploymentId != that.DeploymentId {
		return false
	}
	if equal, ok := interface{}(this.Modification).(interface {
		EqualVT(*storage.NetworkPolicyModification) bool
	}); ok {
		if !equal.EqualVT(that.Modification) {
			return false
		}
	} else if !proto.Equal(this.Modification, that.Modification) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetUndoModificationForDeploymentResponse) EqualVT(that *GetUndoModificationForDeploymentResponse) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if equal, ok := interface{}(this.UndoRecord).(interface {
		EqualVT(*storage.NetworkPolicyApplicationUndoRecord) bool
	}); ok {
		if !equal.EqualVT(that.UndoRecord) {
			return false
		}
	} else if !proto.Equal(this.UndoRecord, that.UndoRecord) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetDiffFlowsReconciledFlow) EqualVT(that *GetDiffFlowsReconciledFlow) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if equal, ok := interface{}(this.Entity).(interface {
		EqualVT(*storage.NetworkEntityInfo) bool
	}); ok {
		if !equal.EqualVT(that.Entity) {
			return false
		}
	} else if !proto.Equal(this.Entity, that.Entity) {
		return false
	}
	if len(this.Added) != len(that.Added) {
		return false
	}
	for i, vx := range this.Added {
		vy := that.Added[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &storage.NetworkBaselineConnectionProperties{}
			}
			if q == nil {
				q = &storage.NetworkBaselineConnectionProperties{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*storage.NetworkBaselineConnectionProperties) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.Removed) != len(that.Removed) {
		return false
	}
	for i, vx := range this.Removed {
		vy := that.Removed[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &storage.NetworkBaselineConnectionProperties{}
			}
			if q == nil {
				q = &storage.NetworkBaselineConnectionProperties{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*storage.NetworkBaselineConnectionProperties) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	if len(this.Unchanged) != len(that.Unchanged) {
		return false
	}
	for i, vx := range this.Unchanged {
		vy := that.Unchanged[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &storage.NetworkBaselineConnectionProperties{}
			}
			if q == nil {
				q = &storage.NetworkBaselineConnectionProperties{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*storage.NetworkBaselineConnectionProperties) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetDiffFlowsGroupedFlow) EqualVT(that *GetDiffFlowsGroupedFlow) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if equal, ok := interface{}(this.Entity).(interface {
		EqualVT(*storage.NetworkEntityInfo) bool
	}); ok {
		if !equal.EqualVT(that.Entity) {
			return false
		}
	} else if !proto.Equal(this.Entity, that.Entity) {
		return false
	}
	if len(this.Properties) != len(that.Properties) {
		return false
	}
	for i, vx := range this.Properties {
		vy := that.Properties[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &storage.NetworkBaselineConnectionProperties{}
			}
			if q == nil {
				q = &storage.NetworkBaselineConnectionProperties{}
			}
			if equal, ok := interface{}(p).(interface {
				EqualVT(*storage.NetworkBaselineConnectionProperties) bool
			}); ok {
				if !equal.EqualVT(q) {
					return false
				}
			} else if !proto.Equal(p, q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GetDiffFlowsResponse) EqualVT(that *GetDiffFlowsResponse) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.Added) != len(that.Added) {
		return false
	}
	for i, vx := range this.Added {
		vy := that.Added[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &GetDiffFlowsGroupedFlow{}
			}
			if q == nil {
				q = &GetDiffFlowsGroupedFlow{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.Removed) != len(that.Removed) {
		return false
	}
	for i, vx := range this.Removed {
		vy := that.Removed[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &GetDiffFlowsGroupedFlow{}
			}
			if q == nil {
				q = &GetDiffFlowsGroupedFlow{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.Reconciled) != len(that.Reconciled) {
		return false
	}
	for i, vx := range this.Reconciled {
		vy := that.Reconciled[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &GetDiffFlowsReconciledFlow{}
			}
			if q == nil {
				q = &GetDiffFlowsReconciledFlow{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NetworkPolicyServiceClient is the client API for NetworkPolicyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetworkPolicyServiceClient interface {
	GetNetworkPolicy(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*storage.NetworkPolicy, error)
	GetNetworkPolicies(ctx context.Context, in *GetNetworkPoliciesRequest, opts ...grpc.CallOption) (*NetworkPoliciesResponse, error)
	GetNetworkGraph(ctx context.Context, in *GetNetworkGraphRequest, opts ...grpc.CallOption) (*NetworkGraph, error)
	GetNetworkGraphEpoch(ctx context.Context, in *GetNetworkGraphEpochRequest, opts ...grpc.CallOption) (*NetworkGraphEpoch, error)
	ApplyNetworkPolicy(ctx context.Context, in *ApplyNetworkPolicyYamlRequest, opts ...grpc.CallOption) (*Empty, error)
	GetUndoModification(ctx context.Context, in *GetUndoModificationRequest, opts ...grpc.CallOption) (*GetUndoModificationResponse, error)
	SimulateNetworkGraph(ctx context.Context, in *SimulateNetworkGraphRequest, opts ...grpc.CallOption) (*SimulateNetworkGraphResponse, error)
	SendNetworkPolicyYAML(ctx context.Context, in *SendNetworkPolicyYamlRequest, opts ...grpc.CallOption) (*Empty, error)
	GenerateNetworkPolicies(ctx context.Context, in *GenerateNetworkPoliciesRequest, opts ...grpc.CallOption) (*GenerateNetworkPoliciesResponse, error)
	GetBaselineGeneratedNetworkPolicyForDeployment(ctx context.Context, in *GetBaselineGeneratedPolicyForDeploymentRequest, opts ...grpc.CallOption) (*GetBaselineGeneratedPolicyForDeploymentResponse, error)
	GetAllowedPeersFromCurrentPolicyForDeployment(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*GetAllowedPeersFromCurrentPolicyForDeploymentResponse, error)
	ApplyNetworkPolicyYamlForDeployment(ctx context.Context, in *ApplyNetworkPolicyYamlForDeploymentRequest, opts ...grpc.CallOption) (*Empty, error)
	GetUndoModificationForDeployment(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*GetUndoModificationForDeploymentResponse, error)
	GetDiffFlowsBetweenPolicyAndBaselineForDeployment(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*GetDiffFlowsResponse, error)
	GetDiffFlowsFromUndoModificationForDeployment(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*GetDiffFlowsResponse, error)
}

type networkPolicyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkPolicyServiceClient(cc grpc.ClientConnInterface) NetworkPolicyServiceClient {
	return &networkPolicyServiceClient{cc}
}

func (c *networkPolicyServiceClient) GetNetworkPolicy(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*storage.NetworkPolicy, error) {
	out := new(storage.NetworkPolicy)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/GetNetworkPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) GetNetworkPolicies(ctx context.Context, in *GetNetworkPoliciesRequest, opts ...grpc.CallOption) (*NetworkPoliciesResponse, error) {
	out := new(NetworkPoliciesResponse)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/GetNetworkPolicies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) GetNetworkGraph(ctx context.Context, in *GetNetworkGraphRequest, opts ...grpc.CallOption) (*NetworkGraph, error) {
	out := new(NetworkGraph)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/GetNetworkGraph", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) GetNetworkGraphEpoch(ctx context.Context, in *GetNetworkGraphEpochRequest, opts ...grpc.CallOption) (*NetworkGraphEpoch, error) {
	out := new(NetworkGraphEpoch)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/GetNetworkGraphEpoch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) ApplyNetworkPolicy(ctx context.Context, in *ApplyNetworkPolicyYamlRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/ApplyNetworkPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) GetUndoModification(ctx context.Context, in *GetUndoModificationRequest, opts ...grpc.CallOption) (*GetUndoModificationResponse, error) {
	out := new(GetUndoModificationResponse)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/GetUndoModification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) SimulateNetworkGraph(ctx context.Context, in *SimulateNetworkGraphRequest, opts ...grpc.CallOption) (*SimulateNetworkGraphResponse, error) {
	out := new(SimulateNetworkGraphResponse)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/SimulateNetworkGraph", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) SendNetworkPolicyYAML(ctx context.Context, in *SendNetworkPolicyYamlRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/SendNetworkPolicyYAML", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) GenerateNetworkPolicies(ctx context.Context, in *GenerateNetworkPoliciesRequest, opts ...grpc.CallOption) (*GenerateNetworkPoliciesResponse, error) {
	out := new(GenerateNetworkPoliciesResponse)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/GenerateNetworkPolicies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) GetBaselineGeneratedNetworkPolicyForDeployment(ctx context.Context, in *GetBaselineGeneratedPolicyForDeploymentRequest, opts ...grpc.CallOption) (*GetBaselineGeneratedPolicyForDeploymentResponse, error) {
	out := new(GetBaselineGeneratedPolicyForDeploymentResponse)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/GetBaselineGeneratedNetworkPolicyForDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) GetAllowedPeersFromCurrentPolicyForDeployment(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*GetAllowedPeersFromCurrentPolicyForDeploymentResponse, error) {
	out := new(GetAllowedPeersFromCurrentPolicyForDeploymentResponse)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/GetAllowedPeersFromCurrentPolicyForDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) ApplyNetworkPolicyYamlForDeployment(ctx context.Context, in *ApplyNetworkPolicyYamlForDeploymentRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/ApplyNetworkPolicyYamlForDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) GetUndoModificationForDeployment(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*GetUndoModificationForDeploymentResponse, error) {
	out := new(GetUndoModificationForDeploymentResponse)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/GetUndoModificationForDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) GetDiffFlowsBetweenPolicyAndBaselineForDeployment(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*GetDiffFlowsResponse, error) {
	out := new(GetDiffFlowsResponse)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/GetDiffFlowsBetweenPolicyAndBaselineForDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkPolicyServiceClient) GetDiffFlowsFromUndoModificationForDeployment(ctx context.Context, in *ResourceByID, opts ...grpc.CallOption) (*GetDiffFlowsResponse, error) {
	out := new(GetDiffFlowsResponse)
	err := c.cc.Invoke(ctx, "/v1.NetworkPolicyService/GetDiffFlowsFromUndoModificationForDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkPolicyServiceServer is the server API for NetworkPolicyService service.
// All implementations must embed UnimplementedNetworkPolicyServiceServer
// for forward compatibility
type NetworkPolicyServiceServer interface {
	GetNetworkPolicy(context.Context, *ResourceByID) (*storage.NetworkPolicy, error)
	GetNetworkPolicies(context.Context, *GetNetworkPoliciesRequest) (*NetworkPoliciesResponse, error)
	GetNetworkGraph(context.Context, *GetNetworkGraphRequest) (*NetworkGraph, error)
	GetNetworkGraphEpoch(context.Context, *GetNetworkGraphEpochRequest) (*NetworkGraphEpoch, error)
	ApplyNetworkPolicy(context.Context, *ApplyNetworkPolicyYamlRequest) (*Empty, error)
	GetUndoModification(context.Context, *GetUndoModificationRequest) (*GetUndoModificationResponse, error)
	SimulateNetworkGraph(context.Context, *SimulateNetworkGraphRequest) (*SimulateNetworkGraphResponse, error)
	SendNetworkPolicyYAML(context.Context, *SendNetworkPolicyYamlRequest) (*Empty, error)
	GenerateNetworkPolicies(context.Context, *GenerateNetworkPoliciesRequest) (*GenerateNetworkPoliciesResponse, error)
	GetBaselineGeneratedNetworkPolicyForDeployment(context.Context, *GetBaselineGeneratedPolicyForDeploymentRequest) (*GetBaselineGeneratedPolicyForDeploymentResponse, error)
	GetAllowedPeersFromCurrentPolicyForDeployment(context.Context, *ResourceByID) (*GetAllowedPeersFromCurrentPolicyForDeploymentResponse, error)
	ApplyNetworkPolicyYamlForDeployment(context.Context, *ApplyNetworkPolicyYamlForDeploymentRequest) (*Empty, error)
	GetUndoModificationForDeployment(context.Context, *ResourceByID) (*GetUndoModificationForDeploymentResponse, error)
	GetDiffFlowsBetweenPolicyAndBaselineForDeployment(context.Context, *ResourceByID) (*GetDiffFlowsResponse, error)
	GetDiffFlowsFromUndoModificationForDeployment(context.Context, *ResourceByID) (*GetDiffFlowsResponse, error)
	mustEmbedUnimplementedNetworkPolicyServiceServer()
}

// UnimplementedNetworkPolicyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNetworkPolicyServiceServer struct {
}

func (UnimplementedNetworkPolicyServiceServer) GetNetworkPolicy(context.Context, *ResourceByID) (*storage.NetworkPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkPolicy not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) GetNetworkPolicies(context.Context, *GetNetworkPoliciesRequest) (*NetworkPoliciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkPolicies not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) GetNetworkGraph(context.Context, *GetNetworkGraphRequest) (*NetworkGraph, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkGraph not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) GetNetworkGraphEpoch(context.Context, *GetNetworkGraphEpochRequest) (*NetworkGraphEpoch, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkGraphEpoch not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) ApplyNetworkPolicy(context.Context, *ApplyNetworkPolicyYamlRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyNetworkPolicy not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) GetUndoModification(context.Context, *GetUndoModificationRequest) (*GetUndoModificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUndoModification not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) SimulateNetworkGraph(context.Context, *SimulateNetworkGraphRequest) (*SimulateNetworkGraphResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimulateNetworkGraph not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) SendNetworkPolicyYAML(context.Context, *SendNetworkPolicyYamlRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendNetworkPolicyYAML not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) GenerateNetworkPolicies(context.Context, *GenerateNetworkPoliciesRequest) (*GenerateNetworkPoliciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateNetworkPolicies not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) GetBaselineGeneratedNetworkPolicyForDeployment(context.Context, *GetBaselineGeneratedPolicyForDeploymentRequest) (*GetBaselineGeneratedPolicyForDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBaselineGeneratedNetworkPolicyForDeployment not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) GetAllowedPeersFromCurrentPolicyForDeployment(context.Context, *ResourceByID) (*GetAllowedPeersFromCurrentPolicyForDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllowedPeersFromCurrentPolicyForDeployment not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) ApplyNetworkPolicyYamlForDeployment(context.Context, *ApplyNetworkPolicyYamlForDeploymentRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyNetworkPolicyYamlForDeployment not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) GetUndoModificationForDeployment(context.Context, *ResourceByID) (*GetUndoModificationForDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUndoModificationForDeployment not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) GetDiffFlowsBetweenPolicyAndBaselineForDeployment(context.Context, *ResourceByID) (*GetDiffFlowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDiffFlowsBetweenPolicyAndBaselineForDeployment not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) GetDiffFlowsFromUndoModificationForDeployment(context.Context, *ResourceByID) (*GetDiffFlowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDiffFlowsFromUndoModificationForDeployment not implemented")
}
func (UnimplementedNetworkPolicyServiceServer) mustEmbedUnimplementedNetworkPolicyServiceServer() {}

// UnsafeNetworkPolicyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkPolicyServiceServer will
// result in compilation errors.
type UnsafeNetworkPolicyServiceServer interface {
	mustEmbedUnimplementedNetworkPolicyServiceServer()
}

func RegisterNetworkPolicyServiceServer(s grpc.ServiceRegistrar, srv NetworkPolicyServiceServer) {
	s.RegisterService(&NetworkPolicyService_ServiceDesc, srv)
}

func _NetworkPolicyService_GetNetworkPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).GetNetworkPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/GetNetworkPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).GetNetworkPolicy(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_GetNetworkPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).GetNetworkPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/GetNetworkPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).GetNetworkPolicies(ctx, req.(*GetNetworkPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_GetNetworkGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).GetNetworkGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/GetNetworkGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).GetNetworkGraph(ctx, req.(*GetNetworkGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_GetNetworkGraphEpoch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkGraphEpochRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).GetNetworkGraphEpoch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/GetNetworkGraphEpoch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).GetNetworkGraphEpoch(ctx, req.(*GetNetworkGraphEpochRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_ApplyNetworkPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyNetworkPolicyYamlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).ApplyNetworkPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/ApplyNetworkPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).ApplyNetworkPolicy(ctx, req.(*ApplyNetworkPolicyYamlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_GetUndoModification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUndoModificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).GetUndoModification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/GetUndoModification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).GetUndoModification(ctx, req.(*GetUndoModificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_SimulateNetworkGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimulateNetworkGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).SimulateNetworkGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/SimulateNetworkGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).SimulateNetworkGraph(ctx, req.(*SimulateNetworkGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_SendNetworkPolicyYAML_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendNetworkPolicyYamlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).SendNetworkPolicyYAML(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/SendNetworkPolicyYAML",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).SendNetworkPolicyYAML(ctx, req.(*SendNetworkPolicyYamlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_GenerateNetworkPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateNetworkPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).GenerateNetworkPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/GenerateNetworkPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).GenerateNetworkPolicies(ctx, req.(*GenerateNetworkPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_GetBaselineGeneratedNetworkPolicyForDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBaselineGeneratedPolicyForDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).GetBaselineGeneratedNetworkPolicyForDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/GetBaselineGeneratedNetworkPolicyForDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).GetBaselineGeneratedNetworkPolicyForDeployment(ctx, req.(*GetBaselineGeneratedPolicyForDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_GetAllowedPeersFromCurrentPolicyForDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).GetAllowedPeersFromCurrentPolicyForDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/GetAllowedPeersFromCurrentPolicyForDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).GetAllowedPeersFromCurrentPolicyForDeployment(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_ApplyNetworkPolicyYamlForDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyNetworkPolicyYamlForDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).ApplyNetworkPolicyYamlForDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/ApplyNetworkPolicyYamlForDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).ApplyNetworkPolicyYamlForDeployment(ctx, req.(*ApplyNetworkPolicyYamlForDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_GetUndoModificationForDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).GetUndoModificationForDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/GetUndoModificationForDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).GetUndoModificationForDeployment(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_GetDiffFlowsBetweenPolicyAndBaselineForDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).GetDiffFlowsBetweenPolicyAndBaselineForDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/GetDiffFlowsBetweenPolicyAndBaselineForDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).GetDiffFlowsBetweenPolicyAndBaselineForDeployment(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkPolicyService_GetDiffFlowsFromUndoModificationForDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceByID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkPolicyServiceServer).GetDiffFlowsFromUndoModificationForDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.NetworkPolicyService/GetDiffFlowsFromUndoModificationForDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkPolicyServiceServer).GetDiffFlowsFromUndoModificationForDeployment(ctx, req.(*ResourceByID))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkPolicyService_ServiceDesc is the grpc.ServiceDesc for NetworkPolicyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkPolicyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.NetworkPolicyService",
	HandlerType: (*NetworkPolicyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNetworkPolicy",
			Handler:    _NetworkPolicyService_GetNetworkPolicy_Handler,
		},
		{
			MethodName: "GetNetworkPolicies",
			Handler:    _NetworkPolicyService_GetNetworkPolicies_Handler,
		},
		{
			MethodName: "GetNetworkGraph",
			Handler:    _NetworkPolicyService_GetNetworkGraph_Handler,
		},
		{
			MethodName: "GetNetworkGraphEpoch",
			Handler:    _NetworkPolicyService_GetNetworkGraphEpoch_Handler,
		},
		{
			MethodName: "ApplyNetworkPolicy",
			Handler:    _NetworkPolicyService_ApplyNetworkPolicy_Handler,
		},
		{
			MethodName: "GetUndoModification",
			Handler:    _NetworkPolicyService_GetUndoModification_Handler,
		},
		{
			MethodName: "SimulateNetworkGraph",
			Handler:    _NetworkPolicyService_SimulateNetworkGraph_Handler,
		},
		{
			MethodName: "SendNetworkPolicyYAML",
			Handler:    _NetworkPolicyService_SendNetworkPolicyYAML_Handler,
		},
		{
			MethodName: "GenerateNetworkPolicies",
			Handler:    _NetworkPolicyService_GenerateNetworkPolicies_Handler,
		},
		{
			MethodName: "GetBaselineGeneratedNetworkPolicyForDeployment",
			Handler:    _NetworkPolicyService_GetBaselineGeneratedNetworkPolicyForDeployment_Handler,
		},
		{
			MethodName: "GetAllowedPeersFromCurrentPolicyForDeployment",
			Handler:    _NetworkPolicyService_GetAllowedPeersFromCurrentPolicyForDeployment_Handler,
		},
		{
			MethodName: "ApplyNetworkPolicyYamlForDeployment",
			Handler:    _NetworkPolicyService_ApplyNetworkPolicyYamlForDeployment_Handler,
		},
		{
			MethodName: "GetUndoModificationForDeployment",
			Handler:    _NetworkPolicyService_GetUndoModificationForDeployment_Handler,
		},
		{
			MethodName: "GetDiffFlowsBetweenPolicyAndBaselineForDeployment",
			Handler:    _NetworkPolicyService_GetDiffFlowsBetweenPolicyAndBaselineForDeployment_Handler,
		},
		{
			MethodName: "GetDiffFlowsFromUndoModificationForDeployment",
			Handler:    _NetworkPolicyService_GetDiffFlowsFromUndoModificationForDeployment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/network_policy_service.proto",
}

func (m *GetNetworkPoliciesRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNetworkPoliciesRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetNetworkPoliciesRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarint(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeploymentQuery) > 0 {
		i -= len(m.DeploymentQuery)
		copy(dAtA[i:], m.DeploymentQuery)
		i = encodeVarint(dAtA, i, uint64(len(m.DeploymentQuery)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarint(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkPoliciesResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPoliciesResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *NetworkPoliciesResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NetworkPolicies) > 0 {
		for iNdEx := len(m.NetworkPolicies) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.NetworkPolicies[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.NetworkPolicies[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SendNetworkPolicyYamlRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendNetworkPolicyYamlRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SendNetworkPolicyYamlRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Modification != nil {
		if vtmsg, ok := interface{}(m.Modification).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.Modification)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NotifierIds) > 0 {
		for iNdEx := len(m.NotifierIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NotifierIds[iNdEx])
			copy(dAtA[i:], m.NotifierIds[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.NotifierIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarint(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetNetworkGraphRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNetworkGraphRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetNetworkGraphRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Scope != nil {
		size, err := m.Scope.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if m.IncludePorts {
		i--
		if m.IncludePorts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarint(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarint(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SimulateNetworkGraphRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateNetworkGraphRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SimulateNetworkGraphRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Scope != nil {
		size, err := m.Scope.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	}
	if m.IncludeNodeDiff {
		i--
		if m.IncludeNodeDiff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IncludePorts {
		i--
		if m.IncludePorts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Modification != nil {
		if vtmsg, ok := interface{}(m.Modification).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.Modification)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarint(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarint(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ApplyNetworkPolicyYamlRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyNetworkPolicyYamlRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ApplyNetworkPolicyYamlRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Modification != nil {
		if vtmsg, ok := interface{}(m.Modification).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.Modification)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarint(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUndoModificationRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUndoModificationRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetUndoModificationRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarint(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUndoModificationResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUndoModificationResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetUndoModificationResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.UndoRecord != nil {
		if vtmsg, ok := interface{}(m.UndoRecord).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.UndoRecord)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkPolicyInSimulation) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkPolicyInSimulation) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *NetworkPolicyInSimulation) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.OldPolicy != nil {
		if vtmsg, ok := interface{}(m.OldPolicy).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.OldPolicy)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Policy != nil {
		if vtmsg, ok := interface{}(m.Policy).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.Policy)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkNodeDiff) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkNodeDiff) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *NetworkNodeDiff) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.OutEdges) > 0 {
		for k := range m.OutEdges {
			v := m.OutEdges[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.NonIsolatedEgress {
		i--
		if m.NonIsolatedEgress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.NonIsolatedIngress {
		i--
		if m.NonIsolatedIngress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.DEPRECATEDOutEdges) > 0 {
		for k := range m.DEPRECATEDOutEdges {
			v := m.DEPRECATEDOutEdges[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PolicyIds) > 0 {
		for iNdEx := len(m.PolicyIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PolicyIds[iNdEx])
			copy(dAtA[i:], m.PolicyIds[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.PolicyIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkGraphDiff) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkGraphDiff) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *NetworkGraphDiff) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NodeDiffs) > 0 {
		for k := range m.NodeDiffs {
			v := m.NodeDiffs[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DEPRECATEDNodeDiffs) > 0 {
		for k := range m.DEPRECATEDNodeDiffs {
			v := m.DEPRECATEDNodeDiffs[k]
			baseI := i
			size, err := v.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i = encodeVarint(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SimulateNetworkGraphResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulateNetworkGraphResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SimulateNetworkGraphResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Removed != nil {
		size, err := m.Removed.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if m.Added != nil {
		size, err := m.Added.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Policies) > 0 {
		for iNdEx := len(m.Policies) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Policies[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.SimulatedGraph != nil {
		size, err := m.SimulatedGraph.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetNetworkGraphEpochRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNetworkGraphEpochRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetNetworkGraphEpochRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarint(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkGraphEpoch) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkGraphEpoch) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *NetworkGraphEpoch) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Epoch != 0 {
		i = encodeVarint(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GenerateNetworkPoliciesRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateNetworkPoliciesRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GenerateNetworkPoliciesRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IncludePorts {
		i--
		if m.IncludePorts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.NetworkDataSince != nil {
		if vtmsg, ok := interface{}(m.NetworkDataSince).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.NetworkDataSince)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DeleteExisting != 0 {
		i = encodeVarint(dAtA, i, uint64(m.DeleteExisting))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarint(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarint(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenerateNetworkPoliciesResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateNetworkPoliciesResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GenerateNetworkPoliciesResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Modification != nil {
		if vtmsg, ok := interface{}(m.Modification).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.Modification)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBaselineGeneratedPolicyForDeploymentRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBaselineGeneratedPolicyForDeploymentRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetBaselineGeneratedPolicyForDeploymentRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IncludePorts {
		i--
		if m.IncludePorts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.DeleteExisting != 0 {
		i = encodeVarint(dAtA, i, uint64(m.DeleteExisting))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarint(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBaselineGeneratedPolicyForDeploymentResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBaselineGeneratedPolicyForDeploymentResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetBaselineGeneratedPolicyForDeploymentResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Modification != nil {
		if vtmsg, ok := interface{}(m.Modification).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.Modification)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAllowedPeersFromCurrentPolicyForDeploymentResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAllowedPeersFromCurrentPolicyForDeploymentResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetAllowedPeersFromCurrentPolicyForDeploymentResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.AllowedPeers) > 0 {
		for iNdEx := len(m.AllowedPeers) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.AllowedPeers[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ApplyNetworkPolicyYamlForDeploymentRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyNetworkPolicyYamlForDeploymentRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ApplyNetworkPolicyYamlForDeploymentRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Modification != nil {
		if vtmsg, ok := interface{}(m.Modification).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.Modification)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarint(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUndoModificationForDeploymentResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUndoModificationForDeploymentResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetUndoModificationForDeploymentResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.UndoRecord != nil {
		if vtmsg, ok := interface{}(m.UndoRecord).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.UndoRecord)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetDiffFlowsReconciledFlow) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDiffFlowsReconciledFlow) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetDiffFlowsReconciledFlow) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Unchanged) > 0 {
		for iNdEx := len(m.Unchanged) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.Unchanged[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.Unchanged[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Removed) > 0 {
		for iNdEx := len(m.Removed) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.Removed[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.Removed[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Added) > 0 {
		for iNdEx := len(m.Added) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.Added[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.Added[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Entity != nil {
		if vtmsg, ok := interface{}(m.Entity).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.Entity)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetDiffFlowsGroupedFlow) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDiffFlowsGroupedFlow) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetDiffFlowsGroupedFlow) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Properties) > 0 {
		for iNdEx := len(m.Properties) - 1; iNdEx >= 0; iNdEx-- {
			if vtmsg, ok := interface{}(m.Properties[iNdEx]).(interface {
				MarshalToSizedBufferVT([]byte) (int, error)
			}); ok {
				size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarint(dAtA, i, uint64(size))
			} else {
				encoded, err := proto.Marshal(m.Properties[iNdEx])
				if err != nil {
					return 0, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = encodeVarint(dAtA, i, uint64(len(encoded)))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Entity != nil {
		if vtmsg, ok := interface{}(m.Entity).(interface {
			MarshalToSizedBufferVT([]byte) (int, error)
		}); ok {
			size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
		} else {
			encoded, err := proto.Marshal(m.Entity)
			if err != nil {
				return 0, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = encodeVarint(dAtA, i, uint64(len(encoded)))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetDiffFlowsResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDiffFlowsResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GetDiffFlowsResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Reconciled) > 0 {
		for iNdEx := len(m.Reconciled) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Reconciled[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Removed) > 0 {
		for iNdEx := len(m.Removed) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Removed[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Added) > 0 {
		for iNdEx := len(m.Added) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Added[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetNetworkPoliciesRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.DeploymentQuery)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *NetworkPoliciesResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NetworkPolicies) > 0 {
		for _, e := range m.NetworkPolicies {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *SendNetworkPolicyYamlRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if len(m.NotifierIds) > 0 {
		for _, s := range m.NotifierIds {
			l = len(s)
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.Modification != nil {
		if size, ok := interface{}(m.Modification).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.Modification)
		}
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetNetworkGraphRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.IncludePorts {
		n += 2
	}
	if m.Scope != nil {
		l = m.Scope.SizeVT()
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *SimulateNetworkGraphRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.Modification != nil {
		if size, ok := interface{}(m.Modification).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.Modification)
		}
		n += 1 + l + sov(uint64(l))
	}
	if m.IncludePorts {
		n += 2
	}
	if m.IncludeNodeDiff {
		n += 2
	}
	if m.Scope != nil {
		l = m.Scope.SizeVT()
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ApplyNetworkPolicyYamlRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.Modification != nil {
		if size, ok := interface{}(m.Modification).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.Modification)
		}
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetUndoModificationRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetUndoModificationResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndoRecord != nil {
		if size, ok := interface{}(m.UndoRecord).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.UndoRecord)
		}
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *NetworkPolicyInSimulation) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != nil {
		if size, ok := interface{}(m.Policy).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.Policy)
		}
		n += 1 + l + sov(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sov(uint64(m.Status))
	}
	if m.OldPolicy != nil {
		if size, ok := interface{}(m.OldPolicy).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.OldPolicy)
		}
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *NetworkNodeDiff) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PolicyIds) > 0 {
		for _, s := range m.PolicyIds {
			l = len(s)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.DEPRECATEDOutEdges) > 0 {
		for k, v := range m.DEPRECATEDOutEdges {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + sov(uint64(k)) + l
			n += mapEntrySize + 1 + sov(uint64(mapEntrySize))
		}
	}
	if m.NonIsolatedIngress {
		n += 2
	}
	if m.NonIsolatedEgress {
		n += 2
	}
	if len(m.OutEdges) > 0 {
		for k, v := range m.OutEdges {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 1 + sov(uint64(mapEntrySize))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *NetworkGraphDiff) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DEPRECATEDNodeDiffs) > 0 {
		for k, v := range m.DEPRECATEDNodeDiffs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + sov(uint64(k)) + l
			n += mapEntrySize + 1 + sov(uint64(mapEntrySize))
		}
	}
	if len(m.NodeDiffs) > 0 {
		for k, v := range m.NodeDiffs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.SizeVT()
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 1 + sov(uint64(mapEntrySize))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *SimulateNetworkGraphResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SimulatedGraph != nil {
		l = m.SimulatedGraph.SizeVT()
		n += 1 + l + sov(uint64(l))
	}
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.SizeVT()
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.Added != nil {
		l = m.Added.SizeVT()
		n += 1 + l + sov(uint64(l))
	}
	if m.Removed != nil {
		l = m.Removed.SizeVT()
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetNetworkGraphEpochRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *NetworkGraphEpoch) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sov(uint64(m.Epoch))
	}
	n += len(m.unknownFields)
	return n
}

func (m *GenerateNetworkPoliciesRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.DeleteExisting != 0 {
		n += 1 + sov(uint64(m.DeleteExisting))
	}
	if m.NetworkDataSince != nil {
		if size, ok := interface{}(m.NetworkDataSince).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.NetworkDataSince)
		}
		n += 1 + l + sov(uint64(l))
	}
	if m.IncludePorts {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *GenerateNetworkPoliciesResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Modification != nil {
		if size, ok := interface{}(m.Modification).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.Modification)
		}
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetBaselineGeneratedPolicyForDeploymentRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.DeleteExisting != 0 {
		n += 1 + sov(uint64(m.DeleteExisting))
	}
	if m.IncludePorts {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetBaselineGeneratedPolicyForDeploymentResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Modification != nil {
		if size, ok := interface{}(m.Modification).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.Modification)
		}
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetAllowedPeersFromCurrentPolicyForDeploymentResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllowedPeers) > 0 {
		for _, e := range m.AllowedPeers {
			l = e.SizeVT()
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *ApplyNetworkPolicyYamlForDeploymentRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sov(uint64(l))
	}
	if m.Modification != nil {
		if size, ok := interface{}(m.Modification).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.Modification)
		}
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetUndoModificationForDeploymentResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndoRecord != nil {
		if size, ok := interface{}(m.UndoRecord).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.UndoRecord)
		}
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetDiffFlowsReconciledFlow) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entity != nil {
		if size, ok := interface{}(m.Entity).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.Entity)
		}
		n += 1 + l + sov(uint64(l))
	}
	if len(m.Added) > 0 {
		for _, e := range m.Added {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.Removed) > 0 {
		for _, e := range m.Removed {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.Unchanged) > 0 {
		for _, e := range m.Unchanged {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetDiffFlowsGroupedFlow) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Entity != nil {
		if size, ok := interface{}(m.Entity).(interface {
			SizeVT() int
		}); ok {
			l = size.SizeVT()
		} else {
			l = proto.Size(m.Entity)
		}
		n += 1 + l + sov(uint64(l))
	}
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			if size, ok := interface{}(e).(interface {
				SizeVT() int
			}); ok {
				l = size.SizeVT()
			} else {
				l = proto.Size(e)
			}
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetDiffFlowsResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Added) > 0 {
		for _, e := range m.Added {
			l = e.SizeVT()
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.Removed) > 0 {
		for _, e := range m.Removed {
			l = e.SizeVT()
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.Reconciled) > 0 {
		for _, e := range m.Reconciled {
			l = e.SizeVT()
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *GetNetworkPoliciesRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNetworkPoliciesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNetworkPoliciesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentQuery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentQuery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkPoliciesResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPoliciesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPoliciesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPolicies = append(m.NetworkPolicies, &storage.NetworkPolicy{})
			if unmarshal, ok := interface{}(m.NetworkPolicies[len(m.NetworkPolicies)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.NetworkPolicies[len(m.NetworkPolicies)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendNetworkPolicyYamlRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendNetworkPolicyYamlRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendNetworkPolicyYamlRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifierIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotifierIds = append(m.NotifierIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modification == nil {
				m.Modification = &storage.NetworkPolicyModification{}
			}
			if unmarshal, ok := interface{}(m.Modification).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Modification); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNetworkGraphRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNetworkGraphRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNetworkGraphRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludePorts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludePorts = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scope == nil {
				m.Scope = &NetworkGraphScope{}
			}
			if err := m.Scope.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateNetworkGraphRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimulateNetworkGraphRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimulateNetworkGraphRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modification == nil {
				m.Modification = &storage.NetworkPolicyModification{}
			}
			if unmarshal, ok := interface{}(m.Modification).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Modification); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludePorts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludePorts = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeNodeDiff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeNodeDiff = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scope == nil {
				m.Scope = &NetworkGraphScope{}
			}
			if err := m.Scope.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyNetworkPolicyYamlRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyNetworkPolicyYamlRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyNetworkPolicyYamlRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modification == nil {
				m.Modification = &storage.NetworkPolicyModification{}
			}
			if unmarshal, ok := interface{}(m.Modification).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Modification); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUndoModificationRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUndoModificationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUndoModificationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUndoModificationResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUndoModificationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUndoModificationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndoRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UndoRecord == nil {
				m.UndoRecord = &storage.NetworkPolicyApplicationUndoRecord{}
			}
			if unmarshal, ok := interface{}(m.UndoRecord).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.UndoRecord); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkPolicyInSimulation) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkPolicyInSimulation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkPolicyInSimulation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &storage.NetworkPolicy{}
			}
			if unmarshal, ok := interface{}(m.Policy).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Policy); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= NetworkPolicyInSimulation_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldPolicy == nil {
				m.OldPolicy = &storage.NetworkPolicy{}
			}
			if unmarshal, ok := interface{}(m.OldPolicy).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.OldPolicy); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkNodeDiff) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkNodeDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkNodeDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyIds = append(m.PolicyIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDOutEdges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DEPRECATEDOutEdges == nil {
				m.DEPRECATEDOutEdges = make(map[int32]*NetworkEdgePropertiesBundle)
			}
			var mapkey int32
			var mapvalue *NetworkEdgePropertiesBundle
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NetworkEdgePropertiesBundle{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DEPRECATEDOutEdges[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonIsolatedIngress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NonIsolatedIngress = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonIsolatedEgress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NonIsolatedEgress = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutEdges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutEdges == nil {
				m.OutEdges = make(map[string]*NetworkEdgePropertiesBundle)
			}
			var mapkey string
			var mapvalue *NetworkEdgePropertiesBundle
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NetworkEdgePropertiesBundle{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OutEdges[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkGraphDiff) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkGraphDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkGraphDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDNodeDiffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DEPRECATEDNodeDiffs == nil {
				m.DEPRECATEDNodeDiffs = make(map[int32]*NetworkNodeDiff)
			}
			var mapkey int32
			var mapvalue *NetworkNodeDiff
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NetworkNodeDiff{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DEPRECATEDNodeDiffs[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDiffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeDiffs == nil {
				m.NodeDiffs = make(map[string]*NetworkNodeDiff)
			}
			var mapkey string
			var mapvalue *NetworkNodeDiff
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NetworkNodeDiff{}
					if err := mapvalue.UnmarshalVT(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeDiffs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimulateNetworkGraphResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimulateNetworkGraphResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimulateNetworkGraphResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimulatedGraph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SimulatedGraph == nil {
				m.SimulatedGraph = &NetworkGraph{}
			}
			if err := m.SimulatedGraph.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &NetworkPolicyInSimulation{})
			if err := m.Policies[len(m.Policies)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Added", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Added == nil {
				m.Added = &NetworkGraphDiff{}
			}
			if err := m.Added.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Removed == nil {
				m.Removed = &NetworkGraphDiff{}
			}
			if err := m.Removed.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNetworkGraphEpochRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNetworkGraphEpochRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNetworkGraphEpochRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkGraphEpoch) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkGraphEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkGraphEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateNetworkPoliciesRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateNetworkPoliciesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateNetworkPoliciesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteExisting", wireType)
			}
			m.DeleteExisting = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteExisting |= GenerateNetworkPoliciesRequest_DeleteExistingPoliciesMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkDataSince", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkDataSince == nil {
				m.NetworkDataSince = &timestamppb.Timestamp{}
			}
			if unmarshal, ok := interface{}(m.NetworkDataSince).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.NetworkDataSince); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludePorts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludePorts = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateNetworkPoliciesResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateNetworkPoliciesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateNetworkPoliciesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modification == nil {
				m.Modification = &storage.NetworkPolicyModification{}
			}
			if unmarshal, ok := interface{}(m.Modification).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Modification); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBaselineGeneratedPolicyForDeploymentRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBaselineGeneratedPolicyForDeploymentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBaselineGeneratedPolicyForDeploymentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteExisting", wireType)
			}
			m.DeleteExisting = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteExisting |= GenerateNetworkPoliciesRequest_DeleteExistingPoliciesMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludePorts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludePorts = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBaselineGeneratedPolicyForDeploymentResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBaselineGeneratedPolicyForDeploymentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBaselineGeneratedPolicyForDeploymentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modification == nil {
				m.Modification = &storage.NetworkPolicyModification{}
			}
			if unmarshal, ok := interface{}(m.Modification).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Modification); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAllowedPeersFromCurrentPolicyForDeploymentResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAllowedPeersFromCurrentPolicyForDeploymentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAllowedPeersFromCurrentPolicyForDeploymentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedPeers = append(m.AllowedPeers, &NetworkBaselineStatusPeer{})
			if err := m.AllowedPeers[len(m.AllowedPeers)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyNetworkPolicyYamlForDeploymentRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyNetworkPolicyYamlForDeploymentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyNetworkPolicyYamlForDeploymentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Modification == nil {
				m.Modification = &storage.NetworkPolicyModification{}
			}
			if unmarshal, ok := interface{}(m.Modification).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Modification); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUndoModificationForDeploymentResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUndoModificationForDeploymentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUndoModificationForDeploymentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndoRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UndoRecord == nil {
				m.UndoRecord = &storage.NetworkPolicyApplicationUndoRecord{}
			}
			if unmarshal, ok := interface{}(m.UndoRecord).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.UndoRecord); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDiffFlowsReconciledFlow) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDiffFlowsReconciledFlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDiffFlowsReconciledFlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entity == nil {
				m.Entity = &storage.NetworkEntityInfo{}
			}
			if unmarshal, ok := interface{}(m.Entity).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Entity); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Added", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Added = append(m.Added, &storage.NetworkBaselineConnectionProperties{})
			if unmarshal, ok := interface{}(m.Added[len(m.Added)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Added[len(m.Added)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Removed = append(m.Removed, &storage.NetworkBaselineConnectionProperties{})
			if unmarshal, ok := interface{}(m.Removed[len(m.Removed)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Removed[len(m.Removed)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unchanged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unchanged = append(m.Unchanged, &storage.NetworkBaselineConnectionProperties{})
			if unmarshal, ok := interface{}(m.Unchanged[len(m.Unchanged)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Unchanged[len(m.Unchanged)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDiffFlowsGroupedFlow) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDiffFlowsGroupedFlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDiffFlowsGroupedFlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entity == nil {
				m.Entity = &storage.NetworkEntityInfo{}
			}
			if unmarshal, ok := interface{}(m.Entity).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Entity); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &storage.NetworkBaselineConnectionProperties{})
			if unmarshal, ok := interface{}(m.Properties[len(m.Properties)-1]).(interface {
				UnmarshalVT([]byte) error
			}); ok {
				if err := unmarshal.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				if err := proto.Unmarshal(dAtA[iNdEx:postIndex], m.Properties[len(m.Properties)-1]); err != nil {
					return err
				}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDiffFlowsResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDiffFlowsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDiffFlowsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Added", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Added = append(m.Added, &GetDiffFlowsGroupedFlow{})
			if err := m.Added[len(m.Added)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Removed = append(m.Removed, &GetDiffFlowsGroupedFlow{})
			if err := m.Removed[len(m.Removed)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reconciled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reconciled = append(m.Reconciled, &GetDiffFlowsReconciledFlow{})
			if err := m.Reconciled[len(m.Reconciled)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
