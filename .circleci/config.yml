defaults: &defaults
  docker:
    - image: docker.io/stackrox/apollo-ci:0.1.11-14-g2811d09a20
      auth:
        username: $DOCKERHUB_USERNAME
        password: $DOCKERHUB_PASSWORD
  working_directory: /go/src/github.com/stackrox/rox

setupBazel: &setupBazel
  run:
    name: Setup Bazel cache access and bazel.rc
    command: |
      echo "$GKE_SERVICE_ACCOUNT" > /tmp/gcp.json
      cp tools/ci-bazel.rc .bazelrc

depCacheKey: &depCacheKey 'v1-rox-go-pkg-dep-{{ checksum "Gopkg.lock" }}'
restoreDep: &restoreDep
  restore_cache:
    keys:
      - *depCacheKey
      - v1-rox-go-pkg-dep

gradleCacheKey: &gradleCacheKey 'v1-rox-gradle-{{ checksum "qa-tests-backend/build.gradle" }}'
restoreGradle: &restoreGradle
  restore_cache:
    keys:
      - *gradleCacheKey
      - v1-rox-gradle

uiCacheKey: &uiCacheKey 'v1-rox-ui-deps-{{ checksum "ui/yarn.lock" }}'
restoreUI: &restoreUI
  restore_cache:
    keys:
      - *uiCacheKey
      - v1-rox-ui-deps

setupGCP: &setupGCP
  run:
    name: Setup deployment env
    command: |
      docker login -u "$DOCKERHUB_USERNAME" -p "$DOCKERHUB_PASSWORD"
      echo 'export REGISTRY_USERNAME="$DOCKERHUB_USERNAME"' >> $BASH_ENV
      echo 'export REGISTRY_PASSWORD="$DOCKERHUB_PASSWORD"' >> $BASH_ENV
      echo 'export MAIN_IMAGE_TAG="$(make tag)"' >> $BASH_ENV
      echo $GKE_SERVICE_ACCOUNT > /tmp/gcp.json
      echo 'export GOOGLE_APPLICATION_CREDENTIALS=/tmp/gcp.json' >> $BASH_ENV
      gcloud auth activate-service-account --key-file /tmp/gcp.json
      gcloud config set project stackrox-ci
      gcloud config set compute/zone us-central1-f

createGKE: &createGKE
  run:
    name: Create GKE cluster
    command: |
      .circleci/create-cluster.sh || (
        echo "Retrying in case this was a transient GCP failure...";
        gcloud container clusters delete "prevent-ci-${CIRCLE_BUILD_NUM}";
        .circleci/create-cluster.sh
      )

# See https://stackoverflow.com/a/46316672 for why we have to use user/pass.
# This step requires the GCP IAM permission "Kubernetes Engine Admin".
deployGKE: &deployGKE
  run:
    name: Deploy to remote cluster
    command: |
      kubectl create clusterrolebinding temporary-admin --clusterrole=cluster-admin --user circleci-gke@ultra-current-825.iam.gserviceaccount.com
      ./deploy/k8s/deploy.sh
      kubectl delete clusterrolebinding temporary-admin

portForwardK8s: &portForwardK8s
  run:
    name: Setup port-forwarding for tests
    command: ./scripts/k8s/local-port-forward.sh
    background: true

waitForAPI: &waitForAPI
  run:
    name: Wait for the API server to be up
    command: |
      export PING_URL="https://127.0.0.1:${LOCAL_PORT}/v1/ping"
      curl -k --connect-timeout 5 --max-time 10 --retry 10 --retry-connrefused --retry-delay 1 --retry-max-time 30 "${PING_URL}"

waitForSensorK8s: &waitForSensorK8s
  run:
    name: Wait for the Sensor to be running K8s
    command: |
      ./scripts/ci/sensor-wait.sh

determineWhetherToRunUIDevServer: &determineWhetherToRunUIDevServer
  run:
    name: Determine whether to run the UI dev server
    command: |
      if .circleci/pr_has_label.sh ci-ui-dev-server; then
        echo "Running UI E2Es against the dev server due to the presence of the ci-ui-dev-server label."
        echo 'export RUN_UI_DEV_SERVER=true' >> "${BASH_ENV}"
      else
        echo "Running UI E2Es against the production server. Apply the ci-ui-dev-server label to your PR to run against the dev server."
        echo 'export RUN_UI_DEV_SERVER=false' >> "${BASH_ENV}"
      fi

runUIDevServer: &runUIDevServer
  run:
    name: Run the UI dev server
    command: |
      if [ "${RUN_UI_DEV_SERVER}" = "true" ]; then
        make -C ui start
      fi
    background: true

waitForUIDevServer: &waitForUIDevServer
  run:
    name: Wait for the UI dev server to be up
    command: |
      if [ "${RUN_UI_DEV_SERVER}" = "true" ]; then
        curl -k --max-time 60 --retry 50 --retry-connrefused --retry-delay 5 --retry-max-time 300 https://127.0.0.1:3000/v1/ping
      else
        echo "Not running the dev server, skipping..."
      fi

runUIE2E: &runUIE2E
  run:
    name: UI e2e tests
    command: |
      if [ "${RUN_UI_DEV_SERVER}" = "true" ]; then
        export UI_BASE_URL="https://localhost:3000"
      else
        export UI_BASE_URL="https://localhost:${LOCAL_PORT}"
      fi
      make -C ui test-e2e-ci

collectImbuedUILogs: &collectImbuedUILogs
  run:
    name: Collect imbued UI logs
    command: |
      mkdir -p /tmp/imbued-ui-logs
      status_code="$(curl -sk -o logs.zip -w "%{http_code}\n" "https://localhost:${LOCAL_PORT}/api/logimbue")"
      # Central returns 204 if there are no imbued logs
      if [ "${status_code}" -eq 204 ]; then
        echo "No imbued logs found."
      elif [ "${status_code}" -eq 200 ]; then
        echo "Logs imbued from the UI were found. Please find them in the artifacts section."
        unzip logs.zip -d /tmp/imbued-ui-logs
      else
        echo "Received error status code ${status_code} from the log imbue endpoint; is the log imbue handler broken?"
        exit 1
      fi
    when:
      always

storeImbuedUILogs: &storeImbuedUILogs
  store_artifacts:
    path: /tmp/imbued-ui-logs
    destination: imbued-ui-logs


teardownGKE: &teardownGKE
  run:
    name: Tear down GKE cluster
    command: |
      gcloud container clusters delete --async "prevent-ci-${CIRCLE_BUILD_NUM}"
    when: always

collectK8sLogs: &collectK8sLogs
  run:
    name: Collect k8s logs
    command: |
      ./scripts/ci/collect-service-logs.sh central deployment
      ./scripts/ci/collect-service-logs.sh sensor deployment
      ./scripts/ci/collect-service-logs.sh collector daemonset
    when: always

storeK8sLogs: &storeK8sLogs
  store_artifacts:
    path: /tmp/k8s-service-logs
    destination: k8s-service-logs

storeCypressResults: &storeCypressResults
 store_test_results:
    path: ui/cypress/reports

storeCypressVideos: &storeCypressVideos
  store_artifacts:
    path: ui/cypress/videos
    destination: ui-e2e-videos

storeCypressScreenshots: &storeCypressScreenshots
  store_artifacts:
    path: ui/cypress/screenshots
    destination: ui-e2e-screenshots


checkOpenshiftLabel: &checkOpenshiftLabel
  run:
    name: Determine whether to run OpenShift tests
    command: |
      set +e
      .circleci/pr_has_label.sh ci-openshift-tests
      if [ $? -eq 1 ]; then
        echo "Skipping tests because we're on a PR. Apply the ci-openshift-tests label to your PR if you want to run them."
        circleci step halt
      fi


version: 2
jobs:

  build:
    <<: *defaults
    resource_class: large
    steps:
      - checkout
      - setup_remote_docker

      - run:
          name: Refresh base image
          command: docker pull alpine:3.8

      - *restoreDep
      - *restoreUI

      - *setupBazel

      - run:
          name: Build image
          command: make image

      - run:
          name: Push new Docker image
          command: |
            docker login -u $DOCKERHUB_USERNAME -p $DOCKERHUB_PASSWORD docker.io

            export TAG=$(make tag)

            docker push stackrox/main:$TAG | cat
            docker push stackrox/monitoring:$TAG | cat
            docker push stackrox/grpc-server:$TAG | cat

      - save-cache:
          key: *depCacheKey
          paths:
            - /go/pkg/dep

      - save-cache:
          key: *uiCacheKey
          paths:
            - ui/node_modules
            - ~/.cache/Cypress # Cypress binary will be put there, see https://docs.cypress.io/guides/guides/continuous-integration.html#Example-circle-yml-v2-config-file-with-yarn

      - persist_to_workspace:
          root: /go/src/github.com/stackrox/rox
          paths:
          - deps
          - generated
          - ui/deps
          - vendor

      - run:
          name: Comment on PR
          command: |
            wget --quiet https://github.com/joshdk/hub-comment/releases/download/0.1.0-rc4/hub-comment_linux_amd64
            sudo install hub-comment_linux_amd64 /usr/bin/hub-comment

            export TAG=$(make tag)
            hub-comment -template-file .circleci/comment-template.tpl

  unit-tests:
    <<: *defaults
    resource_class: large
    steps:
      - checkout
      - setup_remote_docker

      - *restoreDep
      - *restoreGradle
      - *restoreUI

      - *setupBazel

      - run:
          name: Run unit tests
          command: make test upload-coverage

      - run:
          name: Run style checks
          command: make style

      - store_artifacts:
          path: qa-tests-backend/build/reports/codenarc
          destination: reports/codenarc

      - run:
          name: Ensure that generated files are up to date. (If this fails, run `make go-generated-srcs` and commit the result.)
          command: |
            make go-generated-srcs
            git diff --exit-code HEAD


  k8s-tests:
    <<: *defaults
    environment:
      - LOCAL_PORT: 8000
      - MONITORING_SUPPORT: false
    steps:
      - checkout

      - run:
          name: Determine whether to skip tests
          command: |
            if .circleci/pr_has_label.sh ci-no-k8s-tests; then
              echo "Skipping tests because of the presence of the ci-no-k8s-tests label..."
              circleci step halt
            fi

      - setup_remote_docker

      - attach_workspace:
          at: /go/src/github.com/stackrox/rox

      - *setupGCP
      - *createGKE
      - *deployGKE
      - *portForwardK8s
      - *waitForAPI
      - *waitForSensorK8s

      - run:
          name: API tests
          command: |
            export API_ENDPOINT=localhost:${LOCAL_PORT}
            make -C tests

      - *restoreUI
      - *determineWhetherToRunUIDevServer
      - *runUIDevServer
      - *waitForUIDevServer
      - *runUIE2E

      - *collectImbuedUILogs
      - *storeImbuedUILogs

      - *collectK8sLogs
      - *storeK8sLogs

      - *teardownGKE

      - *storeCypressResults
      - *storeCypressScreenshots
      - *storeCypressVideos

  qa-tests:
    <<: *defaults
    environment:
      - LOCAL_PORT: 8000
      - RUNTIME_SUPPORT: true
      - MONITORING_SUPPORT: false
    steps:
      - checkout

      - run:
          name: Determine whether to skip tests
          command: |
            if .circleci/pr_has_label.sh ci-no-qa-tests; then
              echo "Skipping tests because of the presence of the ci-no-qa-tests label..."
              circleci step halt
            fi

      - setup_remote_docker

      - attach_workspace:
          at: /go/src/github.com/stackrox/rox

      - *setupGCP
      - *createGKE
      - *deployGKE
      - *portForwardK8s
      - *waitForAPI
      - *waitForSensorK8s

      - *restoreGradle
      - run:
          name: QA Automation Platform
          command: |
            export CLUSTER=K8S
            export HOSTNAME=localhost
            export PORT=${LOCAL_PORT}
            if [ "${CIRCLE_BRANCH}" = "master" ]; then
              echo "On master, running all QA tests..."
              make -C qa-tests-backend test
            elif .circleci/pr_has_label.sh ci-all-qa-tests; then
              echo "ci-all-qa-tests label was specified, so running all QA tests..."
              make -C qa-tests-backend test
            else
              echo "On a PR branch, running BAT tests only..."
              make -C qa-tests-backend bat-test
            fi

      - save-cache:
          key: *gradleCacheKey
          paths:
          - ~/.gradle/caches/

      - store_test_results:
          path: qa-tests-backend/build/test-results/test

      - store_artifacts:
          path: ./qa-tests-backend/build/spock-reports
          destination: qa-test-report

      - *collectK8sLogs
      - *storeK8sLogs

      - *teardownGKE

  provision-openshift:
    <<: *defaults
    steps:
      - checkout
      - *checkOpenshiftLabel
      - setup_remote_docker

      - attach_workspace:
          at: /go/src/github.com/stackrox/rox

      - run:
          name: Login to Docker Hub
          command: docker login -u "$DOCKERHUB_USERNAME" -p "$DOCKERHUB_PASSWORD"

      - run:
          name: Generate ephemeral SSH key
          command: |
            mkdir openshift
            ssh-keygen -t rsa -f openshift/id_rsa -C packer -N ''
            cat openshift/id_rsa.pub

      - run:
          name: Pack openshift volume
          command: |
            docker create -v /data --name openshift alpine:3.8 /bin/true
            docker cp openshift/id_rsa     openshift:/data
            docker cp openshift/id_rsa.pub openshift:/data

      - run:
          name: Create cloud resources
          command: |
            docker run --rm -t \
              --volumes-from openshift \
              -e GOOGLE_CREDENTIALS="$OPENSHIFT_TERRAFORM_CREDENTIALS" \
              stackrox/openshift-automation:terraform-0.3.0 create "${CIRCLE_SHA1:0:7}"

      - run:
          name: Unpack openshift volume
          command: |
            docker cp openshift:/data/terraform.tfstate openshift
            docker cp openshift:/data/master            openshift

      - store_artifacts:
          path: openshift
          destination: openshift

      - run:
          name: Create Openshift cluster
          command: |
            docker run --rm -t \
            --volumes-from openshift \
            stackrox/openshift-automation:ansible-0.3.0

      - run:
          name: Unpack openshift volume
          command: |
            docker cp openshift:/data/config openshift
            ls -hl openshift
          when: always

      - store_artifacts:
          path: openshift
          destination: openshift

      - persist_to_workspace:
          root: /go/src/github.com/stackrox/rox
          paths:
          - openshift

      - run:
          name: Destroy Openshift cluster
          command: |
            docker run --rm -t \
              --volumes-from openshift \
              -e GOOGLE_CREDENTIALS="$OPENSHIFT_TERRAFORM_CREDENTIALS" \
              stackrox/openshift-automation:terraform-0.3.0 destroy "${CIRCLE_SHA1:0:7}"
          when: on_fail

  openshift-tests:
    <<: *defaults
    environment:
      - LOCAL_PORT: 8000
      - RUNTIME_SUPPORT: true
    steps:
      - checkout
      - *checkOpenshiftLabel
      - setup_remote_docker

      - run:
          name: Login to Docker Hub
          command: docker login -u "$DOCKERHUB_USERNAME" -p "$DOCKERHUB_PASSWORD"

      - attach_workspace:
          at: /go/src/github.com/stackrox/rox

      - run:
          name: Configure Deployment Environment
          command: |
            echo "export CLAIRIFY_IMAGE_TAG=0.4"                            >> "$BASH_ENV"
            echo "export OPENSHIFT_HOST=$(cat openshift/master)"            >> "$BASH_ENV"
            echo "export ROX_IMAGE_REGISTRY=docker.io"                      >> "$BASH_ENV"
            echo "export MAIN_IMAGE_TAG=$(make tag)"                        >> "$BASH_ENV"
            echo "export REGISTRY_PASSWORD=$DOCKERHUB_PASSWORD"             >> "$BASH_ENV"
            echo "export REGISTRY_USERNAME=$DOCKERHUB_USERNAME"             >> "$BASH_ENV"

      - run:
          name: Configure Kubectl
          command: |
            cp openshift/config ~/.kube/
            context="$(kubectl config get-contexts -o name | grep -v master)"
            kubectl config use-context "$context"
            kubectl get nodes

      - run:
          name: Configure SSH
          command: |
            mkdir -p ~/.ssh
            install -m 0400 openshift/id_rsa openshift/id_rsa.pub ~/.ssh
            ssh -o StrictHostKeyChecking=no "stackrox@$OPENSHIFT_HOST" uname -a

      - run:
          name: Generate Installation Bundle
          command: |
            docker run -i "stackrox/main:$MAIN_IMAGE_TAG" deploy openshift none > /tmp/openshift.zip
            unzip /tmp/openshift.zip -d openshift

      - run:
          name: Deploy to remote cluster
          command: |
            ./deploy/openshift/deploy.sh
            oc -n stackrox get all

      - *portForwardK8s
      - *waitForAPI
      - *waitForSensorK8s

#      # TODO: make -C tests hangs when run
#      - run:
#          name: API tests
#          command: |
#            export API_ENDPOINT=localhost:${LOCAL_PORT}
#            make -C tests

      - *restoreUI
      - *determineWhetherToRunUIDevServer
      - *runUIDevServer
      - *waitForUIDevServer
      - *runUIE2E

      - *collectImbuedUILogs
      - *storeImbuedUILogs

      - *collectK8sLogs
      - *storeK8sLogs

      - *storeCypressResults
      - *storeCypressScreenshots
      - *storeCypressVideos

      - run:
          name: Pack openshift volume
          command: |
            docker create -v /data --name openshift alpine:3.8 /bin/true
            docker cp openshift/id_rsa            openshift:/data
            docker cp openshift/id_rsa.pub        openshift:/data
            docker cp openshift/terraform.tfstate openshift:/data
          when: always

      - run:
          name: Destroy Openshift cluster
          command: |
            docker run --rm -t \
              --volumes-from openshift \
              -e GOOGLE_CREDENTIALS="$OPENSHIFT_TERRAFORM_CREDENTIALS" \
              stackrox/openshift-automation:terraform-0.3.0 destroy "${CIRCLE_SHA1:0:7}"
          when: always

  oss-audit:
    <<: *defaults
    steps:
      - checkout

      - run:
          name: Install ossls
          working_directory: /tmp
          command: |
            wget --quiet https://github.com/gruntwork-io/fetch/releases/download/v0.3.2/fetch_linux_amd64
            sudo install fetch_linux_amd64 /usr/bin/fetch
            export GITHUB_OAUTH_TOKEN="$GITHUB_TOKEN"
            fetch --repo="https://github.com/stackrox/ossls" --tag="0.2.0" --release-asset="ossls_linux_amd64" .
            sudo install ossls_linux_amd64 /usr/bin/ossls
            ossls -version

      - *restoreDep
      - *restoreUI

      - run:
          name: Install Go dependencies
          command: dep ensure

      - run:
          name: Install Javascript dependencies
          working_directory: ui
          command: yarn install --frozen-lockfile

      - run:
          name: Audit dependencies
          command: ossls -audit

  push-release:
    <<: *defaults
    resource_class: small
    steps:
      - checkout
      - setup_remote_docker

      - run:
          name: Push image into stackrox.io
          command: |
            docker login -u "$DOCKERHUB_USERNAME" -p "$DOCKERHUB_PASSWORD"
            docker login -u "$DOCKERHUB_USERNAME" -p "$DOCKERHUB_PASSWORD" stackrox.io

            export TAG=$(make tag)

            docker pull docker.io/stackrox/main:$TAG
            docker tag docker.io/stackrox/main:$TAG stackrox.io/main:$TAG
            docker push stackrox.io/main:$TAG | cat

            docker pull docker.io/stackrox/monitoring:$TAG
            docker tag docker.io/stackrox/monitoring:$TAG stackrox.io/monitoring:$TAG
            docker push stackrox.io/monitoring:$TAG | cat


workflows:
  version: 2
  build_all:
    jobs:
      - build:
          filters:
            tags:
              only: /.*/
      - unit-tests:
          filters:
            tags:
              only: /.*/
      - k8s-tests:
          requires:
            - build
          filters:
            tags:
              only: /.*/
      - qa-tests:
          requires:
            - build
          filters:
            tags:
              only: /.*/
      - provision-openshift:
          filters:
            tags:
              only:
              - /.*/
      - openshift-tests:
          requires:
            - build
            - provision-openshift
          filters:
            tags:
              only:
              - /.*/
      - oss-audit:
          filters:
            tags:
              only: /.*/
      # Push release only on tags.
      - push-release:
          requires:
            - build
          filters:
            branches:
              ignore: /.*/
            tags:
              only: /.*/
