package main

import (
	"errors"
	"flag"
	"fmt"
	"os"

	"github.com/grpc-ecosystem/go-grpc-middleware/util/metautils"
	"github.com/stackrox/rox/cmd/roxdetect/report"
	"github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/pkg/clientconn"
	"github.com/stackrox/rox/pkg/images/utils"
	"golang.org/x/net/context"
)

const tokenEnv = "STACKROX_TOKEN"

var (
	version = "development"
	central = flag.String("central", "localhost:8443", "Host and port endpoint where Central is located.")
	image   = flag.String("image", "", "the image name and reference (e.g. nginx:latest or nginx@sha256:...)")

	versionFlag = flag.Bool("version", false, `Prints the version "`+version+`" and exits.`)
	json        = flag.Bool("json", false, "Output policy results as json.")
)

func main() {
	// Parse the input flags.
	flag.Parse()

	if *versionFlag {
		fmt.Println(version)
		os.Exit(2)
	}

	if err := mainCmd(); err != nil {
		fmt.Fprintf(os.Stderr, "roxdetect: %s\n", err.Error())
		os.Exit(1)
	}
}

func mainCmd() error {
	// Read token from ENV.
	token, exists := os.LookupEnv(tokenEnv)
	if !exists {
		return errors.New("the STACKROX_TOKEN environment variable must be set to a token generated by stackrox for a Remote host")
	}

	// Get the violated policies for the input data.
	violatedPolicies, err := getViolatedPolicies(token)
	if err != nil {
		return err
	}

	// If json mode was given, print results (as json) and immediately return.
	if *json {
		return report.JSON(os.Stdout, violatedPolicies)
	}

	// Print results in human readable mode.
	if err = report.Pretty(os.Stdout, violatedPolicies); err != nil {
		return err
	}

	// Check if any of the violated policies have an enforcement action that
	// fails the CI build.
	for _, policy := range violatedPolicies {
		if report.EnforcementFailedBuild(policy) {
			return errors.New("Violated a policy with CI enforcement set")
		}
	}
	return nil
}

// Fetch the alerts for the inputs and convert them to a list of Policies that are violated.
func getViolatedPolicies(token string) ([]*v1.Policy, error) {
	alerts, err := getAlerts(token)
	if err != nil {
		return nil, err
	}

	var policies []*v1.Policy
	for _, alert := range alerts {
		policies = append(policies, alert.GetPolicy())
	}
	return policies, nil
}

// Get the alerts for the command line inputs.
func getAlerts(token string) ([]*v1.Alert, error) {
	// Attempt to construct the request first since it is the cheapest op.
	image, err := buildRequest()
	if err != nil {
		return nil, err
	}

	// Create the connection to the central detection service.
	conn, err := clientconn.UnauthenticatedGRPCConnection(*central)
	if err != nil {
		return nil, err
	}
	service := v1.NewDetectionServiceClient(conn)

	// Build context with token header.
	md := metautils.NiceMD{}
	md = md.Add("authorization", "Bearer "+token)
	ctx := md.ToOutgoing(context.Background())

	// Call detection and return the returned alerts.
	response, err := service.DetectBuildTime(ctx, image)
	if err != nil {
		return nil, err
	}
	return response.GetAlerts(), nil
}

// Use inputs to generate an image name for request.
func buildRequest() (*v1.Image, error) {
	if *image == "" {
		return nil, fmt.Errorf("image name must be set")
	}
	img, err := utils.GenerateImageFromStringWithError(*image)
	if err != nil {
		return nil, fmt.Errorf("could not parse image '%s': %s", *image, err)
	}
	return img, nil
}
