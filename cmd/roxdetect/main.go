package main

import (
	"flag"
	"fmt"
	"os"

	"github.com/grpc-ecosystem/go-grpc-middleware/util/metautils"
	"github.com/stackrox/rox/cmd/roxdetect/report"
	"github.com/stackrox/rox/generated/api/v1"
	"github.com/stackrox/rox/pkg/clientconn"
	"golang.org/x/net/context"
)

const tokenEnv = "STACKROX_TOKEN"

var (
	passFail = flag.Bool("pass-fail", true, "exit 1 on any critical policy failures")
	central  = flag.String("central", "localhost:8080", "endpoint where central is available")
	digest   = flag.String("digest", "", "the sha256 digest for the image")
	registry = flag.String("registry", "", "registry where the image is uploaded")
	remote   = flag.String("remote", "", "the remote name of the image")
	tag      = flag.String("tag", "", "the tag for the image")
)

func main() {
	// Parse the input flags.
	flag.Parse()

	// Read token from ENV.
	token, exists := os.LookupEnv(tokenEnv)
	if !exists {
		fmt.Println(fmt.Errorf("the STACKROX_TOKEN environment variable must be set to a token generated by stackrox for a Remote host"))
		return
	}

	// Get the violated policies for the input data.
	violatedPolicies, err := getViolatedPolicies(token)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	// Run requested operations.
	if *passFail {
		err = report.Pretty(os.Stdout, violatedPolicies)
	} else {
		err = report.JSON(os.Stdout, violatedPolicies)
	}
	if err != nil {
		os.Exit(1)
	}

	// Exit with a status of 1 if any of the violated policies were of a
	// "critical" severity level.
	if *passFail && criticalViolations(violatedPolicies) {
		os.Exit(1)
	}
}

// criticalViolations returns true if any of the given policies are of a
// "critical" severity level.
func criticalViolations(policies []*v1.Policy) bool {
	for _, policy := range policies {
		if policy.GetSeverity() == v1.Severity_CRITICAL_SEVERITY {
			return true
		}
	}
	return false
}

// Fetch the alerts for the inputs and convert them to a list of Policies that are violated.
func getViolatedPolicies(token string) ([]*v1.Policy, error) {
	alerts, err := getAlerts(token)
	if err != nil {
		return nil, err
	}

	var policies []*v1.Policy
	for _, alert := range alerts {
		policies = append(policies, alert.GetPolicy())
	}
	return policies, nil
}

// Get the alerts for the command line inputs.
func getAlerts(token string) ([]*v1.Alert, error) {
	// Attempt to construct the request first since it is the cheapest op.
	image, err := buildRequest()
	if err != nil {
		return nil, err
	}

	// Create the connection to the central detection service.
	conn, err := clientconn.UnauthenticatedGRPCConnection(*central)
	if err != nil {
		return nil, err
	}
	service := v1.NewDetectionServiceClient(conn)

	// Build context with token header.
	md := metautils.NiceMD{}
	md = md.Add("authorization", "Bearer "+token)
	ctx := md.ToOutgoing(context.Background())

	// Call detection and return the returned alerts.
	response, err := service.DetectBuildTime(ctx, image)
	if err != nil {
		return nil, err
	}
	return response.GetAlerts(), nil
}

// Use inputs to generate an image name for request.
func buildRequest() (*v1.Image, error) {
	im := v1.ImageName{
		Remote:   *remote,
		Registry: *registry,
		Tag:      *tag,
	}

	switch {
	case *registry == "":
		return nil, fmt.Errorf("image registry must be set, or we don't know where to get metadata from")
	case *remote == "":
		return nil, fmt.Errorf("image remote must be set, or we don't know which image in the registry to process")
	case *digest == "" && *tag == "":
		return nil, fmt.Errorf("an image tag, digest, or both must be set, otherwise we don't know which version of the image to process")
	}

	return &v1.Image{
		Id:   *digest,
		Name: &im,
	}, nil
}
