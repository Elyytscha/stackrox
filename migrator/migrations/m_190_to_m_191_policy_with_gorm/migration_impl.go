// Code generated by pg-bindings generator. DO NOT EDIT.

package m190tom191

import (
	"github.com/pkg/errors"
	"github.com/stackrox/rox/generated/storage"
	"github.com/stackrox/rox/migrator/migrations/m_190_to_m_191_policy_with_gorm/schema"
	"github.com/stackrox/rox/migrator/types"
	"github.com/stackrox/rox/pkg/logging"
	"github.com/stackrox/rox/pkg/postgres/pgutils"
	"gorm.io/gorm/clause"
)

var (
	batchSize = 2000
	log       = logging.LoggerForModule()
)

// TODO(dont-merge):
//  - remove the gen.go file generated in ../{OBJECT}/store

// TODO(dont-merge): Determine if this change breaks a previous releases database.
// If so increment the `MinimumSupportedDBVersionSeqNum` to the `CurrentDBVersionSeqNum` of the release immediately
// following the release that cannot tolerate the change in pkg/migrations/internal/fallback_seq_num.go.
//
// For example, in 4.2 a column `column_v2` is added to replace the `column_v1` column in 4.1.
// All the code from 4.2 onward will not reference `column_v1`. At some point in the future a rollback to 4.1
// will not longer be supported and we want to remove `column_v1`. To do so, we will upgrade the schema to remove
// the column and update the `MinimumSupportedDBVersionSeqNum` to be the value of `CurrentDBVersionSeqNum` in 4.2
// as 4.1 will no longer be supported. The migration process will inform the user of an error when trying to migrate
// to a software version that can no longer be supported by the database.

func migrate(database *types.Databases) error {
	// TODO(dont-merge): Update migration code as required
	// The generated migration handles the simple case of promoting a field to a column on the top level table.  This
	// provides the base.  Enhance and build out to suit the needs of your specific migration case.

	db := database.GormDB
	pgutils.CreateTableFromModel(database.DBCtx, db, schema.CreateTablePoliciesStmt)
	db = db.WithContext(database.DBCtx).Table(schema.PoliciesTableName)

	rows, err := db.Rows()
	if err != nil {
		return errors.Wrapf(err, "failed to iterate table %s", schema.PoliciesTableName)
	}
	defer func() { _ = rows.Close() }()

	var convertedRecords []*schema.Policies
	var count int
	for rows.Next() {
		var record *schema.Policies
		if err = db.ScanRows(rows, &record); err != nil {
			return errors.Wrap(err, "failed to scan rows")
		}

		// TODO(dont-merge): Make any necessary updates to the record

		recordProto, err := schema.ConvertPolicyToProto(record)
		if err != nil {
			return errors.Wrapf(err, "failed to convert %+v to proto", record)
		}

		converted, err := schema.ConvertPolicyFromProto(recordProto)
		if err != nil {
			return errors.Wrapf(err, "failed to convert from proto %+v", recordProto)
		}
		convertedRecords = append(convertedRecords, converted)
		count++

		if len(convertedRecords) == batchSize {
			// Upsert converted blobs
			if err = db.Clauses(clause.OnConflict{UpdateAll: true}).Model(schema.CreateTablePoliciesStmt.GormModel).Create(&convertedRecords).Error; err != nil {
				return errors.Wrapf(err, "failed to upsert converted %d objects after %d upserted", len(convertedRecords), count-len(convertedRecords))
			}
		convertedRecords = convertedRecords[:0]
		}
	}

	if err := rows.Err(); err != nil {
		return errors.Wrapf(err, "failed to get rows for %s", schema.PoliciesTableName)
	}

	if len(convertedRecords) > 0 {
		if err = db.Clauses(clause.OnConflict{UpdateAll: true}).Model(schema.CreateTablePoliciesStmt.GormModel).Create(&convertedRecords).Error; err != nil {
			return errors.Wrapf(err, "failed to upsert last %d objects", len(convertedRecords))
		}
	}
	log.Infof("Converted %d records", count)

	return nil
}

// TODO(dont-merge): Write the additional code to support the migration

// TODO(dont-merge): remove any pending TODO
